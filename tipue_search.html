{
    "pages": [
        {
            "title": "Programming Phoenix勉強その7", 
            "text":"その7です。 ここからchapter5です。認証周りをやるらしいです。 パスワードのハッシュ化 まずはパスワードのハッシュ化を行います。必要なライブラリをインストールするために mix.exs に以下のように追記を行います。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ... def application do [mod: {Rumbl, []}, applications: [:phoenix, :phoenix_pubsub, :phoenix_html, :cowboy, :logger, :gettext, :phoenix_ecto, :postgrex, :comeonin]] # comeoninを追加 end ... defp deps do [{:phoenix, &#34;~&gt; 1.2.1&#34;}, {:phoenix_pubsub, &#34;~&gt; 1.0&#34;}, {:phoenix_ecto, &#34;~&gt; 3.0&#34;}, {:postgrex, &#34;&gt;= 0.0.0&#34;}, {:phoenix_html, &#34;~&gt; 2.6&#34;}, {:phoenix_live_reload, &#34;~&gt; 1.0&#34;, only: :dev}, {:gettext, &#34;~&gt; 0.11&#34;}, {:cowboy, &#34;~&gt; 1.0&#34;}, {:comeonin, &#34;~&gt; 2.0&#34;}] # 追加 end application に対して追加しているのはこのアプリの依存ライブラリを書いているようです。 comeonin とか言うライブラリを追加しています。 リポジトリ を見るとそのまんまパスワードをハッシュ化してくれるライブラリだとわかります。 mix deps.get で追加できたらモデルでこいつを使うように変更してやります。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24def changeset(model, params \\ %{}) do model |&gt; cast(params, [:name, :username]) # 更新予定のパラメータカラムを第三引数でとる(?) |&gt; validate_required([:name, :username]) # このリストがcastが返すchangesetに存在するか検証 |&gt; validate_length(:username, min: 1, max: 20) end def registration_changeset(model, params) do model |&gt; changeset(params) |&gt; cast(params, [:password]) |&gt; validate_required([:password]) |&gt; validate_length(:password, min: 6, max: 100) |&gt; put_pass_hash() end defp put_pass_hash(changeset) do case changeset do %Ecto.Changeset{valid?: true, changes: %{password: pass}} -&gt; put_change(changeset, :password_hash, Comeonin.Bcrypt.hashpwsalt(pass)) _ -&gt; changeset end end Ecto の最新版を使っているので書籍と若干異なっています。新しい方の Ecto では cast/4 は推奨されなくなっているようです。 なので、 Phoenixのガイド とか、 Ectoのドキュメント とかを見て適当に修正してます。（このやり方でいいか不安ですが・・・） また、 :empty もWarningになるので、空のハッシュに変えています。 ついでに create アクションで User.changeset の部分を User.registration_changeset に変更します。 ここまでやってMacだとOKでしたが、Windowsだとエラーになりました。 Windowsでのエラー（comeonin） Windowsから comeonin を使おうとするとコンパイルを促すエラーが出るので ここ を参考にコンパイルします。 ちなみにVisualStudioインストールしてあったので最下部付近にあるVSインストール済みの場合の方法を取っています。 VSに付属している開発者コマンドプロンプトを起動します。 開発者コマンドプロンプト上で以下のコマンドを実行しておきます。 1&gt; vcvarsall.bat amd64 vcvarsall.bat にパスが通ってない場合は、適当にフルパスで指定すればいいと思います。これを行わなくてもコンパイル自体は出来ますが、実行時にエラーになりました。（ vcvarsall.bat については MSDN ） 本プロジェクト（ rumbl ）のディレクトリまで移動して以下のコマンドを実行します。 1rumbl &gt; mix deps.compile 自分の環境ではこれでうまくいきました。 Plugについて Plug を使ってログイン機能を作る前に Plug についてちょっと掘ります。 Plug にはモジュールプラグと関数プラグの二種類が存在する。 モジュールプラグは名前の通り幾つかの関数を集めたモジュールのプラグ 関数プラグは関数名をアトムとして指定したプラグ ログイン機能としてモジュールプラグを作成します。 モジュールプラグ モジュールプラグとして設定するモジュールには init/1 関数と call/2 関数が必要とされます。 以下は何もしないモジュールプラグの例です。 1 2 3 4 5 6 7 8 9defmodule NothingPlug do def init(opts) do opts end def call(conn, _opts) do conn end end call 関数の引数を見るとわかりますが、モジュールプラグは conn を変換するようです。 Plug.Connについて(conn) Plug.Conn が持つフィールドについて見てみます。 書籍の方には色々書いてありますが割愛します。 Plug.Connの公式ドキュメント を参照して下さい。ここではリクエストフィールドが持つものだけを見てみます。 host リクエストのホスト名 ex) www.pragprog.com method リクエストのWebメソッド（GETとかPOSTとか） path_info パスを分割したリスト req_headers リクエストヘッダ scheme プロトコル（httpとか） Webのリクエスト周りに関係するものが存在していることがわかります。 認証プラグの実装 やっと認証用のプラグを実装します。 controllers/auth.ex を以下の内容で実装します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17defmodule Rumbl.Auth do import Plug.Conn def init(opts) do # キーワードリストから:repoの箇所の値を取得する # 無ければexception(つまりは必須) Keyword.fetch!(opts, :repo) end def call(conn, repo) do user_id = get_session(conn, :user_id) user = user_id &amp;&amp; repo.get(Rumbl.User, user_id) # assignでconnを変更する(importされた関数) # これによって:current_userがコントローラやビューで使えるようになる assign(conn, :current_user, user) end end コメント通りなので余り言うことはないです。 init で repo を取得してそれが conn の第二引数に渡されるようです。セッションにあるユーザIDからユーザを取得しています。 パイプラインの流れの一部として処理してほしいので router.ex を以下のように変更します。 1 2 3 4 5 6 7 8pipeline :browser do plug :accepts, [&#34;html&#34;] plug :fetch_session plug :fetch_flash plug :protect_from_forgery plug :put_secure_browser_headers plug Rumbl.Auth, repo: Rumbl.Repo # 追加 end アクセス制限の実装 Plug は出来たのでアクセス制限とログインを作ります。ログインしない限りは :index アクションと :show アクションにアクセス出来ないようにします。 user_controller.ex を以下のように変更します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25defmodule Rumbl.UserController do ... def index(conn, _params) do case authenticate(conn) do # 構造体connのhaltedメンバのパターンマッチによる振り分け %Plug.Conn{halted: true} = conn -&gt; conn conn -&gt; users = Repo.all(Rumbl.User) render conn, &#34;index.html&#34;, users: users end end ... defp authenticate(conn) do # Plugで追加したassignの呼び出しが可能かどうか if conn.assigns.current_user do conn else conn |&gt; put_flash(:error, &#34;You must be logged in to access that page&#34;) |&gt; redirect(to: page_path(conn, :index)) |&gt; halt() end end end 先程の Plug で変更した値を authenticate/1 関数で使っています。また、 :index アクションのアクセス時に authenticate 関数で認証済みかチェック掛けています。 authenticate の関数プラグ化 user_controller.ex の Rumbl.Web の直下のあたりに以下を追加します。 1plug :authenticate when action in [:index, :show] また、 index アクションを case 文を使う以前のものに戻しておきます。 authenticate 関数も以下のように2引数にしておきます。 1 2 3 4 5 6 7 8 9 10 11defp authenticate(conn, _opts) do # Plugで追加したassignの呼び出しが可能かどうか if conn.assigns.current_user do conn else conn |&gt; put_flash(:error, &#34;You must be logged in to access that page&#34;) |&gt; redirect(to: page_path(conn, :index)) |&gt; halt() end end _opts を追加しただけです。関数 Plug 化したためです。 Plug をマクロ展開したときの例が出てますが割愛します。 ログインの実装 認証までしか無いので実際のログイン処理を実装します。取り敢えず create アクションでユーザが作成された時に自動でログインするようにしてみます。 先程作った auth.ex に以下の関数を追加します。 1 2 3 4 5 6def login(conn, user) do conn |&gt; assign(:current_user, user) |&gt; put_session(:user_id, user.id) |&gt; configure_session(renew: true) # セッションキーとかを新しくしている(セキュリティのため) end 次に create アクションでこの関数を呼び出すようにしてやります。 1 2 3 4 5 6 7 8 9 10 11 12def create(conn, %{&#34;user&#34; =&gt; user_params}) do changeset = User.registration_changeset(%User{}, user_params) case Repo.insert(changeset) do {:ok, user} -&gt; conn |&gt; Rumbl.Auth.login(user) # ユーザを作成したらログイン |&gt; put_flash(:info, &#34;#{user.name} created!&#34;) |&gt; redirect(to: user_path(conn, :index)) {:error, changeset} -&gt; render(conn, &#34;new.html&#34;, changeset: changeset) end end これで完了です。 ログイン画面の実装 ここまででログインするための素材は揃ったので、ログイン/ログアウト画面を作ります。今まで作ったものの合わせ技なので一気に行きます。 session_controller.ex を実装します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26defmodule Rumbl.SessionController do use Rumbl.Web, :controller def new(conn, _) do render conn, &#34;new.html&#34; end def create(conn, %{&#34;session&#34; =&gt; %{&#34;username&#34; =&gt; user, &#34;password&#34; =&gt; pass}}) do case Rumbl.Auth.login_by_username_add_pass(conn, user, pass, repo: Repo) do {:ok, conn} -&gt; conn |&gt; put_flash(:info, &#34;Welcome back!&#34;) |&gt; redirect(to: page_path(conn, :index)) {:error, _reason, conn} -&gt; conn |&gt; put_flash(:error, &#34;Invalid username/password combination&#34;) |&gt; render(&#34;new.html&#34;) end end def delete(conn, _) do conn |&gt; Rumbl.Auth.logout() |&gt; redirect(to: page_path(conn, :index)) end end session_view.ex も作っておきます。内容は割愛します。関数などは定義しなくて良いです。 router.ex も上で作った session_controller.ex 用に追加しておきます。 1 2 3 4 5 6 7scope &#34;/&#34;, Rumbl do pipe_through :browser # Use the default browser stacks. get &#34;/&#34;, PageController, :index resources &#34;/users&#34;, UserController, only: [:index, :show, :new, :create] resources &#34;/sessions&#34;, SessionController, only: [:new, :create, :delete] # 追加 end usernameとpasswordでログインするための関数とログアウト用の関数を auth.ex に用意しておきます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23... import Comeonin.Bcrypt, only: [checkpw: 2, dummy_checkpw: 0] ... def logout(conn) do configure_session(conn, drop: true) end def login_by_username_add_pass(conn, username, given_pass, opts) do repo = Keyword.fetch!(opts, :repo) user = repo.get_by(Rumbl.User, username: username) # 複数の値で分岐しているためcaseではなくcond(caseは与えられた1つの値に対する分岐) cond do user &amp;&amp; checkpw(given_pass, user.password_hash) -&gt; {:ok, login(conn, user)} user -&gt; {:error, :unauthorized, conn} true -&gt; dummy_checkpw() {:error, :not_found, conn} end end ログイン画面用のテンプレートも作ります。まず session/new.html.eex を以下のように実装します。 1 2 3 4 5 6 7 8 9 10 11 12&lt;h1&gt;Login&lt;/h1&gt; &lt;%= form_for @conn, session_path(@conn, :create), [as: :session], fn f-&gt; %&gt; &lt;div class=&#34;form-group&#34;&gt; &lt;%= text_input f, :username, placeholder: &#34;Username&#34;, class: &#34;form-control&#34; %&gt; &lt;/div&gt; &lt;div class=&#34;form-group&#34;&gt; &lt;%= password_input f, :password, placeholder: &#34;Password&#34;, class: &#34;form-control&#34; %&gt; &lt;/div&gt; &lt;%= submit &#34;Log in&#34;, class: &#34;btn btn-primary&#34; %&gt; &lt;% end %&gt; 最後に今まで作ったもののリンクを表示します。 layout/app.html.eex を以下のように変更します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16&lt;header class=&#34;header&#34;&gt; &lt;ol class=&#34;breadcrumb text-right&#34;&gt; &lt;!-- assignsで突っ込んだものが使えている --&gt; &lt;%= if @current_user do %&gt; &lt;li&gt;&lt;%= @current_user.username %&gt;&lt;/li&gt; &lt;li&gt; &lt;%= link &#34;Log out&#34;, to: session_path(@conn, :delete, @current_user), method: &#34;delete&#34; %&gt; &lt;/li&gt; &lt;% else %&gt; &lt;li&gt;&lt;%= link &#34;Register&#34;, to: user_path(@conn, :new) %&gt;&lt;/li&gt; &lt;li&gt;&lt;%= link &#34;Log in&#34;, to: session_path(@conn, :new) %&gt;&lt;/li&gt; &lt;% end %&gt; &lt;/ol&gt; &lt;span class=&#34;logo&#34;&gt;&lt;/span&gt; &lt;/header&gt; これでOKなはずです。 まとめ Plug.Conn を使ったセッションやコネクションの管理はスマートだし中身が分かればわかりやすいと思いました。関数の引数に毎回 conn が出てきちゃいますが・・・ 本のおかげかもしれませんが余りブラックボックスな部分を残さないよう理解出来ている感があるのが良いです。 関数型だけあってかロジックを関数毎に分離しているのがとても良かったです。書いてて理解し易い気がします。 1記事がやたらと長くなりましたが実験ということで・・・", 
            "tags": "programming", 
            "loc": "https://zonuko.github.io/posts/2017/01/19/programming-phoenix7/"
        },
        {
            "title": "Programming Phoenix勉強その6", 
            "text":"その6です。 実際にDBを操作するところからです。 新規ユーザ生成処理 Rumbl.UserController に以下の関数を実装します。 1 2 3 4def new(conn, _params) do changeset = User.changeset(%User{}) render conn, &#34;new.html&#34;, changeset: changeset end changeset 周りとかが謎めいていますが一旦置いときます。単に自分が今理解してないだけですが・・・ DBの操作とそれ以外の検証とかエラーとかセキュリティとかを分離するのに役立つっぽいです。 user.ex に上記で利用している User.changeset 関数を実装します。 1 2 3 4 5def changeset(model, params \\ :empty) do model |&gt; cast(params, ~w(name username), []) |&gt; validate_length(:username, min: 1, max: 20) end Ecto を使う関数を定義しました。 cast で Ecto.changeset を生成してバリデーションチェックを掛けているようです。 前準備 :new アクションを実装する前に前準備をします。 今まで書いてあったルーティング設定を消して以下を追加します。まぁ説明不要だと思います。 1resouces &#34;/users&#34;, UserController, only: [:index, :show, :new, :create] テンプレート実装 :new に対応するテンプレートを適当に作ります。 1 2 3 4 5 6 7 8 9 10 11 12 13 14&lt;h1&gt;New User&lt;/h1&gt; &lt;%= form_for @changeset, user_path(@conn, :create), fn f -&gt; %&gt; &lt;div class=&#34;form-group&#34;&gt; &lt;%= text_input f, :name, placeholder: &#34;Name&#34;, class: &#34;form-control&#34; %&gt; &lt;/div&gt; &lt;div class=&#34;form-group&#34;&gt; &lt;%= text_input f, :username, placeholder: &#34;Username&#34;, class: &#34;form-control&#34; %&gt; &lt;/div&gt; &lt;div class=&#34;form-group&#34;&gt; &lt;%= password_input f, :password, placeholder: &#34;Password&#34;, class: &#34;form-control&#34; %&gt; &lt;/div&gt; &lt;%= submit &#34;Create User&#34;, class: &#34;btn, btn-primary&#34; %&gt; &lt;% end %&gt; ここまでやって起動したところ、何やらWarningが出たので解消します。 1 2 3 4 5 6 7 8 9 10 11warning: `Ecto.Changeset.cast/4` is deprecated, please use `cast/3` + `validate_required/3` instead (rumbl) web/models/user.ex:15: Rumbl.User.changeset/2 (rumbl) web/controllers/user_controller.ex:16: Rumbl.UserController.new/2 (rumbl) web/controllers/user_controller.ex:1: Rumbl.UserController.action/2 (rumbl) web/controllers/user_controller.ex:1: Rumbl.UserController.phoenix_controller_pipeline/2 warning: passing :empty to Ecto.Changeset.cast/3 is deprecated, please pass an empty map or :invalid instead (rumbl) web/models/user.ex:15: Rumbl.User.changeset/2 (rumbl) web/controllers/user_controller.ex:16: Rumbl.UserController.new/2 (rumbl) web/controllers/user_controller.ex:1: Rumbl.UserController.action/2 (rumbl) web/controllers/user_controller.ex:1: Rumbl.UserController.phoenix_controller_pipeline/2 Warningの解消 Ecto とかのバージョの違いのせいか2つWarningが出てました。1つは user.ex の changeset/2 関数のデフォルト引数で :empty としていた部分です。 その部分を以下のように変えます。 1def changeset(model, params \\ %{}) do 単純に空の Map にしただけですね。 もう1つ cast/4 関数を呼び出している部分でもWarningが出ているので修正します。 1 2 3 4model |&gt; cast(params, [:name, :username]) |&gt; validate_required([:name, :username]) |&gt; validate_length(:username, min: 1, max: 20) ここ とか ここらへん 参考にしましたが英語力の無さ故にあってるかわからないです。誰か教えて!! パラメータの名前的にはあってそうですが・・・ また、これを見ると cast が changeset を返してきて、それに対してバリデーションを掛けているのがわかります。 Createアクションの実装 new アクションを実装したので実際にDBにインサートする create アクションを実装します。 1 2 3 4 5 6 7 8 9 10 11def create(conn, %{&#34;user&#34; =&gt; user_params}) do changeset = User.changeset(%User{}, user_params) case Repo.insert(changeset) do {:ok, user} -&gt; conn |&gt; put_flash(:info, &#34;#{user.name} created!&#34;) |&gt; redirect(to: user_path(conn, :index)) {:error, changeset} -&gt; render(conn, &#34;new.html&#34;, changeset: changeset) end end あんまり説明することはないですが、 conn からのパイプラインで作成後の template 用の処理を読んでる点くらいでしょうか。パイプラインが最大の特徴かもしれませんが・・・ また、 new.html.eex もエラーを表示するように変えます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22&lt;h1&gt;New User&lt;/h1&gt; &lt;%= if @changeset.action do %&gt; &lt;div class=&#34;alert alert-danger&#34;&gt; &lt;p&gt;Oops, something went wrong! Please check the errors below.&lt;/p&gt; &lt;/div&gt; &lt;% end %&gt; &lt;%= form_for @changeset, user_path(@conn, :create), fn f -&gt; %&gt; &lt;div class=&#34;form-group&#34;&gt; &lt;%= text_input f, :name, placeholder: &#34;Name&#34;, class: &#34;form-control&#34; %&gt; &lt;%= error_tag f, :name %&gt; &lt;/div&gt; &lt;div class=&#34;form-group&#34;&gt; &lt;%= text_input f, :username, placeholder: &#34;Username&#34;, class: &#34;form-control&#34; %&gt; &lt;%= error_tag f, :username %&gt; &lt;/div&gt; &lt;div class=&#34;form-group&#34;&gt; &lt;%= password_input f, :password, placeholder: &#34;Password&#34;, class: &#34;form-control&#34; %&gt; &lt;%= error_tag f, :password %&gt; &lt;/div&gt; &lt;%= submit &#34;Create User&#34;, class: &#34;btn, btn-primary&#34; %&gt; &lt;% end %&gt; error_tag/2 関数は view の error_helpers.ex に定義されている関数です。 Changesetについて このchapterの最後に changeset について触れられています。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20iex(1)&gt; changeset = Rumbl.User.changeset(%Rumbl.User{username: &#34;eric&#34;}) #Ecto.Changeset&lt;action: nil, changes: %{}, errors: [name: {&#34;can&#39;t be blank&#34;, [validation: :required]}], data: #Rumbl.User&lt;&gt;, valid?: false&gt; iex(2)&gt; changeset #Ecto.Changeset&lt;action: nil, changes: %{}, errors: [name: {&#34;can&#39;t be blank&#34;, [validation: :required]}], data: #Rumbl.User&lt;&gt;, valid?: false&gt; iex(3)&gt; import Ecto.Changeset Ecto.Changeset iex(4)&gt; changeset.changes %{} iex(5)&gt; changeset = put_change(changeset, :username, &#34;ericmj&#34;) #Ecto.Changeset&lt;action: nil, changes: %{username: &#34;ericmj&#34;}, errors: [name: {&#34;can&#39;t be blank&#34;, [validation: :required]}], data: #Rumbl.User&lt;&gt;, valid?: false&gt; iex(6)&gt; changeset.changes %{username: &#34;ericmj&#34;} iex(7)&gt; get_change(changeset, :username) &#34;ericmj&#34; これを見ると changeset はバリデーション以外にも変更をの追跡と保持を行っていることがわかります。 まとめ 簡単なDB操作を行いました。今回はテンプレート周りはおまけだったように思います。 何かしらフレームワーク触ったことあればそんなに違和感はなく使えると思います。 ずっと changeset が謎だったんですが、少し理解できたと思います。 基本的なところは結構網羅されてきたんじゃないかと思いますのでサクサク行きたいです。", 
            "tags": "programming", 
            "loc": "https://zonuko.github.io/posts/2017/01/11/programming-phoenix6/"
        },
        {
            "title": "Programming Phoenix勉強その5", 
            "text":"その5です。ここからChapter4です。 Ecto を使って独自実装してた Repository を Postgres に置き換えていきます。 まず lib/rumbl/repo.ex をもとに戻します。 1 2 3defmodule Rumbl.Repo do use Ecto.Repo, otp_app: :rumbl end さらに lib/rumbl.ex でコメントアウトした部分をもとに戻します。 1 2# Start the Ecto repository supervisor(Rumbl.Repo, []), # ここのコメントアウトを戻す まだ mix ecto.create をしてなければしておきます。 modelの実装 次に model の実装を行います。 web/model/user.ex を以下の内容で実装します。 1 2 3 4 5 6 7 8 9 10 11 12defmodule Rumbl.User do use Rumbl.Web, :model schema &#34;users&#34; do field :name, :string field :username, :string field :password, :string, virtual: true field :password_hash, :string timestamps end end ActiveRecord 使ったことがあればそんなに違和感なく受け入れられると思います。 :virtual オプションは値として受け取るが、DBには保存しない値です。 ここまで行って起動してみたら以下のような警告が出ました。 1 2 3warning: variable &#34;timestamps&#34; does not exist and is being expanded to &#34;timestamps()&#34;, please use parentheses to remove the ambiguity or change the variable name web/models/user.ex:10 timestamps が変数なのか timestamps/0 の関数呼び出しか曖昧だと言われてるようです。 今回は timestamps/0 の呼び出しなので timestamps の部分を timestamps() にすると警告がでなくなります。 ここらへん を参考にしました。 最後に web/web.ex の model 関数を以下のように変更します。 1 2 3 4 5 6 7 8 9def model do quote do use Ecto.Schema import Ecto import Ecto.Changeset import Ecto.Query, only: [from: 1, from: 2] # only以下を追加 end end DBのマイグレーション DB側にもテーブルとかを作る必要があるので以下のコマンドを実行します。 1 2 3rumbl $ mix ecto.gen.migration create_user * creating priv/repo/migrations * creating priv/repo/migrations/20170108070642_create_user.exs 生成された priv/repo/migrations/{日付}_create_user.exs ファイルを以下のように変更します。 これもRailsやったことあれば説明不要だと思います。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15defmodule Rumbl.Repo.Migrations.CreateUser do use Ecto.Migration def change do create table(:users) do add :name, :string add :username, :string, null: false add :password_hash, :string timestamps() end create unique_index(:users, [:username]) end end mix ecto.migrate でマイグレーションを実行します。 まとめ Model 周りの話でした。O/Rマッパー使ったことあればあまり違和感なく受け入れられそうでした。 関係ないですけど、基本的な部分終わったらガンガン飛ばしていこうと思います。亀のようなペースだと全然おわらないので。", 
            "tags": "programming", 
            "loc": "https://zonuko.github.io/posts/2017/01/09/programming-phoenix5/"
        },
        {
            "title": "Programming Phoenix勉強その4", 
            "text":"その4です。 その3の続きです。 :show アクションの実装からです. :showアクションの実装 :show アクションで各ユーザの詳細を表示できるようにします. まず Controler を実装します. 1 2 3 4def show(conn, %{&#34;id&#34; =&gt; id}) do user = Repo.get(Rumbl.User, id) render conn, &#34;show.html&#34;, user: user end 次に, web/templates/user/show.html.eex を以下の内容で実装します. 1 2&lt;h1&gt;Showing User&lt;/h1&gt; &lt;b&gt;&lt;%= first_name(@user) %&gt;&lt;/b&gt; (&lt;%= @user.id %&gt;) よく見ると &lt;b&gt; タグの部分が index.html.eex とかぶっているのがわかります. templateの分離 各テンプレートで重複している部分を別テンプレートに分離します. web/templates/user/user.html.eex を以下の内容で実装します. 1&lt;b&gt;&lt;%= first_name(@user) %&gt;&lt;/b&gt; (&lt;%= @user.id %&gt;) 共通部分をくくりだしたので,既存のテンプレートを編集します. web/templates/user/index.html.eex を以下の内容に変更します. &lt;%= render &#34;user.html&#34;, user: user %&gt; の部分が変更点です. 1 2 3 4 5 6 7 8 9 10&lt;h1&gt;Listing Users&lt;/h1&gt; &lt;table class=&#34;table&#34;&gt; &lt;%= for user &lt;- @users do %&gt; &lt;tr&gt; &lt;td&gt;&lt;%= render &#34;user.html&#34;, user: user %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= link &#34;View&#34;, to: user_path(@conn, :show, user.id) %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% end %&gt; &lt;/table&gt; web/templates/user/show.html.eex も同様に変更します. 1 2&lt;h1&gt;Showing User&lt;/h1&gt; &lt;%= render &#34;user.html&#34;, user: @user %&gt; view はモジュール, template は関数と捉えると良いみたいです. iex -S mix で以下のコマンドを入力すると何が起きているかなんとなくわかります. view の部分が :safe とリストの入れ子のタプルになってて一見わかりにくいですが,リストの部分は単なるタグの入れ子になってるみたいです. 素のタグ部分と, &lt;%= %&gt; とか &lt;% %&gt; の部分とでわけられてるみたいです. 1 2 3 4 5 6iex(1)&gt; user = Rumbl.Repo.get Rumbl.User, &#34;1&#34; %Rumbl.User{id: &#34;1&#34;, name: &#34;Jose&#34;, password: &#34;elixir&#34;, username: &#34;josevalim&#34;} iex(2)&gt; view = Rumbl.UserView.render(&#34;user.html&#34;, user: user) {:safe, [[[[[&#34;&#34; | &#34;&lt;b&gt;&#34;] | &#34;Jose&#34;] | &#34;&lt;/b&gt; (&#34;] | &#34;1&#34;] | &#34;)\n&#34;]} iex(3)&gt; Phoenix.HTML.safe_to_string(view) &#34;&lt;b&gt;Jose&lt;/b&gt; (1)\n&#34; :safe はこのHTMLが安全であることを示しています. また、リストになっているのはパフォーマスのためだそうです. ぱっと見どのテンプレートも render 関数呼び出しで呼び出されるっぽいですがテンプレート名でパターンマッチが行われることによってレンダリングしてるようです. error 見るとよりわかりやすそうです. 1 2 3 4 5 6 7def render(&#34;404.html&#34;, _assigns) do &#34;Page not found&#34; end def render(&#34;500.html&#34;, _assigns) do &#34;Internal server error&#34; end render 関数が2つあって第一引数のテンプレート名でパターンマッチしてるのがわかります. レンダリングについて 一番初めに templates/layout/app.html.eex がレンダリングされて,その後正規のテンプレートがレンダリングされる. まぁRailsとかもおんなじ感じだったと思うのでここらへんは適当にすっ飛ばします. まとめ ここでChapter3終わるのでちょっと短いですがここまでです. @conn みたいな度々出てくる conn の正体がまだイマイチ理解しきれてないので具体的にどういうものがどういう流れで入ってきてるのかぼちぼちしらべたいです.", 
            "tags": "programming", 
            "loc": "https://zonuko.github.io/posts/2017/01/07/programming-phoenix4/"
        },
        {
            "title": "Programming Phoenix勉強その3", 
            "text":"その3です。 その2の続きです。 今回からChpater3です. このChapterではまず rumbl と呼ばれるアプリを作ります. ビデオにたいしてリアルタイムでコメントを付けられるアプリになる予定らしい. 準備 Chapter1と同様に以下のコマンドでPhoenixの新しいプロジェクトを作成します.（詳細は割愛） 1 2 3 4 5 6 7 8 9 10 11 12 13 14$ mix phoenix.new rumbl * creating rumbl/ config/ config.exs ... Fetch and install dependencies? [Yn] y * running mix deps.get * running npm $ cd rumbl rumbl $ mix ecto.create ==&gt; connection Compiling 1 file （.ex） Generated connection app ... Modelの追加 実際はコマンドで自動生成されるものを手製で実装します. web/models/user.ex を以下の内容で実装します. 1 2 3defmodule Rumbl.User do defstruct [:id, :name, :username, :password] endD これは id, name, username, password 構造体として持つUserモジュールです. Repositoryの変更 現段階では,RepositoryはRDBからではなく独自にハードコーディングします. このようにすることで,データの概念とデータベースの概念が分離されていることがわかります. （ Repo と Model として） まず, lib/rumbl/repo.ex を以下のように変更します. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23defmodule Rumbl.Repo do @moduledoc &#34;&#34;&#34; In memory repository. &#34;&#34;&#34; def all(Rumbl.User) do [%Rumbl.User{id: &#34;1&#34;, name: &#34;Jose&#34;, username: &#34;josevalim&#34;, password: &#34;elixir&#34;}, %Rumbl.User{id: &#34;2&#34;, name: &#34;Bruce&#34;, username: &#34;redropids&#34;, password: &#34;7longs&#34;}, %Rumbl.User{id: &#34;3&#34;, name: &#34;Chris&#34;, username: &#34;chrismccord&#34;, password: &#34;phx&#34;}] end def all(_module), do: [] def get(module, id) do Enum.find all(module), fn map -&gt; map.id == id end end def get_by(module, params) do Enum.find all(module), fn map -&gt; Enum.all?(params, fn {key, val} -&gt; Map.get(map, key) == val end) end end end Ecto を使わないようにしたので, lib/rumbl.ex を編集して上記の repo.ex をプロセス管理対象から外します. 1 2# Start the Ecto repository # supervisor(Rumbl.Repo, []), # これをコメントアウト 上手く行っているか試すにはコンソールでプロジェクトフォルダに移動して iex -S mix コマンドで iex を起動します. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22rumbl $ iex -S mix Erlang/OTP 19 [erts-8.2] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace] Compiling 7 files (.ex) Interactive Elixir (1.3.4) - press Ctrl+C to exit (type h() ENTER for help) iex(1)&gt; alias Rumbl.User Rumbl.User iex(2)&gt; alias Rumbl.Repo Rumbl.Repo iex(3)&gt; Repo.all User [%Rumbl.User{id: &#34;1&#34;, name: &#34;Jose&#34;, password: &#34;elixir&#34;, username: &#34;josevalim&#34;}, %Rumbl.User{id: &#34;2&#34;, name: &#34;Bruce&#34;, password: &#34;7longs&#34;, username: &#34;redropids&#34;}, %Rumbl.User{id: &#34;3&#34;, name: &#34;Chris&#34;, password: &#34;phx&#34;, username: &#34;chrismccord&#34;}] iex(4)&gt; Repo.all Rumbl.Other [] iex(5)&gt; Repo.get User, &#34;1&#34; %Rumbl.User{id: &#34;1&#34;, name: &#34;Jose&#34;, password: &#34;elixir&#34;, username: &#34;josevalim&#34;} iex(6)&gt; Repo.get_by User, name: &#34;Brunce&#34; nil iex(7)&gt; Repo.get_by User, name: &#34;Bruce&#34; %Rumbl.User{id: &#34;2&#34;, name: &#34;Bruce&#34;, password: &#34;7longs&#34;, username: &#34;redropids&#34;} iex(8)&gt; Controllerの実装 上記で作成した Repository を扱う Controller を実装します. まず,専用のルーティング設定を web/router.ex に設定します. 1 2 3 4 5 6 7scope &#34;/&#34;, Rumbl do pipe_through :browser # Use the default browser stacks. get &#34;/users&#34;, UserController, :index # 追加 get &#34;/users/:id&#34;, UserController, :show # 追加 get &#34;/&#34;, PageController, :index end みて分かる通り UserControler の index アクションと show アクションに対応するルーティング設定を行います. get マクロはHTTPメソッドのGETで呼び出されることを想定されています. 次に,設定したルーティングに対応する Controller を実装します. 1 2 3 4 5 6 7 8defmodule Rumbl.UserController do use Rumbl.Web, :controller def index(conn, _params) do users = Repo.all(Rumbl.User) render conn, &#34;index.html&#34;, users: users end end hello アプリで作成したものと対して変わらないと思います. 違いは Repo.all/1 関数でユーザ一覧を取ってきてることくらいだと思います. この時点でもまだ View がないとエラーになるので, View の実装をします. Viewの実装 web/views/user_view.ex を以下の内容で実装します. 1 2 3 4 5 6 7 8 9 10defmodule Rumbl.UserView do use Rumbl.Web, :view alias Rumbl.User def first_name(%User{name: name}) do name |&gt; String.split(&#34; &#34;) |&gt; Enum.at(0) end end 単純に名前を名字と名前で分解しているだけの関数です. View モジュール名は Controller 名から自動で推測されます. （ UserController なら UserView といった具合） Templateの実装 web/templates/user/index.html.eex を以下の内容で実装します. 1 2 3 4 5 6 7 8 9 10&lt;h1&gt;Listing Users&lt;/h1&gt; &lt;table class=&#34;table&#34;&gt; &lt;%= for user &lt;- @users do %&gt; &lt;tr&gt; &lt;td&gt;&lt;b&gt;&lt;%= first_name(user) %&gt;&lt;/b&gt; (&lt;%= user.id %&gt;)&lt;/td&gt; &lt;td&gt;&gt;&lt;%= link &#34;View&#34;, to: user_path(@conn, :show, user.id) %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% end %&gt; &lt;/table&gt; Template は View 名から自動で推測されます. （ UserView なら user フォルダといった具合） ここまでくれば http://localhost:4000/users でユーザ一覧が表示されます. EEx のハイライトないので ERB でハイライトしてます. Viewのuse Rumbl.Web, :viewについて view に記述した use Rumbl.Web, :view の実体は web/web.ex に存在します. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19defmodule Rumbl.Web do … def view do quote do use Phoenix.View, root: &#34;web/templates&#34; # Import convenience functions from controllers import Phoenix.Controller, only: [get_csrf_token: 0, get_flash: 2, view_module: 1] # Use all HTML functionality (forms, tags, etc) use Phoenix.HTML import Rumbl.Router.Helpers import Rumbl.ErrorHelpers import Rumbl.Gettext end end … end Phoenix.HTML をHTML周りのことを色々やってくれているようです. また,これによって生成されるHTMLは安全で,XSS対策なども行ってくれているようです. ここには勝手に関数を書くのはNG.書きたいなら真似して import を使うこと. まとめ 今回は前回より具体的に各機能を実装しました. 個人的には今までよくわからなかった Repository と Model の関係がちょっとわかったのが収穫でした. 他のフレームワーク触ってると, View と Template が分離しているのが一瞬戸惑いそうだとおもいました.", 
            "tags": "programming", 
            "loc": "https://zonuko.github.io/posts/2017/01/04/programming-phoenix3/"
        },
        {
            "title": "Programming Phoenix勉強その2", 
            "text":"その2です。 その1の続きです。 デフォルトのディレクトリ構成について config ディレクトリ Phoenixの設定ファイル置き場.名前のまま. prod.secret.exs は秘密情報が入っているファイルなので,VCSからは外すこと. config.exs の endpoint はWebサーバーとアプリケーションの接続の境界部分. lib ディレクトリ Supervision treeと,長く起動するプロセスが置かれる.（?,あってるか微妙） DBとのコネクションプールとかのような長く使われるものが置かれるっぽい. test ディレクトリ 名前の通りテストが置かれる. web ディレクトリ Webアプリに必要な model, view, template, controller が置かれる. Plugについて Plug ライブラリは接続の統一化のために使われる. Plug のリポジトリ [Plugリポジトリ] には以下のように書いてある. ・ A specification for composable modules between web applications ・ Connection adapters for different web servers in the Erlang VM なので,各機能のモジュールの仕様の記述と,Erlang VMと各Webサーバーとの接続をやってくれるみたいです. （あまり理解してない感が） 実際にPhoenixが作ってくれる物を見てみます. config/endpoint.exs を見てみます. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42defmodule Hello.Endpoint do use Phoenix.Endpoint, otp_app: :hello socket &#34;/socket&#34;, Hello.UserSocket # Serve at &#34;/&#34; the static files from &#34;priv/static&#34; directory. # # You should set gzip to true if you are running phoenix.digest # when deploying your static files in production. plug Plug.Static, at: &#34;/&#34;, from: :hello, gzip: false, only: ~w(css fonts images js favicon.ico robots.txt) # Code reloading can be explicitly enabled under the # :code_reloader configuration of your endpoint. if code_reloading? do socket &#34;/phoenix/live_reload/socket&#34;, Phoenix.LiveReloader.Socket plug Phoenix.LiveReloader plug Phoenix.CodeReloader end plug Plug.RequestId plug Plug.Logger plug Plug.Parsers, parsers: [:urlencoded, :multipart, :json], pass: [&#34;*/*&#34;], json_decoder: Poison plug Plug.MethodOverride plug Plug.Head # The session will be stored in the cookie and signed, # this means its contents can be read but not tampered with. # Set :encryption_salt if you would also like to encrypt it. plug Plug.Session, store: :cookie, key: &#34;_hello_key&#34;, signing_salt: &#34;zzWE+Yw+&#34; plug Hello.Router end とりあえず plug ってのがいっぱい出てきています. なんとなく見てると, plug Plug.Static で静的ファイルについての設定っぽいものが書いてあったり, plug Plug.Logger とか, plug Plug.Parsers とかあったりして,Webアプリに必要な設定が書いてあるっぽいなと言う感覚です. ココらへんの一連の plug は関数のパイプラインとして処理されるようです. 1 2 3 4 5 6 7 8 9connection |&gt; Plug.Static.call |&gt; Plug.RequestId.call |&gt; Plug.Logger.call |&gt; Plug.Parsers.call |&gt; Plug.MethodOverride.call |&gt; Plug.Head.call |&gt; Plug.Session.call |&gt; Hello.Router.call ソースに書いた順になってるっぽいです.Servletの設定順ミスってハマった思い出が… ちなみに endpoint 自体も plug で,アプリケーション自体は endpoint で始まり controller で終わる一連のパイプラインらしい. Routerについて web/router.ex のソースを見ると,2つのパイプラインがあることがわかる. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27defmodule Hello.Router do use Hello.Web, :router pipeline :browser do plug :accepts, [&#34;html&#34;] plug :fetch_session plug :fetch_flash plug :protect_from_forgery plug :put_secure_browser_headers end pipeline :api do plug :accepts, [&#34;json&#34;] end scope &#34;/&#34;, Hello do pipe_through :browser # Use the default browser stack get &#34;/hello/:name&#34;, HelloController, :world get &#34;/&#34;, PageController, :index end # Other scopes may use custom stacks. # scope &#34;/api&#34;, Hello do # pipe_through :api # end end browser パイプライン HTMLのみを受け付ける. セッション管理とか,フラッシュメッセージとか,セキュリティ対策とかを提供してくれるらしい. api パイプライン 基本的なJSON API用のパイプライン.JSONのみ受け付ける. XMLにしたいときとかはここ一箇所変更すれば全部変更される. pipe_through でどのパイプラインを使うか書く. 処理の流れとしては接続を取得→パイプラインを呼び出し→コントローラーを呼び出し. 呼び出し順を纏めると以下になる. 1 2 3 4 5connection |&gt; endpoint |&gt; router |&gt; pipeline |&gt; controller まとめ 今回は,内部的な処理の流れとかおまじない的な部分が何をしてるかの勉強だった感じです. 英語がヘタレ過ぎて自分が理解している意味とあってるか若干の不安が... リンク [Plugリポジトリ]https://github.com/elixir-lang/plug", 
            "tags": "programming", 
            "loc": "https://zonuko.github.io/posts/2016/12/31/programming-phoenix2/"
        },
        {
            "title": "Programming Phoenix勉強その1", 
            "text":"買ってあったけど読んでなかったので読みます.プログラミングElixirは原著の方も翻訳の方も一応読んでます. プログラミングElixirについては色々なところで書評なり見る気がするけど,こっちの方は余り見ない気がします. ちなみに実際にコードを書くPart1のChapter2からやってきます. あとPhoenix自体は何回か触ってます.趣味で. 前提 PostgreSQL9.5 Elixir 1.3.2 Phoenix Framework1.2.1 本より新し目のバージョンにしてるので,色々問題ありそうですが頑張る感じで行きます. 初期構築 プロジェクトテンプレートの生成としてはじめに以下のコマンドを入力します. 1 2 3 4 5 6 7$ mix phoenix.new hello * creating hello/ config/ config.exs ... Fetch and install dependencies? [Yn] y * running mix deps.get * running npm これでカレントディレクトリにhelloってフォルダが掘られて,色々勝手に整備してくれる. 次に以下のコマンドでDB作ったりします. 1 2 3 4 5 6$ cd hello hello $ mix ecto.create ==&gt; connection Compiling 1 file （.ex） Generated connection app ... これで hello_dev とか言うデータベースができていればOKです. 出来てなければ, config/dev.exs ってファイルにDBとの接続設定があるので見直します. 起動 以下のコマンドでサーバー起動. 1 2$ cd hello $ mix phoenix.server mix phoenix.server の部分は iex -S mix phoenix.server でもOK.こちらはIEXの内部でサーバーが起動する. ちなみにデフォルトでは localhost:4000 で起動する. ルーティング 特定のURLとのルーティングを行うには, web/router.exs に設定を書く. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15defmodule Hello.Router do # 省略 scope &#34;/&#34;, Hello do pipe_through :browser # Use the default browser stack get &#34;/hello&#34;, HelloController, :world # 追加 get &#34;/&#34;, PageController, :index end # Other scopes may use custom stacks. # scope &#34;/api&#34;, Hello do # pipe_through :api # end end 見ればなんとなくわかると思いますが, get マクロに対して色々ルーティングの設定をします. この場合は /hello にアクセスが来たら HelloController （モジュール）の :world アクション（関数）を呼び出すようにしてます. ただ,この段階だと HelloController がないのでアクセスしてもエラー画面です. エラー画面が若干本と違ってたので貼っておきます. Controller実装 エラーを解消するために web/controllers/hello_controller.ex を以下の内容で作ります. 1 2 3 4 5 6 7defmodule Hello.HelloController do use Hello.Web, :controller def world（conn, _param） do render conn, &#34;world.html&#34; end end ファイル名はController名をスネークケース,モジュール名は, （ scope で設定した名前） . （ get に設定したController名）で作ります. （ココらへんの理解が微妙に曖昧） で,また /hello にアクセスすると,今度はviewがないと怒られます。 View実装 web/views/hello_view.ex を以下の内容で作ります. 1 2 3defmodule Hello.HelloView do use Hello.Web, :view end で,今度はtemplateが無いって怒られるのでまた作ります. Template実装 web/templates/world.html.eex を以下の内容で作ります. 1&lt;h1&gt;From template: Hello world!&lt;/h1&gt; これで晴れて /hello にアクセスしても怒られなくなります. Routing時のパラメータ 次に,ルーティング時にパラメータを渡す方法を実装します. （ /hoge/1/ のような感じに） web/router.ex に上の方で追加したルーティング設定を修正します. 1get &#34;/hello/:name&#34;, HelloController, :world こうすると :name の部分が色々変えられてControllerに渡されてきます. なので,Controllerを以下のように変更して渡された値を取得できるようにします. 1 2 3def world(conn, %{&#34;name&#34; =&gt; name}) do render conn, &#34;world.html&#34;, name: name end パターンマッチにより渡されてきた値が name にバインドされます. パターンマッチについては本の中で解説されてますが,飛ばします.プログラミングElixirとかElixirのチュートリアルとか読んでもらえれば. 最後に,template側で渡された値を表示するようにしてあげれば完成. 1&lt;h1&gt;Hello &lt;%= String.capitalize @name %&gt;!&lt;/h1&gt; &lt;%= ～ %&gt; の部分にElixirの関数が書けて, @name の部分にControllerから渡された値が入ってくるようです. まとめ とりあえず今回はここまでとしておきます。 かなり復習感ありましたが,基本的な部分はなんとなくわかったと思います。 やっぱりRailsにかなり近くて,Railsやってた人はここらへんはあまり深く読まなくても良い気がします. あと名前付けとかのルールとかは追々という感じで調べていきたいです.", 
            "tags": "programming", 
            "loc": "https://zonuko.github.io/posts/2016/12/28/programming-phoenix1/"
        },
        {
            "title": "ブログ書くことにした", 
            "text":"大した理由は無いけど色々あってブログを書くことにしました。 動機 始めようと思った理由は以下のような感じです。 勉強だけは色々するけど、発表する場が社内でもない。（自分で作ればあるけど・・・） EvernoteとかOnenoteにまとめてたけど中々見づらくてあとで振り返りづらい。 社外の人とも技術的な交流がする場が欲しい。 技術的なアウトプットを目に見える形で出すことにメリットが有ると思ったから。 構成 Pelicanと適当にテーマ使って作ってます。なので見た目はちょくちょく変わるかも。 サーバー自体はGitHub Pages使ってます。 Pelican選んだ理由は以下のような感じです。 Python好きだったから。 流行ってるもの嫌いな天邪鬼だから。（流行ってるものが素晴らしかったり楽しいのは理解してるんですが・・・） 方向性 基本的には技術的な内容にしていきたいですが、好きなゲームとか音楽とかアニメとかも話すかもしれないです。 あと、数学も大学院終わって大分忘れてきているので、勉強したらその内容でも投稿しようかと。 Pelicanについて ググればいくらでも出ると思いますが、PelicanはPython製の静的サイトジェネレーターです。 （Rubyで言うJekyllとかに値するやつ） 元々個人的に作った社内資料まとめとかにはSphinx使ってて、その流れって感じです。 具体的なPelicanの設定うんぬんは気が向けばそのうち書きます。環境は以下の感じ。 OS Windows10 64bit or Mac OS X El Capitan 諸事情でSierraじゃないです。 Python3.5.2 Pelican 3.6.3 エディタの類 Visual Studio Code Vim その他 Pelican良いと思いますが、ブログを書くという一点のみに着目すると車輪の再発明感も否めないです。 多分好き勝手書いていくと思うので、何か間違ってるとかあればコメントしてもらうか、Twitterにリプなりくれれば多分反応します。 うさぎの画像がたまに出てくるのは大久野島にたまに行くからです。うさぎ好きならおすすめします。一人なら泊る場所は島外にしよう！ PS. 何故か社内Redmineとかも丁寧語になってしまう現象が・・・", 
            "tags": "misc", 
            "loc": "https://zonuko.github.io/posts/2016/12/25/my-first-article/"
        },
        {
            "title": "About", 
            "text":"About me 名前 y-fujiwara nuhera or zonuko (HN) 経歴 千葉県の私立理系大学院修了(2015/3) 数理計画の類をやってた。 Pythonつかって色々やってた。 都内のIT企業に就職(2015/4 ～ 今まで) メインはC++かC#かJava たまにRubyとかJavaScript Interests アニメ SHOW BY ROCK!! 2期円盤マラソン中 Game STG どれも下手くそ レイストーム ダライアス外伝 格闘ゲーム コンボゲーと呼ばれる物 Music ゲームサントラ集め Technology 業務でつかった物 Vim 修行中 Python Elixir Haskell,Rust 勉強中・・・ Elm 線形代数 プログラミング言語作成 将来的に・・・", 
            "tags": "pages", 
            "loc": "https://zonuko.github.io/pages/about.html"
        }        
    ]
}