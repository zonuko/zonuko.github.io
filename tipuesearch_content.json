{"pages":[{"title":"About","text":"About me 名前 y-fujiwara nuhera or zonuko (HN) 経歴 千葉県の私立理系大学院修了(2015/3) 数理計画の類をやってた。 Pythonつかって色々やってた。 都内のIT企業に就職(2015/4 ～ 今まで) メインはC++かC#かJava たまにRubyとかJavaScript Interests アニメ SHOW BY ROCK!! 2期円盤マラソン中 Game STG どれも下手くそ レイストーム ダライアス外伝 格闘ゲーム コンボゲーと呼ばれる物 Music ゲームサントラ集め Technology 業務でつかった物 Vim 修行中 Python Elixir Haskell,Rust 勉強中・・・ Elm 線形代数 プログラミング言語作成 将来的に・・・","tags":"pages","url":"https://zonuko.github.io/pages/about.html"},{"title":"Programming Phoenix勉強その5","text":"その5です。ここからChapter4です。 Ecto を使って独自実装してた Repository を Postgres に置き換えていきます。 まず lib/rumbl/repo.ex をもとに戻します。 1 2 3 defmodule Rumbl.Repo do use Ecto.Repo , otp_app : :rumbl end さらに lib/rumbl.ex でコメントアウトした部分をもとに戻します。 1 2 # Start the Ecto repository supervisor ( Rumbl.Repo , []), # ここのコメントアウトを戻す まだ mix ecto.create をしてなければしておきます。 modelの実装 次に model の実装を行います。 web/model/user.ex を以下の内容で実装します。 1 2 3 4 5 6 7 8 9 10 11 12 defmodule Rumbl.User do use Rumbl.Web , :model schema \"users\" do field :name , :string field :username , :string field :password , :string , virtual : true field :password_hash , :string timestamps end end ActiveRecord 使ったことがあればそんなに違和感なく受け入れられると思います。 :virtual オプションは値として受け取るが、DBには保存しない値です。 ここまで行って起動してみたら以下のような警告が出ました。 1 2 3 warning: variable \"timestamps\" does not exist and is being expanded to \"timestamps()\" , please use parentheses to remove the ambiguity or change the variable name web/models/user.ex:10 timestamps が変数なのか timestamps/0 の関数呼び出しか曖昧だと言われてるようです。 今回は timestamps/0 の呼び出しなので timestamps の部分を timestamps() にすると警告がでなくなります。 ここらへん を参考にしました。 最後に web/web.ex の model 関数を以下のように変更します。 1 2 3 4 5 6 7 8 9 def model do quote do use Ecto.Schema import Ecto import Ecto.Changeset import Ecto.Query , only : [ from : 1 , from : 2 ] # only以下を追加 end end DBのマイグレーション DB側にもテーブルとかを作る必要があるので以下のコマンドを実行します。 1 2 3 rumbl $ mix ecto.gen.migration create_user * creating priv/repo/migrations * creating priv/repo/migrations/20170108070642_create_user.exs 生成された priv/repo/migrations/{日付}_create_user.exs ファイルを以下のように変更します。 これもRailsやったことあれば説明不要だと思います。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 defmodule Rumbl.Repo.Migrations.CreateUser do use Ecto.Migration def change do create table ( :users ) do add :name , :string add :username , :string , null : false add :password_hash , :string timestamps () end create unique_index ( :users , [ :username ]) end end mix ecto.migrate でマイグレーションを実行します。 まとめ Model 周りの話でした。O/Rマッパー使ったことあればあまり違和感なく受け入れられそうでした。 関係ないですけど、基本的な部分終わったらガンガン飛ばしていこうと思います。亀のようなペースだと全然おわらないので。","tags":"programming","url":"https://zonuko.github.io/posts/2017/01/09/programming-phoenix5/"},{"title":"Programming Phoenix勉強その4","text":"その4です。 その3の続きです。 :show アクションの実装からです. :showアクションの実装 :show アクションで各ユーザの詳細を表示できるようにします. まず Controler を実装します. 1 2 3 4 def show ( conn , %{ \"id\" => id }) do user = Repo . get ( Rumbl.User , id ) render conn , \"show.html\" , user : user end 次に, web/templates/user/show.html.eex を以下の内容で実装します. 1 2 <h1>Showing User</h1> <b> <%= first_name ( @user ) %> </b> ( <%= @user . id %> ) よく見ると <b> タグの部分が index.html.eex とかぶっているのがわかります. templateの分離 各テンプレートで重複している部分を別テンプレートに分離します. web/templates/user/user.html.eex を以下の内容で実装します. 1 <b> <%= first_name ( @user ) %> </b> ( <%= @user . id %> ) 共通部分をくくりだしたので,既存のテンプレートを編集します. web/templates/user/index.html.eex を以下の内容に変更します. <%= render \"user.html\", user: user %> の部分が変更点です. 1 2 3 4 5 6 7 8 9 10 <h1>Listing Users</h1> <table class=\"table\"> <%= for user <- @users do %> <tr> <td> <%= render \"user.html\" , user : user %> </td> <td> <%= link \"View\" , to : user_path ( @conn , :show , user . id ) %> </td> </tr> <% end %> </table> web/templates/user/show.html.eex も同様に変更します. 1 2 <h1>Showing User</h1> <%= render \"user.html\" , user : @user %> view はモジュール, template は関数と捉えると良いみたいです. iex -S mix で以下のコマンドを入力すると何が起きているかなんとなくわかります. view の部分が :safe とリストの入れ子のタプルになってて一見わかりにくいですが,リストの部分は単なるタグの入れ子になってるみたいです. 素のタグ部分と, <%= %> とか <% %> の部分とでわけられてるみたいです. 1 2 3 4 5 6 iex ( 1 ) > user = Rumbl.Repo.get Rumbl.User, \"1\" %Rumbl.User { id: \"1\" , name: \"Jose\" , password: \"elixir\" , username: \"josevalim\" } iex ( 2 ) > view = Rumbl.UserView.render ( \"user.html\" , user: user ) { :safe, [[[[[ \"\" | \"<b>\" ] | \"Jose\" ] | \"</b> (\" ] | \"1\" ] | \")\\n\" ]} iex ( 3 ) > Phoenix.HTML.safe_to_string ( view ) \"<b>Jose</b> (1)\\n\" :safe はこのHTMLが安全であることを示しています. また、リストになっているのはパフォーマスのためだそうです. ぱっと見どのテンプレートも render 関数呼び出しで呼び出されるっぽいですがテンプレート名でパターンマッチが行われることによってレンダリングしてるようです. error 見るとよりわかりやすそうです. 1 2 3 4 5 6 7 def render ( \"404.html\" , _assigns ) do \"Page not found\" end def render ( \"500.html\" , _assigns ) do \"Internal server error\" end render 関数が2つあって第一引数のテンプレート名でパターンマッチしてるのがわかります. レンダリングについて 一番初めに templates/layout/app.html.eex がレンダリングされて,その後正規のテンプレートがレンダリングされる. まぁRailsとかもおんなじ感じだったと思うのでここらへんは適当にすっ飛ばします. まとめ ここでChapter3終わるのでちょっと短いですがここまでです. @conn みたいな度々出てくる conn の正体がまだイマイチ理解しきれてないので具体的にどういうものがどういう流れで入ってきてるのかぼちぼちしらべたいです.","tags":"programming","url":"https://zonuko.github.io/posts/2017/01/07/programming-phoenix4/"},{"title":"Programming Phoenix勉強その3","text":"その3です。 その2の続きです。 今回からChpater3です. このChapterではまず rumbl と呼ばれるアプリを作ります. ビデオにたいしてリアルタイムでコメントを付けられるアプリになる予定らしい. 準備 Chapter1と同様に以下のコマンドでPhoenixの新しいプロジェクトを作成します.（詳細は割愛） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ mix phoenix.new rumbl * creating rumbl/ config/ config.exs ... Fetch and install dependencies? [ Yn ] y * running mix deps.get * running npm $ cd rumbl rumbl $ mix ecto.create == > connection Compiling 1 file （.ex） Generated connection app ... Modelの追加 実際はコマンドで自動生成されるものを手製で実装します. web/models/user.ex を以下の内容で実装します. 1 2 3 defmodule Rumbl.User do defstruct [ :id , :name , :username , :password ] endD これは id, name, username, password 構造体として持つUserモジュールです. Repositoryの変更 現段階では,RepositoryはRDBからではなく独自にハードコーディングします. このようにすることで,データの概念とデータベースの概念が分離されていることがわかります. （ Repo と Model として） まず, lib/rumbl/repo.ex を以下のように変更します. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 defmodule Rumbl.Repo do @moduledoc \"\"\" In memory repository. \"\"\" def all ( Rumbl.User ) do [% Rumbl.User { id : \"1\" , name : \"Jose\" , username : \"josevalim\" , password : \"elixir\" }, % Rumbl.User { id : \"2\" , name : \"Bruce\" , username : \"redropids\" , password : \"7longs\" }, % Rumbl.User { id : \"3\" , name : \"Chris\" , username : \"chrismccord\" , password : \"phx\" }] end def all ( _module ), do : [] def get ( module , id ) do Enum . find all ( module ), fn map -> map . id == id end end def get_by ( module , params ) do Enum . find all ( module ), fn map -> Enum . all? ( params , fn { key , val } -> Map . get ( map , key ) == val end ) end end end Ecto を使わないようにしたので, lib/rumbl.ex を編集して上記の repo.ex をプロセス管理対象から外します. 1 2 # Start the Ecto repository # supervisor(Rumbl.Repo, []), # これをコメントアウト 上手く行っているか試すにはコンソールでプロジェクトフォルダに移動して iex -S mix コマンドで iex を起動します. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 rumbl $ iex -S mix Erlang/OTP 19 [ erts-8.2 ] [ source ] [ 64-bit ] [ smp:4:4 ] [ async-threads:10 ] [ hipe ] [ kernel-poll:false ] [ dtrace ] Compiling 7 files ( .ex ) Interactive Elixir ( 1.3.4 ) - press Ctrl+C to exit ( type h () ENTER for help ) iex ( 1 ) > alias Rumbl.User Rumbl.User iex ( 2 ) > alias Rumbl.Repo Rumbl.Repo iex ( 3 ) > Repo.all User [ %Rumbl.User { id: \"1\" , name: \"Jose\" , password: \"elixir\" , username: \"josevalim\" } , %Rumbl.User { id: \"2\" , name: \"Bruce\" , password: \"7longs\" , username: \"redropids\" } , %Rumbl.User { id: \"3\" , name: \"Chris\" , password: \"phx\" , username: \"chrismccord\" }] iex ( 4 ) > Repo.all Rumbl.Other [] iex ( 5 ) > Repo.get User, \"1\" %Rumbl.User { id: \"1\" , name: \"Jose\" , password: \"elixir\" , username: \"josevalim\" } iex ( 6 ) > Repo.get_by User, name: \"Brunce\" nil iex ( 7 ) > Repo.get_by User, name: \"Bruce\" %Rumbl.User { id: \"2\" , name: \"Bruce\" , password: \"7longs\" , username: \"redropids\" } iex ( 8 ) > Controllerの実装 上記で作成した Repository を扱う Controller を実装します. まず,専用のルーティング設定を web/router.ex に設定します. 1 2 3 4 5 6 7 scope \"/\" , Rumbl do pipe_through :browser # Use the default browser stacks. get \"/users\" , UserController , :index # 追加 get \"/users/:id\" , UserController , :show # 追加 get \"/\" , PageController , :index end みて分かる通り UserControler の index アクションと show アクションに対応するルーティング設定を行います. get マクロはHTTPメソッドのGETで呼び出されることを想定されています. 次に,設定したルーティングに対応する Controller を実装します. 1 2 3 4 5 6 7 8 defmodule Rumbl.UserController do use Rumbl.Web , :controller def index ( conn , _params ) do users = Repo . all ( Rumbl.User ) render conn , \"index.html\" , users : users end end hello アプリで作成したものと対して変わらないと思います. 違いは Repo.all/1 関数でユーザ一覧を取ってきてることくらいだと思います. この時点でもまだ View がないとエラーになるので, View の実装をします. Viewの実装 web/views/user_view.ex を以下の内容で実装します. 1 2 3 4 5 6 7 8 9 10 defmodule Rumbl.UserView do use Rumbl.Web , :view alias Rumbl.User def first_name (% User { name : name }) do name |> String . split ( \" \" ) |> Enum . at ( 0 ) end end 単純に名前を名字と名前で分解しているだけの関数です. View モジュール名は Controller 名から自動で推測されます. （ UserController なら UserView といった具合） Templateの実装 web/templates/user/index.html.eex を以下の内容で実装します. 1 2 3 4 5 6 7 8 9 10 <h1>Listing Users</h1> <table class=\"table\"> <%= for user <- @users do %> <tr> <td><b> <%= first_name ( user ) %> </b> ( <%= user . id %> )</td> <td>> <%= link \"View\" , to : user_path ( @conn , :show , user . id ) %> </td> </tr> <% end %> </table> Template は View 名から自動で推測されます. （ UserView なら user フォルダといった具合） ここまでくれば http://localhost:4000/users でユーザ一覧が表示されます. EEx のハイライトないので ERB でハイライトしてます. Viewのuse Rumbl.Web, :viewについて view に記述した use Rumbl.Web, :view の実体は web/web.ex に存在します. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 defmodule Rumbl.Web do … def view do quote do use Phoenix.View , root : \"web/templates\" # Import convenience functions from controllers import Phoenix.Controller , only : [ get_csrf_token : 0 , get_flash : 2 , view_module : 1 ] # Use all HTML functionality (forms, tags, etc) use Phoenix.HTML import Rumbl.Router.Helpers import Rumbl.ErrorHelpers import Rumbl.Gettext end end … end Phoenix.HTML をHTML周りのことを色々やってくれているようです. また,これによって生成されるHTMLは安全で,XSS対策なども行ってくれているようです. ここには勝手に関数を書くのはNG.書きたいなら真似して import を使うこと. まとめ 今回は前回より具体的に各機能を実装しました. 個人的には今までよくわからなかった Repository と Model の関係がちょっとわかったのが収穫でした. 他のフレームワーク触ってると, View と Template が分離しているのが一瞬戸惑いそうだとおもいました.","tags":"programming","url":"https://zonuko.github.io/posts/2017/01/04/programming-phoenix3/"},{"title":"Programming Phoenix勉強その2","text":"その2です。 その1の続きです。 デフォルトのディレクトリ構成について config ディレクトリ Phoenixの設定ファイル置き場.名前のまま. prod.secret.exs は秘密情報が入っているファイルなので,VCSからは外すこと. config.exs の endpoint はWebサーバーとアプリケーションの接続の境界部分. lib ディレクトリ Supervision treeと,長く起動するプロセスが置かれる.（?,あってるか微妙） DBとのコネクションプールとかのような長く使われるものが置かれるっぽい. test ディレクトリ 名前の通りテストが置かれる. web ディレクトリ Webアプリに必要な model , view , template , controller が置かれる. Plugについて Plug ライブラリは接続の統一化のために使われる. Plug のリポジトリ [Plugリポジトリ] には以下のように書いてある. ・ A specification for composable modules between web applications ・ Connection adapters for different web servers in the Erlang VM なので,各機能のモジュールの仕様の記述と,Erlang VMと各Webサーバーとの接続をやってくれるみたいです. （あまり理解してない感が） 実際にPhoenixが作ってくれる物を見てみます. config/endpoint.exs を見てみます. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 defmodule Hello.Endpoint do use Phoenix.Endpoint , otp_app : :hello socket \"/socket\" , Hello.UserSocket # Serve at \"/\" the static files from \"priv/static\" directory. # # You should set gzip to true if you are running phoenix.digest # when deploying your static files in production. plug Plug.Static , at : \"/\" , from : :hello , gzip : false , only : ~w(css fonts images js favicon.ico robots.txt) # Code reloading can be explicitly enabled under the # :code_reloader configuration of your endpoint. if code_reloading? do socket \"/phoenix/live_reload/socket\" , Phoenix.LiveReloader.Socket plug Phoenix.LiveReloader plug Phoenix.CodeReloader end plug Plug.RequestId plug Plug.Logger plug Plug.Parsers , parsers : [ :urlencoded , :multipart , :json ], pass : [ \"*/*\" ], json_decoder : Poison plug Plug.MethodOverride plug Plug.Head # The session will be stored in the cookie and signed, # this means its contents can be read but not tampered with. # Set :encryption_salt if you would also like to encrypt it. plug Plug.Session , store : :cookie , key : \"_hello_key\" , signing_salt : \"zzWE+Yw+\" plug Hello.Router end とりあえず plug ってのがいっぱい出てきています. なんとなく見てると, plug Plug.Static で静的ファイルについての設定っぽいものが書いてあったり, plug Plug.Logger とか, plug Plug.Parsers とかあったりして,Webアプリに必要な設定が書いてあるっぽいなと言う感覚です. ココらへんの一連の plug は関数のパイプラインとして処理されるようです. 1 2 3 4 5 6 7 8 9 connection |> Plug.Static . call |> Plug.RequestId . call |> Plug.Logger . call |> Plug.Parsers . call |> Plug.MethodOverride . call |> Plug.Head . call |> Plug.Session . call |> Hello.Router . call ソースに書いた順になってるっぽいです.Servletの設定順ミスってハマった思い出が… ちなみに endpoint 自体も plug で,アプリケーション自体は endpoint で始まり controller で終わる一連のパイプラインらしい. Routerについて web/router.ex のソースを見ると,2つのパイプラインがあることがわかる. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 defmodule Hello.Router do use Hello.Web , :router pipeline :browser do plug :accepts , [ \"html\" ] plug :fetch_session plug :fetch_flash plug :protect_from_forgery plug :put_secure_browser_headers end pipeline :api do plug :accepts , [ \"json\" ] end scope \"/\" , Hello do pipe_through :browser # Use the default browser stack get \"/hello/:name\" , HelloController , :world get \"/\" , PageController , :index end # Other scopes may use custom stacks. # scope \"/api\", Hello do # pipe_through :api # end end browser パイプライン HTMLのみを受け付ける. セッション管理とか,フラッシュメッセージとか,セキュリティ対策とかを提供してくれるらしい. api パイプライン 基本的なJSON API用のパイプライン.JSONのみ受け付ける. XMLにしたいときとかはここ一箇所変更すれば全部変更される. pipe_through でどのパイプラインを使うか書く. 処理の流れとしては接続を取得→パイプラインを呼び出し→コントローラーを呼び出し. 呼び出し順を纏めると以下になる. 1 2 3 4 5 connection |> endpoint |> router |> pipeline |> controller まとめ 今回は,内部的な処理の流れとかおまじない的な部分が何をしてるかの勉強だった感じです. 英語がヘタレ過ぎて自分が理解している意味とあってるか若干の不安が... リンク [Plugリポジトリ] https://github.com/elixir-lang/plug","tags":"programming","url":"https://zonuko.github.io/posts/2016/12/31/programming-phoenix2/"},{"title":"Programming Phoenix勉強その1","text":"買ってあったけど読んでなかったので読みます.プログラミングElixirは原著の方も翻訳の方も一応読んでます. プログラミングElixirについては色々なところで書評なり見る気がするけど,こっちの方は余り見ない気がします. ちなみに実際にコードを書くPart1のChapter2からやってきます. あとPhoenix自体は何回か触ってます.趣味で. 前提 PostgreSQL9.5 Elixir 1.3.2 Phoenix Framework1.2.1 本より新し目のバージョンにしてるので,色々問題ありそうですが頑張る感じで行きます. 初期構築 プロジェクトテンプレートの生成としてはじめに以下のコマンドを入力します. 1 2 3 4 5 6 7 $ mix phoenix.new hello * creating hello/ config/ config.exs ... Fetch and install dependencies? [ Yn ] y * running mix deps.get * running npm これでカレントディレクトリにhelloってフォルダが掘られて,色々勝手に整備してくれる. 次に以下のコマンドでDB作ったりします. 1 2 3 4 5 6 $ cd hello hello $ mix ecto.create == > connection Compiling 1 file （.ex） Generated connection app ... これで hello_dev とか言うデータベースができていればOKです. 出来てなければ, config/dev.exs ってファイルにDBとの接続設定があるので見直します. 起動 以下のコマンドでサーバー起動. 1 2 $ cd hello $ mix phoenix.server mix phoenix.server の部分は iex -S mix phoenix.server でもOK.こちらはIEXの内部でサーバーが起動する. ちなみにデフォルトでは localhost:4000 で起動する. ルーティング 特定のURLとのルーティングを行うには, web/router.exs に設定を書く. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 defmodule Hello.Router do # 省略 scope \"/\" , Hello do pipe_through :browser # Use the default browser stack get \"/hello\" , HelloController , :world # 追加 get \"/\" , PageController , :index end # Other scopes may use custom stacks. # scope \"/api\", Hello do # pipe_through :api # end end 見ればなんとなくわかると思いますが, get マクロに対して色々ルーティングの設定をします. この場合は /hello にアクセスが来たら HelloController （モジュール）の :world アクション（関数）を呼び出すようにしてます. ただ,この段階だと HelloController がないのでアクセスしてもエラー画面です. エラー画面が若干本と違ってたので貼っておきます. Controller実装 エラーを解消するために web/controllers/hello_controller.ex を以下の内容で作ります. 1 2 3 4 5 6 7 defmodule Hello.HelloController do use Hello.Web , :controller def world （ conn , _param ） do render conn , \"world.html\" end end ファイル名はController名をスネークケース,モジュール名は, （ scope で設定した名前） . （ get に設定したController名）で作ります. （ココらへんの理解が微妙に曖昧） で,また /hello にアクセスすると,今度はviewがないと怒られます。 View実装 web/views/hello_view.ex を以下の内容で作ります. 1 2 3 defmodule Hello.HelloView do use Hello.Web , :view end で,今度はtemplateが無いって怒られるのでまた作ります. Template実装 web/templates/world.html.eex を以下の内容で作ります. 1 < h1 > From template: Hello world! </ h1 > これで晴れて /hello にアクセスしても怒られなくなります. Routing時のパラメータ 次に,ルーティング時にパラメータを渡す方法を実装します. （ /hoge/1/ のような感じに） web/router.ex に上の方で追加したルーティング設定を修正します. 1 get \"/hello/:name\" , HelloController , :world こうすると :name の部分が色々変えられてControllerに渡されてきます. なので,Controllerを以下のように変更して渡された値を取得できるようにします. 1 2 3 def world ( conn , %{ \"name\" => name }) do render conn , \"world.html\" , name : name end パターンマッチにより渡されてきた値が name にバインドされます. パターンマッチについては本の中で解説されてますが,飛ばします.プログラミングElixirとかElixirのチュートリアルとか読んでもらえれば. 最後に,template側で渡された値を表示するようにしてあげれば完成. 1 < h1 > Hello < %= String.capitalize @name %>! </ h1 > <%= ～ %> の部分にElixirの関数が書けて, @name の部分にControllerから渡された値が入ってくるようです. まとめ とりあえず今回はここまでとしておきます。 かなり復習感ありましたが,基本的な部分はなんとなくわかったと思います。 やっぱりRailsにかなり近くて,Railsやってた人はここらへんはあまり深く読まなくても良い気がします. あと名前付けとかのルールとかは追々という感じで調べていきたいです.","tags":"programming","url":"https://zonuko.github.io/posts/2016/12/28/programming-phoenix1/"},{"title":"ブログ書くことにした","text":"大した理由は無いけど色々あってブログを書くことにしました。 動機 始めようと思った理由は以下のような感じです。 勉強だけは色々するけど、発表する場が社内でもない。（自分で作ればあるけど・・・） EvernoteとかOnenoteにまとめてたけど中々見づらくてあとで振り返りづらい。 社外の人とも技術的な交流がする場が欲しい。 技術的なアウトプットを目に見える形で出すことにメリットが有ると思ったから。 構成 Pelicanと適当にテーマ使って作ってます。なので見た目はちょくちょく変わるかも。 サーバー自体はGitHub Pages使ってます。 Pelican選んだ理由は以下のような感じです。 Python好きだったから。 流行ってるもの嫌いな天邪鬼だから。（流行ってるものが素晴らしかったり楽しいのは理解してるんですが・・・） 方向性 基本的には技術的な内容にしていきたいですが、好きなゲームとか音楽とかアニメとかも話すかもしれないです。 あと、数学も大学院終わって大分忘れてきているので、勉強したらその内容でも投稿しようかと。 Pelicanについて ググればいくらでも出ると思いますが、PelicanはPython製の静的サイトジェネレーターです。 （Rubyで言うJekyllとかに値するやつ） 元々個人的に作った社内資料まとめとかにはSphinx使ってて、その流れって感じです。 具体的なPelicanの設定うんぬんは気が向けばそのうち書きます。環境は以下の感じ。 OS Windows10 64bit or Mac OS X El Capitan 諸事情でSierraじゃないです。 Python3.5.2 Pelican 3.6.3 エディタの類 Visual Studio Code Vim その他 Pelican良いと思いますが、ブログを書くという一点のみに着目すると車輪の再発明感も否めないです。 多分好き勝手書いていくと思うので、何か間違ってるとかあればコメントしてもらうか、Twitterにリプなりくれれば多分反応します。 うさぎの画像がたまに出てくるのは大久野島にたまに行くからです。うさぎ好きならおすすめします。一人なら泊る場所は島外にしよう！ PS. 何故か社内Redmineとかも丁寧語になってしまう現象が・・・","tags":"misc","url":"https://zonuko.github.io/posts/2016/12/25/my-first-article/"}]}