{"pages":[{"tags":"pages","url":"https://zonuko.github.io/pages/about.html","title":"About","text":"About me 名前 y-fujiwara nuhera or zonuko (HN) 経歴 千葉県の私立理系大学院修了(2015/3) 数理計画の類をやってた。 Pythonつかって色々やってた。 都内のIT企業に就職(2015/4 ～ 今まで) メインはC++かC#かJava たまにRubyとかJavaScript Interests アニメ SHOW BY ROCK!! 2期円盤マラソン中 Game STG どれも下手くそ レイストーム ダライアス外伝 格闘ゲーム コンボゲーと呼ばれる物 Music ゲームサントラ集め Technology 業務でつかった物 Vim 修行中 Python Elixir Haskell,Rust 勉強中・・・ Elm 線形代数 プログラミング言語作成 将来的に・・・"},{"tags":"programming","url":"https://zonuko.github.io/posts/2017/01/01/programming-phoenix3/","title":"Programming Phoenix勉強その3","text":"その3です。 その2の続きです。 今回からChpater3です. このChapterではまず rumbl と呼ばれるアプリを作ります. ビデオにたいしてリアルタイムでコメントを付けられるアプリになる予定らしい. 準備 Chapter1と同様に以下のコマンドでPhoenixの新しいプロジェクトを作成します.（詳細は割愛） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ mix phoenix.new rumbl * creating rumbl/ config/ config.exs ... Fetch and install dependencies? [ Yn ] y * running mix deps.get * running npm $ cd rumbl rumbl $ mix ecto.create == > connection Compiling 1 file （.ex） Generated connection app ..."},{"tags":"programming","url":"https://zonuko.github.io/posts/2016/12/31/programming-phoenix2/","title":"Programming Phoenix勉強その2","text":"その2です。 その1の続きです。 デフォルトのディレクトリ構成について config ディレクトリ Phoenixの設定ファイル置き場.名前のまま. prod.secret.exs は秘密情報が入っているファイルなので,VCSからは外すこと. config.exs の endpoint はWebサーバーとアプリケーションの接続の境界部分. lib ディレクトリ Supervision treeと,長く起動するプロセスが置かれる.（?,あってるか微妙） DBとのコネクションプールとかのような長く使われるものが置かれるっぽい. test ディレクトリ 名前の通りテストが置かれる. web ディレクトリ Webアプリに必要な model , view , template , controller が置かれる. Plugについて Plug ライブラリは接続の統一化のために使われる. Plug のリポジトリ [Plugリポジトリ] には以下のように書いてある. ・ A specification for composable modules between web applications ・ Connection adapters for different web servers in the Erlang VM なので,各機能のモジュールの仕様の記述と,Erlang VMと各Webサーバーとの接続をやってくれるみたいです. （あまり理解してない感が） 実際にPhoenixが作ってくれる物を見てみます. config/endpoint.exs を見てみます. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 defmodule Hello.Endpoint do use Phoenix.Endpoint , otp_app : :hello socket \"/socket\" , Hello.UserSocket # Serve at \"/\" the static files from \"priv/static\" directory. # # You should set gzip to true if you are running phoenix.digest # when deploying your static files in production. plug Plug.Static , at : \"/\" , from : :hello , gzip : false , only : ~w(css fonts images js favicon.ico robots.txt) # Code reloading can be explicitly enabled under the # :code_reloader configuration of your endpoint. if code_reloading? do socket \"/phoenix/live_reload/socket\" , Phoenix.LiveReloader.Socket plug Phoenix.LiveReloader plug Phoenix.CodeReloader end plug Plug.RequestId plug Plug.Logger plug Plug.Parsers , parsers : [ :urlencoded , :multipart , :json ], pass : [ \"*/*\" ], json_decoder : Poison plug Plug.MethodOverride plug Plug.Head # The session will be stored in the cookie and signed, # this means its contents can be read but not tampered with. # Set :encryption_salt if you would also like to encrypt it. plug Plug.Session , store : :cookie , key : \"_hello_key\" , signing_salt : \"zzWE+Yw+\" plug Hello.Router end とりあえず plug ってのがいっぱい出てきています. なんとなく見てると, plug Plug.Static で静的ファイルについての設定っぽいものが書いてあったり, plug Plug.Logger とか, plug Plug.Parsers とかあったりして,Webアプリに必要な設定が書いてあるっぽいなと言う感覚です. ココらへんの一連の plug は関数のパイプラインとして処理されるようです. 1 2 3 4 5 6 7 8 9 connection |> Plug.Static . call |> Plug.RequestId . call |> Plug.Logger . call |> Plug.Parsers . call |> Plug.MethodOverride . call |> Plug.Head . call |> Plug.Session . call |> Hello.Router . call ソースに書いた順になってるっぽいです.Servletの設定順ミスってハマった思い出が… ちなみに endpoint 自体も plug で,アプリケーション自体は endpoint で始まり controller で終わる一連のパイプラインらしい. Routerについて web/router.ex のソースを見ると,2つのパイプラインがあることがわかる. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 defmodule Hello.Router do use Hello.Web , :router pipeline :browser do plug :accepts , [ \"html\" ] plug :fetch_session plug :fetch_flash plug :protect_from_forgery plug :put_secure_browser_headers end pipeline :api do plug :accepts , [ \"json\" ] end scope \"/\" , Hello do pipe_through :browser # Use the default browser stack get \"/hello/:name\" , HelloController , :world get \"/\" , PageController , :index end # Other scopes may use custom stacks. # scope \"/api\", Hello do # pipe_through :api # end end browser パイプライン HTMLのみを受け付ける. セッション管理とか,フラッシュメッセージとか,セキュリティ対策とかを提供してくれるらしい. api パイプライン 基本的なJSON API用のパイプライン.JSONのみ受け付ける. XMLにしたいときとかはここ一箇所変更すれば全部変更される. pipe_through でどのパイプラインを使うか書く. 処理の流れとしては接続を取得→パイプラインを呼び出し→コントローラーを呼び出し. 呼び出し順を纏めると以下になる. 1 2 3 4 5 connection |> endpoint |> router |> pipeline |> controller まとめ 今回は,内部的な処理の流れとかおまじない的な部分が何をしてるかの勉強だった感じです. 英語がヘタレ過ぎて自分が理解している意味とあってるか若干の不安が... リンク [Plugリポジトリ] https://github.com/elixir-lang/plug"},{"tags":"programming","url":"https://zonuko.github.io/posts/2016/12/28/programming-phoenix1/","title":"Programming Phoenix勉強その1","text":"買ってあったけど読んでなかったので読みます. プログラミングElixirについては色々なところで書評なり見る気がするけど,こっちの方は余り見ない気がします. ちなみに実際にコードを書くPart1のChapter2からやってきます. あとPhoenix自体は何回か触ってます.趣味で. 前提 PostgreSQL9.5 Elixir 1.3.2 Phoenix Framework1.2.1 本より新し目のバージョンにしてるので,色々問題ありそうですが頑張る感じで行きます. 初期構築 プロジェクトテンプレートの生成としてはじめに以下のコマンドを入力します. 1 2 3 4 5 6 7 $ mix phoenix.new hello * creating hello/ config/ config.exs ... Fetch and install dependencies? [ Yn ] y * running mix deps.get * running npm これでカレントディレクトリにhelloってフォルダが掘られて,色々勝手に整備してくれる. 次に以下のコマンドでDB作ったりします. 1 2 3 4 5 6 $ cd hello hello $ mix ecto.create == > connection Compiling 1 file （.ex） Generated connection app ... これで hello_dev とか言うデータベースができていればOKです. 出来てなければ, config/dev.exs ってファイルにDBとの接続設定があるので見直します. 起動 以下のコマンドでサーバー起動. 1 2 $ cd hello $ mix phoenix.server mix phoenix.server の部分は iex -S mix phoenix.server でもOK.こちらはIEXの内部でサーバーが起動する. ちなみにデフォルトでは localhost:4000 で起動する. ルーティング 特定のURLとのルーティングを行うには, web/router.exs に設定を書く. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 defmodule Hello.Router do # 省略 scope \"/\" , Hello do pipe_through :browser # Use the default browser stack get \"/hello\" , HelloController , :world # 追加 get \"/\" , PageController , :index end # Other scopes may use custom stacks. # scope \"/api\", Hello do # pipe_through :api # end end 見ればなんとなくわかると思いますが, get マクロに対して色々ルーティングの設定をします. この場合は /hello にアクセスが来たら HelloController （モジュール）の :world アクション（関数）を呼び出すようにしてます. ただ,この段階だと HelloController がないのでアクセスしてもエラー画面です. エラー画面が若干本と違ってたので貼っておきます. Controller実装 エラーを解消するために web/controllers/hello_controller.ex を以下の内容で作ります. 1 2 3 4 5 6 7 defmodule Hello.HelloController do use Hello.Web , :controller def world （ conn , _param ） do render conn , \"world.html\" end end ファイル名はController名をスネークケース,モジュール名は, （ scope で設定した名前） . （ get に設定したController名）で作ります. （ココらへんの理解が微妙に曖昧） で,また /hello にアクセスすると,今度はviewがないと怒られます。 View実装 web/views/hello_view.ex を以下の内容で作ります. 1 2 3 defmodule Hello.HelloView do use Hello.Web , :view end で,今度はtemplateが無いって怒られるのでまた作ります. Template実装 web/templates/world.html.eex を以下の内容で作ります. 1 < h1 > From template: Hello world! </ h1 > これで晴れて /hello にアクセスしても怒られなくなります. Routing時のパラメータ 次に,ルーティング時にパラメータを渡す方法を実装します. （ /hoge/1/ のような感じに） web/router.ex に上の方で追加したルーティング設定を修正します. 1 get \"/hello/:name\" , HelloController , :world こうすると :name の部分が色々変えられてControllerに渡されてきます. なので,Controllerを以下のように変更して渡された値を取得できるようにします. 1 2 3 def world ( conn , %{ \"name\" => name }) do render conn , \"world.html\" , name : name end パターンマッチにより渡されてきた値が name にバインドされます. パターンマッチについては本の中で解説されてますが,飛ばします.プログラミングElixirとかElixirのチュートリアルとか読んでもらえれば. 最後に,template側で渡された値を表示するようにしてあげれば完成. 1 < h1 > Hello < %= String.capitalize @name %>! </ h1 > <%= ～ %> の部分にElixirの関数が書けて, @name の部分にControllerから渡された値が入ってくるようです. まとめ とりあえず今回はここまでとしておきます。 かなり復習感ありましたが,基本的な部分はなんとなくわかったと思います。 やっぱりRailsにかなり近くて,Railsやってた人はここらへんはあまり深く読まなくても良い気がします. あと名前付けとかのルールとかは追々という感じで調べていきたいです."},{"tags":"misc","url":"https://zonuko.github.io/posts/2016/12/25/my-first-article/","title":"ブログ書くことにした","text":"大した理由は無いけど色々あってブログを書くことにしました。 動機 始めようと思った理由は以下のような感じです。 勉強だけは色々するけど、発表する場が社内でもない。（自分で作ればあるけど・・・） EvernoteとかOnenoteにまとめてたけど中々見づらくてあとで振り返りづらい。 社外の人とも技術的な交流がする場が欲しい。 技術的なアウトプットを目に見える形で出すことにメリットが有ると思ったから。 構成 Pelicanと適当にテーマ使って作ってます。なので見た目はちょくちょく変わるかも。 サーバー自体はGitHub Pages使ってます。 Pelican選んだ理由は以下のような感じです。 Python好きだったから。 流行ってるもの嫌いな天邪鬼だから。（流行ってるものが素晴らしかったり楽しいのは理解してるんですが・・・） 方向性 基本的には技術的な内容にしていきたいですが、好きなゲームとか音楽とかアニメとかも話すかもしれないです。 あと、数学も大学院終わって大分忘れてきているので、勉強したらその内容でも投稿しようかと。 Pelicanについて ググればいくらでも出ると思いますが、PelicanはPython製の静的サイトジェネレーターです。 （Rubyで言うJekyllとかに値するやつ） 元々個人的に作った社内資料まとめとかにはSphinx使ってて、その流れって感じです。 具体的なPelicanの設定うんぬんは気が向けばそのうち書きます。環境は以下の感じ。 OS Windows10 64bit or Mac OS X El Capitan 諸事情でSierraじゃないです。 Python3.5.2 Pelican 3.6.3 エディタの類 Visual Studio Code Vim その他 Pelican良いと思いますが、ブログを書くという一点のみに着目すると車輪の再発明感も否めないです。 多分好き勝手書いていくと思うので、何か間違ってるとかあればコメントしてもらうか、Twitterにリプなりくれれば多分反応します。 うさぎの画像がたまに出てくるのは大久野島にたまに行くからです。うさぎ好きならおすすめします。一人なら泊る場所は島外にしよう！ PS. 何故か社内Redmineとかも丁寧語になってしまう現象が・・・"}]}