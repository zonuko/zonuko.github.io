{"pages":[{"text":"About me 名前 y-fujiwara nuhera or zonuko (HN) 経歴 千葉県の私立理系大学院修了(2015/3) 数理計画の類をやってた。 Pythonつかって色々やってた。 都内のIT企業に就職(2015/4 ～ 今まで) メインはC++かC#かJava たまにRubyとかJavaScript Interests アニメ SHOW BY ROCK!! 2期円盤マラソン中 Game STG どれも下手くそ レイストーム ダライアス外伝 格闘ゲーム コンボゲーと呼ばれる物 Music ゲームサントラ集め Technology 業務でつかった物 Vim 修行中 Python Elixir Haskell,Rust 勉強中・・・ Elm 線形代数 プログラミング言語作成 将来的に・・・","url":"https://zonuko.github.io/pages/about.html","title":"About","tags":"pages"},{"text":"その14です。その13の続きです。追加した Slug をURLに使ってアクセスできるようにします。 URLのカスタマイズ URLを単なるID指定から id + 先程作成した slug でアクセスできるようにします。 Phoenix.Param を impl することでカスタマイズ可能です。 1 2 3 4 5 defimpl Phoenix.Param , for : Rumbl.Video do def to_param (%{ slug : slug , id : id }) do \" #{ id } - #{ slug } \" end end 公式ドキュメント を見ると単なる impl なら @derive {Phoenix.Param, key: :username} で行けるようです。 今回は \"#{id}-#{slug}\" などのちょっとカスタムされたURLでアクセスしたいので直接実装してます。（ derive で実装できる方法はあるのだろうか・・・） IEX で上記で作成したものを試してみます。 1 2 3 iex> video = %Rumbl.Video { id: 1, slug: \"hello\" } iex> Rumbl.Router.Helpers.watch_path ( %URI {} , :show, video ) \"/watch/1-hello\" watch_path/3 の第一引数が %URI{} となっています。すべてのヘルパーはこのURI構造体を第一引数を取るらしいです。 URI構造体を使ってちょっと遊んでみます。 1 2 3 4 5 iex> url = URI.parse ( \"http://example.com/prefix\" ) %URI { authority: \"example.com\" , fragment: nil, host: \"example.com\" , path: \"/prefix\" , port: 80, query: nil, scheme: \"http\" , userinfo: nil } iex ( 6 ) > Rumbl.Router.Helpers.watch_url ( url, :show, video ) \"http://example.com/prefix/watch/1-hello\" 第一引数に与えたURLに続くパスとしてパスを構築してくれていることがわかります。じゃあ今使っている localhost のURLはどうなってんだという疑問がわきます。 以下を試してみます。 1 2 3 4 5 iex> url = Rumbl.Endpoint.struct_url %URI { authority: nil, fragment: nil, host: \"localhost\" , path: nil, port: 4000, query: nil, scheme: \"http\" , userinfo: nil } iex ( 8 ) > Rumbl.Router.Helpers.watch_url ( url, :show, video ) \"http://localhost:4000/watch/1-hello\" どうやら内部的には struct_url で全体のURLが構築されているらしいことがわかります。また、 url というAPIもあるようです。 こちらは文字列でURL全体を返してくれます。 ここまでやって、ウォッチページにとぼうとするとエラーになります。 watch_controller の :show アクションではURLパラメータとして :id を期待しているのに 1-hello のようなパラメータが来ているためです。これからこの点を修正します。 リンクの修正 上記の問題を解決するためにリンクを修正します。 lib/rumbl/permalink.ex を実装します。 ちなみに lib フォルダと web フォルダの違いはコードリロードが走るかどうかの違いのようです。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 defmodule Rumbl.Permalink do # cast,dump,load,typeの実装を要求するbehaviour @behaviour Ecto.Type def type , do : :id # changesetのcast関数が呼び出される時とかクエリを構築する時とかに使われる # 文字列の場合 def cast ( binary ) when is_binary ( binary ) do case Integer . parse ( binary ) do { int , _ } when int > 0 -> { :ok , int } _ -> :error end end def cast ( integer ) when is_integer ( integer ) do { :ok , integer } end def cast ( _ ) do :error end # データがデータベースに送信される時に呼び出される def dump ( integer ) when is_integer ( integer ) do { :ok , integer } end # データがデータベースからロードされる時に呼び出される def load ( integer ) when is_integer ( integer ) do { :ok , integer } end end データが呼び出されたり、突っ込まれたりするときの動作を記述しています。 今回関係があるのは一つ目の cast/1 関数で、文字列を binary として受け取り、先頭の数字とそれ以外でパースしている部分です。 この処理により、 3-hello のようなパラメータも受取が可能になります。 上記作ったものを利用できるように video.ex を編集します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 defmodule Rumbl.Video do use Rumbl.Web , :model # idフィールドのカスタマイズ 第二要素は型らしい @primary_key { :id , Rumbl.Permalink , autogenerate : true } schema \"videos\" do field :url , :string field :title , :string field :description , :string field :slug , :string belongs_to :user , Rumbl.User belongs_to :category , Rumbl.Category timestamps () end ... @praimary_key アトリビュートを使ってプライマリーキーをカスタマイズしています。 :id 以外をキーとしたい場合も似たような感じで書けば出来るようです。 ここまでやればビデオ閲覧画面は完成です。 まとめ Phoenix.Param を impl することでURLパラメータがカスタマイズ出来る。 @primary_key でプライマリーキーをカスタマイズ出来る。 ちょっと短かったです・・・バランスが難しい。 @primary_key の2個目の要素の型指定とかまだちょっと疑問が残るので追々調べてみようと思います。","url":"https://zonuko.github.io/posts/2017/01/31/programming-phoenix14/","title":"Programming Phoenix勉強その14","tags":"programming"},{"text":"その13です。ここからPart2です。ここから機能をちゃんと整備します。 ビデオに対してリアルタイムコメントを付けられるように ビデオを再生可能に をやっていくようです。はじめにビデオを再生可能にしていきます。 視聴用ページ作成 投稿されたビデオを見るためのページを作ります。いつものを作るのでソースのみ提示します。 app.html.eex に投稿一覧表示用メニューを付けます。 1 2 3 4 5 6 7 8 9 10 11 ... <body> <div class=\"container\"> <header class=\"header\"> <ol class=\"breadcrumb text-right\"> <!-- assignsで突っ込んだものが使えている --> <%= if @current_user do %> <li> <%= @current_user . username %> </li> <li> <%= link \"My Videos\" , to : video_path ( @conn , :index ) %> </li> <li> ... watch_controller.ex を作成します。 1 2 3 4 5 6 7 8 9 defmodule Rumbl.WatchController do use Rumbl.Web , :controller alias Rumbl.Video def show ( conn , %{ \"id\" => id }) do video = Repo . get! ( Video , id ) render conn , \"show.html\" , video : video end end wathc/show.html.eex を作成します。コメント入力欄がある唯のページです。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 <h2> <%= @video . title %> </h2> <div class=\"row\"> <div class=\"col-sm-7\"> <%= content_tag :div , id : \"video\" , data : [ id : @video . id , player_id : player_id ( @video ) ] do %> <% end %> </div> <div class=\"col-sm-5\"> <div class=\"panel panel-default\"> <div class=\"panel-heading\"> <h3 class=\"panel-title\">Annotations</h3> </div> <div id=\"msg-container\" class=\"panel-body annotations\"> </div> <div class=\"panel-footer\"> <textarea id=\"msg-input\" rows=\"3\" class=\"form-control\" placeholder=\"Comment...\"> </textarea> <button id=\"msg-submit\" class=\"btn btn-primary form-control\" type=\"submit\"> Post </button> </div> </div> </div> </div> 上記テンプレート内で player_id/1 という関数を使っているので watch_view.ex を実装します。 1 2 3 4 5 6 7 8 9 defmodule Rumbl.WatchView do use Rumbl.Web , :view def player_id ( video ) do ~r{&#94;.*(?:youtu\\.be/|\\w+/|v=)(?<id>[&#94; # &?]*)} |> Regex . named_captures ( video . url ) |> get_in ([ \"id\" ]) end end 正規表現を使って投稿されたYouTubeのURLに対してパラメータ部分のみを取り出しています。 router.ex に / スコープに get \"/watch/:id\", WatchController, :show を追加しておきます。 最後に、ビデオ一覧画面にウォッチ画面へのリンクボタンを作成します。 video/index.html.eex に以下を追加します。 1 2 3 4 5 6 7 8 9 10 11 12 ... <tbody> <%= for video <- @videos do %> <tr> <td> <%= video . user_id %> </td> <td> <%= video . url %> </td> <td> <%= video . title %> </td> <td> <%= video . description %> </td> <td class=\"text-right\"> <%= link \"Watch\" , to : watch_path ( @conn , :show , video ), class : \"btn btn-default btn-xs\" %> ... これで準備は完了です。次からJavaScript側のコードを作成します。 視聴用ページ作成 最初にPhoenixでのJavaScriptのビルド周りについて触れられています。 ビルドツールは Brunch がデフォルト Brunch の設定はデフォルトでES6になっている Brunch を使わないように変えることも可能。プロジェクト作成時に --no-Brunch オプションを与えると最初から除ける。 web/static/js 以下にあるファイルをすべて app.js にまとめる staticファイルの読み込みは static_path(@conn, \"/js/app.js\") で行う モジュールシステムを利用しないライブラリは web/static/vendor に追加する 公式ドキュメントによると bower で入れたものはこっちに配備されるっぽい？ というわけでJavaScript周りを実装します。 static/js/player.js を以下の通り実装します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 let Player = { player : null , init ( domId , player , onReadby ) { window . onYouTubeIframeAPIReady = () => { this . onIframeReady ( domId , player , onReadby ); }; let youtubeScriptTag = document . createElement ( \"script\" ); // APIの読み込み APIが読み込まれるとonYouTubeIframeAPIReady関数が自動で呼ばれる youtubeScriptTag . src = \"//www.youtube.com/iframe_api\" ; document . head . appendChild ( youtubeScriptTag ); }, onIframeReady ( domId , playerId , onReady ) { this . player = new YT . Player ( domId , { height : \"360\" , width : \"420\" , videoId : playerId , events : { \"onReady\" : ( event => onReady ( event )), \"onStateChange\" : ( event => this . onPlayerStateChange ( event )) } }); }, onPlayerStateChange ( event ) {}, getCurrentTime () { return Math . floor ( this . player . getCurrentTime () * 1000 ); }, seekTo ( millsec ) { return this . player . seekTo ( millsec / 1000 ); } }; export default Player ; YouTubeのAPIを読み込んでいます。本筋から外れてしまうので割愛します。文法がES2015形式なので昔のJavaScriptとはちょっと変わっています。 ソースを作っただけでは読み込んでくれないので static/js/app.js を以下のように変更します。 1 2 3 4 5 6 7 8 ... import Player from \"./player\" ; let video = document . getElementById ( \"video\" ); if ( video ) { Player . init ( video . id , video . getAttribute ( \"data-player-id\" ), () => { console . log ( \"player ready!\" ); }); } import 文もES2015の文法だったと記憶してます。これも特に言うことはありません。 こんな感じで実装して実行したあと、 priv/static/js/app.js を見に行くとソースがまとめられていることがわかります。 抜粋して載せてみます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 var Player = { player : null , init : function init ( domId , plyerId , onReadby ) { var _this = this ; window . onYouTubeIframeAPIReady = function () { _this . onIframeReady ( domId , playerId , onReadby ); }; var youtubeScriptTag = document . createElement ( \"script\" ); // APIの読み込み APIが読み込まれるとonYouTubeIframeAPIReady関数が自動で呼ばれる youtubeScriptTag . src = \"//www.youtube.com/iframe_api\" ; document . head . appendChild ( youtubeScriptTag ); }, onIframeReady : function onIframeReady ( domId , playerId , _onReady ) { var _this2 = this ; this . player = new YT . Player ( domId , { height : \"360\" , width : \"420\" , videoId : playerId , events : { \"onReady\" : function onReady ( event ) { return _onReady ( event ); }, \"onStateChange\" : function onStateChange ( event ) { return _this2 . onPlayerStateChange ( event ); } } }); }, onPlayerStateChange : function onPlayerStateChange ( event ) {}, getCurrentTime : function getCurrentTime () { return Math . floor ( this . player . getCurrentTime () * 1000 ); }, seekTo : function seekTo ( millsec ) { return this . player . seekTo ( millsec / 1000 ); } }; exports . default = Player ; }); スラッグの追加 各ビデオを任意のURLでアクセス出来るように Slug を付けます。 mix ecto.gen.migration add_slug_to_video を実行後以下のようにマイグレーションファイルを変更します。 1 2 3 4 5 6 7 8 9 defmodule Rumbl.Repo.Migrations.AddSlugToVideo do use Ecto.Migration def change do alter table ( :videos ) do add :slug , :string end end end 出来たらマイグレーションを実行後、 video.ex で新たに追加された slug カラムを使うようにします。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 defmodule Rumbl.Video do use Rumbl.Web , :model schema \"videos\" do field :url , :string field :title , :string field :description , :string field :slug , :string # 追加 belongs_to :user , Rumbl.User belongs_to :category , Rumbl.Category timestamps () end @doc \"\"\" Builds a changeset based on the `struct` and `params`. \"\"\" def changeset ( struct , params \\\\ %{}) do struct |> cast ( params , [ :url , :title , :description , :category_id ]) |> validate_required ([ :url , :title , :description ]) |> slugify_title () # タイトルをSlugに変換 |> assoc_constraint ( :category ) end defp slugify_title ( changeset ) do # タイトルからSlugを作成する # changesetを弄るだけで変更予定データの追加などが出来ている if title = get_change ( changeset , :title ) do put_change ( changeset , :slug , slugify ( title )) else changeset end end defp slugify ( str ) do str |> String . downcase () |> String . replace ( ~r/[&#94;\\w-]+/u , \"-\" ) end end get_change や put_change などを使うことで、変更が changeset の中だけで収まってくれています。 まとめ JavaScript のビルドツールのデフォルトは Brunch JavaScript の書式はデフォルトでES2015(ES6)形式 static系統のファイルは web/static/* に色々おいていくとよしなにしてくれる 全体的にクライアントサイドって感じでした。","url":"https://zonuko.github.io/posts/2017/01/30/programming-phoenix13/","title":"Programming Phoenix勉強その13","tags":"programming"},{"text":"その12です。テストの続きです。ビュー周りのテストからです。 テンプレートのテスト 何個か前の章でやったようにテンプレートのレンダリングも単なる関数なので簡単にテスト可能です。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 defmodule Rumbl.VideoViewTest do use Rumbl.ConnCase , async : true import Phoenix.View test \"renders index.html\" , %{ conn : conn } do videos = [% Rumbl.Video { id : \"1\" , title : \"dogs\" }, % Rumbl.Video { id : \"2\" , title : \"cats\" }] # テンプレートを文字列としてレンダリングする content = render_to_string ( Rumbl.VideoView , \"index.html\" , conn : conn , videos : videos ) assert String . contains? ( content , \"Listing videos\" ) # 内包表記は中の式は評価される for video <- videos do assert String . contains? ( content , video . title ) end end test \"renders new.html\" , %{ conn : conn } do changeset = Rumbl.Video . changeset (% Rumbl.Video {}) categories = [{ \"cats\" , 123 }] content = render_to_string ( Rumbl.VideoView , \"new.html\" , conn : conn , changeset : changeset , categories : categories ) assert String . contains? ( content , \"New video\" ) end end 注目すべきは render_to_string 関数でテンプレートを文字列としてレンダリングしている点かと思います。 実際にレンダリングをHTMLとして行わなくてもテストが出来ています。 render_to_string 関数のオプションにテンプレート側で使う変数を割り当てられるようです。 モデルのテスト（非同期） モデルのテストを行う前に model_case.ex を確認しておきます。ついでに import Rumbl.TestHelpers を追記もしておきます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 defmodule Rumbl.ModelCase do use ExUnit.CaseTemplate using do quote do alias Rumbl.Repo import Ecto import Ecto.Changeset import Ecto.Query import Rumbl.TestHelpers import Rumbl.ModelCase end end setup tags do :ok = Ecto.Adapters.SQL.Sandbox . checkout ( Rumbl.Repo ) unless tags [ :async ] do Ecto.Adapters.SQL.Sandbox . mode ( Rumbl.Repo , { :shared , self ()}) end :ok end def errors_on ( struct , data ) do struct . __struct__ . changeset ( struct , data ) |> Ecto.Changeset . traverse_errors ( & Rumbl.ErrorHelpers . translate_error / 1 ) |> Enum . flat_map ( fn { key , errors } -> for msg <- errors , do : { key , msg } end ) end end 書籍と比べて error_on 関数が変更されてますが余りきにしなくて良さそうです。ぱっとみエラーメッセージをマップに変更しているだけに見えます。 model/user_test.exs を作成し以下のように実装します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 defmodule Rumbl.UserTest do use Rumbl.ModelCase , async : true alias Rumbl.User @valid_attrs %{ name : \"A User\" , username : \"eva\" , password : \"secret\" } @invalid_attrs %{} test \"changeset with valid attributes\" do changeset = User . changeset (% User {}, @valid_attrs ) assert changeset . valid? end test \"changeset with invalid attributes\" do changeset = User . changeset (% User {}, @invalid_attrs ) refute changeset . valid? end test \"changeset does not accepts long usernames\" do attrs = Map . put ( @valid_attrs , :username , String . duplicate ( \"a\" , 30 )) assert { :username , \"should be at most 20 character(s)\" } in errors_on (% User {}, attrs ) end test \"registration_changeset password must be at least 6 chars long\" do attrs = Map . put ( @valid_attrs , :password , \"12345\" ) changeset = User . registration_changeset (% User {}, attrs ) assert { :password , { \"should be at least %{count} character(s)\" , [ count : 6 , validation : :length , min : 6 ]}} in changeset . errors end test \"registration_changeset with valid attributes hashes password\" do attrs = Map . put ( @valid_attrs , :password , \"123456\" ) changeset = User . registration_changeset (% User {}, attrs ) %{ password : pass , password_hash : pass_hash } = changeset . changes assert changeset . valid? assert pass_hash assert Comeonin.Bcrypt . checkpw ( pass , pass_hash ) end end erros_on を使っている場所は ここを参考 にしました。 これらのテストは副作用を起こさないテストでまとめたため、 async: true にして並列実行しているようです。 副作用のあるテスト 副作用が無く非同期に実行できるテストに対して、実際に Repo.insert したりするようなテストは副作用が発生します。その為、同じモデルのテストでも副作用あり/無しで分離してテストを書きます。 model/user_repo_test.exs を以下のように作成します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 defmodule Rumbl.UserRepoTest do use Rumbl.ModelCase alias Rumbl.User @valid_attrs %{ name : \"A User\" , username : \"eva\" } test \"converts unique_constraint on username to error\" do insert_user ( username : \"eric\" ) attrs = Map . put ( @valid_attrs , :username , \"eric\" ) changeset = User . changeset (% User {}, attrs ) assert { :error , changeset } = Repo . insert ( changeset ) # changeset.errorsはキーワードリストになっている # キーワードリストの各要素は最初の値がアトムとなるタプルとしても認識される assert { :username , { \"has already been taken\" , []}} in changeset . errors end end 実際にインサートを行っている以外には大した違いが無いです。 async オプションはデフォルトで false なので指定をしていません。 関係ないですが、キーワードリストについて忘れてて若干ハマりました・・・ 同様に category_repo_test.exs を以下のように作ります。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 defmodule Rumbl.CategoryRepoTest do use Rumbl.ModelCase alias Rumbl.Category test \"alphabetical/1 orders by name\" do Repo . insert! (% Category { name : \"c\" }) Repo . insert! (% Category { name : \"a\" }) Repo . insert! (% Category { name : \"b\" }) query = Category |> Category . alphabetical () query = from c in query , select : c . name assert Repo . all ( query ) == ~w(a b c) end end 別段躓くところはなかったです。 まとめ ビューは単なる関数なので render_to_string などを使って簡単にテストができる。 副作用が無いテストを分離することで非同期にテストを実行できる。 NUnit とか使ってうっかり先に書いたテストに依存するようなテストを書いちゃうことは結構ありましたが、今回のように改めてテストの同期/非同期を意識したのは新鮮でした。 書籍の区分け的にはここで一段落です。以降からパート2に入ります。 Channel とかは目玉昨日の一つだと思うのでやっていきます。","url":"https://zonuko.github.io/posts/2017/01/29/programming-phoenix12/","title":"Programming Phoenix勉強その12","tags":"programming"},{"text":"その11です。chapter8です。テストですよ 環境が test になるのでChapter7でやったWindows用コンパイルをやっておきます。細かい部分は省きます。 1 rumbl> set \"MIX_ENV=test\" && mix deps.compile テスト用に自動生成されるコードについて テストを実行する前に自動生成された video_controller_test.exs を削除しておきます。 conn_case.ex を見るとテストの初期設定がかいてあるっぽいです。ちなみに最新版だと書籍のやつと大分違います。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 defmodule Rumbl.ConnCase do use ExUnit.CaseTemplate using do quote do # Import conveniences for testing with connections use Phoenix.ConnTest alias Rumbl.Repo import Ecto import Ecto.Changeset import Ecto.Query import Rumbl.Router.Helpers # The default endpoint for testing @endpoint Rumbl.Endpoint end end setup tags do :ok = Ecto.Adapters.SQL.Sandbox . checkout ( Rumbl.Repo ) unless tags [ :async ] do Ecto.Adapters.SQL.Sandbox . mode ( Rumbl.Repo , { :shared , self ()}) end { :ok , conn : Phoenix.ConnTest . build_conn ()} end end using ブロックは対して違いが無いですが、 setup ブロックは大分違います。 Ectoのドキュメント を見て探ってみます。 Ecto.Adapters.SQL.Sandbox.checkout(Rumbl.Repo) では与えられたリポジトリに対してコネクションを取りに行っているようです。 次の Ecto.Adapters.SQL.Sandbox.mode(Rumbl.Repo, {:shared, self()}) は接続の共有方法を指定しているようです。同期的にテストを行う場合はこちらのようです。（ allow/3 関数を使った非同期の方も書いてありましたが割愛します。） また、これは checkout された接続と同じ接続を使うようなので checkout の後に呼び出すのが必須なようです。 接続に対して所有権の概念が導入されこのようになったようです。 ログアウト時のテストの実装 まずテストデータを作る関数を作ります。 test/support/test_helpers.ex を作ります。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 defmodule Rumbl.TestHelpers do alias Rumbl.Repo def insert_user ( attrs \\\\ %{}) do # Dictをマージする キーが被っている時は第二引数のものが優先される changes = Enum . into ( attrs , %{ name : \"Some User\" , username : \"user #{ Base . encode16 ( :crypto . rand_bytes ( 8 )) } \" , password : \"supersecret\" , }) % Rumbl.User {} |> Rumbl.User . registration_changeset ( changes ) |> Repo . insert! () end def insert_video ( user , attrs \\\\ %{}) do user |> Ecto . build_assoc ( :videos , attrs ) |> Repo . insert! () end end 新しい目のElixirだと Dict がdeprecatedと怒られるので Enum.into に変えてます。第一引数の Enumerable を第二引数の Collectable のものに合体します。パイプでやろうかと思いましたが逆に見にくくなりそうだったのでやめました。 作った関数を各テストで使えるように import します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 using do quote do # Import conveniences for testing with connections use Phoenix.ConnTest alias Rumbl.Repo import Ecto import Ecto.Changeset import Ecto.Query import Rumbl.Router.Helpers # 自分で実装したヘルパー関数を各テストで使えるようにする import Rumbl.TestHelpers # The default endpoint for testing @endpoint Rumbl.Endpoint end end 最後に video_controller_test.exs を作ります。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 defmodule Rumbl.VideoControllerTest do use Rumbl.ConnCase test \"requires user authentication on all actions\" , %{ conn : conn } do Enum . each ([ get ( conn , video_path ( conn , :new )), get ( conn , video_path ( conn , :index )), get ( conn , video_path ( conn , :show , \"123\" )), get ( conn , video_path ( conn , :edit , \"123\" )), put ( conn , video_path ( conn , :update , \"123\" , %{})), post ( conn , video_path ( conn , :create , %{})), delete ( conn , video_path ( conn , :delete , \"123\" )), ], fn conn -> assert html_response ( conn , 302 ) # ユーザ認証が必要なので全部設定されたパスにリダイレクトされる assert conn . halted # 認証が行われていないのでhaltedはtrueになる end ) end end ユーザ認証が行われていない時にちゃんとリダイレクトされて halted が true になっているかテストをしています。このテストは mix test で実行した時にパスするはずです。 ログイン時のテストの実装 ログアウトときたらログインということで実装してみます。 まずテスト時にログインしてないと話にならないのでそこら辺からやっていきます。 auth.ex の call/2 関数を変更します。 1 2 3 4 5 6 7 8 9 10 11 12 13 def call ( conn , repo ) do user_id = get_session ( conn , :user_id ) cond do user = conn . assigns [ :current_user ] -> conn user = user_id && repo . get ( Rumbl.User , user_id ) -> # assignでconnを変更する(importされた関数) # これによって:current_userがコントローラやビューで使えるようになる assign ( conn , :current_user , user ) true -> assign ( conn , :current_user , nil ) end end cond で場合分けをしていて、カレントユーザがすでに入ればそのまま conn を返します。これで :current_user を突っ込んだ後にこいつを呼び出せばそのまま処理に移れるはずです。 次に video_controller_test.exs を以下のように変更します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 defmodule Rumbl.VideoControllerTest do use Rumbl.ConnCase alias Rumbl.Video @valid_attrs %{ url : \"http://youtu.be\" , title : \"vid\" , description : \"a vid\" } @invalid_attrs %{ title : \"invalid\" } defp video_count ( query ), do : Repo . one ( from v in query , select : count ( v . id )) setup %{ conn : conn } = config do if username = config [ :login_as ] do # ログインしておいて欲しいときはこっち user = insert_user ( username : \"max\" ) conn = assign ( conn , :current_user , user ) { :ok , conn : conn , user : user } else # ログインしてほしくないときはこっち :ok end end test \"requires user authentication on all actions\" , %{ conn : conn } do Enum . each ([ get ( conn , video_path ( conn , :new )), get ( conn , video_path ( conn , :index )), get ( conn , video_path ( conn , :show , \"123\" )), get ( conn , video_path ( conn , :edit , \"123\" )), put ( conn , video_path ( conn , :update , \"123\" , %{})), post ( conn , video_path ( conn , :create , %{})), delete ( conn , video_path ( conn , :delete , \"123\" )), ], fn conn -> assert html_response ( conn , 302 ) # ユーザ認証が必要なので全部設定されたパスにリダイレクトされる assert conn . halted # 認証が行われていないのでhaltedはtrueになる end ) end @tag login_as : \"max\" test \"lists all user's videos on index\" , %{ conn : conn , user : user } do user_video = insert_video ( user , title : \"funny cats\" ) other_video = insert_video ( insert_user ( username : \"other\" ), title : \"another video\" ) conn = get conn , video_path ( conn , :index ) assert html_response ( conn , 200 ) =~ ~r/Listing videos/ assert String . contains? ( conn . resp_body , user_video . title ) refute String . contains? ( conn . resp_body , other_video . title ) end @tag login_as : \"max\" test \"creates user video and redirects\" , %{ conn : conn , user : user } do conn = post conn , video_path ( conn , :create ), video : @valid_attrs assert redirected_to ( conn ) == video_path ( conn , :index ) assert Repo . get_by! ( Video , @valid_attrs ) . user_id == user . id end @tag login_as : \"max\" test \"does not create video and renders errors when invalid\" , %{ conn : conn } do count_before = video_count ( Video ) conn = post conn , video_path ( conn , :create ), video : @invalid_attrs assert html_response ( conn , 200 ) =~ \"check the errors\" assert video_count ( Video ) == count_before end @tag login_as : \"max\" test \"autorizes actions against access by other users\" , %{ user : owner , conn : conn } do video = insert_video ( owner , @valid_attrs ) non_owner = insert_user ( username : \"sneaky\" ) conn = assign ( conn , :current_user , non_owner ) assert_error_sent :not_found , fn -> get ( conn , video_path ( conn , :show , video )) end assert_error_sent :not_found , fn -> get ( conn , video_path ( conn , :edit , video )) end assert_error_sent :not_found , fn -> get ( conn , video_path ( conn , :update , video , video : @valid_attrs )) end assert_error_sent :not_found , fn -> get ( conn , video_path ( conn , :delete , video )) end end end video_controller に対するテストを一気に追加しました。ポイントとなるのは以下だと思います。テスト自体にそんなに難しいところは無いと思います。 setup の部分をタグによって場合分けした。それにより、ログイン時のテストにはタグを付けることでログアウト時のテストと一緒にテストが出来る。 @～ で共通で使えるリクエストパラメータを外出しした。 Plugのテスト Plug のテストも普通のテストと同じように書けます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 defmodule Rumbl.AuthTest do use Rumbl.ConnCase alias Rumbl.Auth setup %{ conn : conn } do conn = conn |> bypass_through ( Rumbl.Router , :browser ) # bypass_through関数でRouterを経由してconnを作る |> get ( \"/\" ) { :ok , %{ conn : conn }} end test \"authenticate_user halts when no current_user exists\" , %{ conn : conn } do conn = Auth . authenticate_user ( conn , []) assert conn . halted end test \"authenticate_user continues when the current_user exists\" , %{ conn : conn } do conn = conn |> assign ( :current_user , % Rumbl.User {}) |> Auth . authenticate_user ([]) refute conn . halted end test \"login puts the user in the session\" , %{ conn : conn } do login_conn = conn |> Auth . login (% Rumbl.User { id : 123 }) |> send_resp ( :ok , \"\" ) # テスト用に:okをレスポンスとして返す next_conn = get ( login_conn , \"/\" ) assert get_session ( next_conn , :user_id ) === 123 end test \"logout drops the session\" , %{ conn : conn } do logout_conn = conn |> put_session ( :user_id , 123 ) |> Auth . logout () |> send_resp ( :ok , \"\" ) next_conn = get ( logout_conn , \"/\" ) refute get_session ( next_conn , :user_id ) end test \"call places user from session into assigns\" , %{ conn : conn } do user = insert_user () # セッションにユーザIDをを入れてcallを呼び出す conn = conn |> put_session ( :user_id , user . id ) |> Auth . call ( Repo ) assert conn . assigns . current_user . id == user . id end test \"call with no session sets current_user assign to nil\" , %{ conn : conn } do # sessionに何も入れずにcallを呼び出す conn = Auth . call ( conn , Repo ) assert conn . assigns . current_user == nil end test \"login with a valid username and pass\" , %{ conn : conn } do user = insert_user ( username : \"me\" , password : \"secret\" ) { :ok , conn } = Auth . login_by_username_add_pass ( conn , \"me\" , \"secret\" , repo : Repo ) assert conn . assigns . current_user . id == user . id end test \"login with a not found user\" , %{ conn : conn } do assert { :error , :not_found , _conn } = Auth . login_by_username_add_pass ( conn , \"me\" , \"secret\" , repo : Repo ) end test \"login with password mismatch\" , %{ conn : conn } do _ = insert_user ( username : \"me\" , password : \"secret\" ) assert { :error , :unauthorized , _conn } = Auth . login_by_username_add_pass ( conn , \"me\" , \"wrond\" , repo : Repo ) end end あまり書くことはないですが、 setup で bypass_through で各パイプを経由した conn を作っている点くらいだと思います。 セッションやらフラッシュメッセージが必要となるためです。 テストの高速化のために config/text.exs に以下を追加しておきます。 1 2 3 # テストを高速化するためにハッシュの複雑差を変えて計算の時間を減らす config :comeonin , :bcrypt_log_rounds , 4 config :comeonin , :pbkdf2_rounds , 1 まとめ よくあるテストコードと余り変わらなくて特に書くことがない・・・今までの知識を総動員している感覚があります。","url":"https://zonuko.github.io/posts/2017/01/28/programming-phoenix11/","title":"Programming Phoenix勉強その11","tags":"programming"},{"text":"その10です。 chapter7の続きです。 Ecto.Queryの利用 前のChapterで調べた Ecto.Query を利用して Category にソート用の query と取得用の query を生成できる関数を用意します。 1 2 3 4 5 6 7 def alphabetical ( query ) do from c in query , order_by : c . name end def names_and_ids ( query ) do from c in query , select : { c . name , c . id } end テンプレートの準備 カテゴリ一覧は取得できるようになったのでそれを表示できるようにしておきます。 video/form.html.eex を以下のように編集します。 1 2 3 4 5 6 7 8 9 <%= form_for @changeset , @action , fn f -> %> ... <!-- 追加 --> <div class=\"form-group\"> <%= label f , :category_id , \"Category\" , class : \"control-label\" %> <%= select f , :category_id , @categories , class : \"form-control\" , prompt : \"Choose a category\" %> </div> ... <% end %> video/new.html.eex を以下のように編集します。 1 2 3 4 5 6 <h2>New video</h2> <%= render \"form.html\" , changeset : @changeset , categories : @categories , action : video_path ( @conn , :create ) %> <%= link \"Back\" , to : video_path ( @conn , :index ) %> video/edit.html.eex を以下のように編集します。 1 2 3 4 5 6 <h2>Edit video</h2> <%= render \"form.html\" , changeset : @changeset , categories : @categories , action : video_path ( @conn , :update , @video ) %> <%= link \"Back\" , to : video_path ( @conn , :index ) %> QueryのAPIについて Query 構築の際に使えるものは以下 ==, !=, <=, >=,<,> and, or, not in like,ilike is_nil count, avg, sum, min, max datetime_add, date_add fragment, field, type より柔軟に Query を使いたい場合は fragments を使うことが出来る。 1 from ( u in User , where : fragment ( \"lower(username) = ?\" , &#94; String . downcase ( uname ))) よくある静的プレースホルダと同じでしょうか。この方法でもセキュリティは担保されています。 もっと柔軟にクエリを投げたいときは以下のように直接SQLを実行できます。 1 iex> Ecto.Adapters.SQL.query ( Rumbl.Repo, \"SELECT power( $1 , $2 )\" , [ 2, 10 ]) クエリで関連するものも取りたい時は以下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 iex ( 6 ) > user = Repo.one from ( u in User, limit: 1 ) [ debug ] QUERY OK source = \"users\" db = 16.0ms decode = 15.0ms SELECT u0. \"id\" , u0. \"name\" , u0. \"username\" , u0. \"password_hash\" , u0. \"inserted_at\" , u0. \"updated_at\" FROM \"users\" AS u0 LIMIT 1 [] %Rumbl.User { __meta__: #Ecto.Schema.Metadata<:loaded, \"users\">, id: 1, inserted_at: ~N [ 2017-01-11 03:37:33.878000 ] , name: \"aaa\" , password: nil, password_hash: \" $2 b $12$L2IGA8kAewNvbOLJ0 /c7i.4m6k18hAmuTSG4JuaHhyUK0qWfB0hae\" , updated_at: ~N [ 2017-01-16 03:40:31.371000 ] , username: \"aaa\" , videos: #Ecto.Association.NotLoaded<association :videos is not loaded>} iex ( 7 ) > user.videos # この時点ではNotLoaded #Ecto.Association.NotLoaded<association :videos is not loaded> iex ( 8 ) > user = Repo.preload ( user, :videos ) # preloadすると関連するものも取れる [ debug ] QUERY OK source = \"videos\" db = 78.0ms SELECT v0. \"id\" , v0. \"url\" , v0. \"title\" , v0. \"description\" , v0. \"user_id\" , v0. \"category_id\" , v0. \"inserted_at\" , v0. \"updated_at\" , v0. \"user_id\" FROM \"videos\" AS v0 WHERE ( v0. \"user_id\" = $1 ) ORDER BY v0. \"user_id\" [ 1 ] %Rumbl.User { __meta__: #Ecto.Schema.Metadata<:loaded, \"users\">, id: 1, inserted_at: ~N [ 2017-01-11 03:37:33.878000 ] , name: \"aaa\" , password: nil, password_hash: \" $2 b $12$L2IGA8kAewNvbOLJ0 /c7i.4m6k18hAmuTSG4JuaHhyUK0qWfB0hae\" , updated_at: ~N [ 2017-01-16 03:40:31.371000 ] , username: \"aaa\" , videos: []} iex ( 9 ) > user.videos [] Repo.preload 関数を使えば関連するものも一緒に取得できます。ただ、毎回 user の取得と preload を別々にやるのは面倒なので以下のようなオプションが良いされてます。 1 2 3 4 5 6 7 8 9 10 11 iex ( 10 ) > user = Repo.one from ( u in User, limit: 1, preload: [ :videos ]) [ debug ] QUERY OK source = \"users\" db = 0.0ms SELECT u0. \"id\" , u0. \"name\" , u0. \"username\" , u0. \"password_hash\" , u0. \"inserted_at\" , u0. \"updated_at\" FROM \"users\" AS u0 LIMIT 1 [] [ debug ] QUERY OK source = \"videos\" db = 16.0ms SELECT v0. \"id\" , v0. \"url\" , v0. \"title\" , v0. \"description\" , v0. \"user_id\" , v0. \"category_id\" , v0. \"inserted_at\" , v0. \"updated_at\" , v0. \"user_id\" FROM \"videos\" AS v0 WHERE ( v0. \"user_id\" = $1 ) ORDER BY v0. \"user_id\" [ 1 ] %Rumbl.User { __meta__: #Ecto.Schema.Metadata<:loaded, \"users\">, id: 1, inserted_at: ~N [ 2017-01-11 03:37:33.878000 ] , name: \"aaa\" , password: nil, password_hash: \" $2 b $12$L2IGA8kAewNvbOLJ0 /c7i.4m6k18hAmuTSG4JuaHhyUK0qWfB0hae\" , updated_at: ~N [ 2017-01-16 03:40:31.371000 ] , username: \"aaa\" , videos: []} iex ( 11 ) > join も普通に出来ます。 1 2 3 4 5 6 7 8 9 10 11 iex ( 11 ) > Repo.all from u in User, ... ( 11 ) > join: v in assoc ( u, :videos ) , ... ( 11 ) > join: c in assoc ( v, :category ) , ... ( 11 ) > where: c.name == \"Comedy\" , ... ( 11 ) > select : { u, v } [ debug ] QUERY OK source = \"users\" db = 31.0ms SELECT u0. \"id\" , u0. \"name\" , u0. \"username\" , u0. \"password_hash\" , u0. \"inserted_at\" , u0. \"updated_at\" , v1. \"id\" , v1. \"url\" , v1. \"title\" , v1. \"description\" , v1. \"user_id\" , v1. \"category_id\" , v1. \"inserted_at\" , v1. \"updated_at\" FROM \"users\" AS u0 INNER JOIN \"videos\" AS v1 ON v1. \"user_id\" = u0. \"id\" INNER JOIN \"categories\" AS c2 ON c2. \"id\" = v1. \"category_id\" WHERE ( c2. \"name\" = 'Comedy' ) [] [] iex ( 12 ) > 各制約について 現状のアプリケーションはマイグレーションファイルに create unique_index(:users, [:username]) とあり、重複するユーザーネームを登録しようとするとエラーになります。 このままだと画面にエラーが出てしまうので changeset で受け取れるように変更してみます。 user.ex を編集します。 1 2 3 4 5 6 7 def changeset ( model , params \\\\ %{}) do model |> cast ( params , [ :name , :username ]) # 更新予定のパラメータカラムを第三引数でとる(?) |> validate_required ([ :name , :username ]) # このリストがcastが返すchangesetに存在するか検証 |> validate_length ( :username , min : 1 , max : 20 ) |> unique_constraint ( :username ) end unique_constraint を最後のパイプラインに追加することで :username がかぶっていればエラーにしてくれます。 この調子で外部キー制約もエラーハンドリングできるようにします。 video.ex を以下のように変更します。 色々やった結果元の部分も間違っていたので修正してます。 1 2 3 4 5 6 def changeset ( struct , params \\\\ %{}) do struct |> cast ( params , [ :url , :title , :description , :category_id ]) |> validate_required ([ :url , :title , :description ]) |> assoc_constraint ( :category ) end validate_required の第三引数には何がはいるのだろうか・・・と思いましたが、 公式ドキュメント に書いてありました。 :message を取り、エラーメッセージをカスタマイズできるっぽいです。 これで外部制約も確かめることが出来ます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 iex ( 1 ) > alias Rumbl.Repo iex ( 2 ) > alias Rumbl.Video iex ( 3 ) > alias Rumbl.Category iex ( 4 ) > import Ecto.Query iex ( 5 ) > video = Repo.one ( from v in Video, limit: 1 ) iex ( 6 ) > changeset = Video.changeset ( video, % { category_id: 12345 }) iex ( 7 ) > Repo.update changeset [ debug ] QUERY OK db = 0.0ms begin [] [ debug ] QUERY ERROR db = 46.0ms UPDATE \"videos\" SET \"category_id\" = $1 , \"updated_at\" = $2 WHERE \"id\" = $3 [ 12345, {{ 2017, 1, 23 } , { 15, 2, 49, 366000 }} , 1 ] [ debug ] QUERY OK db = 0.0ms rollback [] { :error, #Ecto.Changeset<action: :update, changes: %{category_id: 12345}, errors: [ category: { \"does not exist\" , []}] , data: #Rumbl.Video<>, valid?: false> } 良さそうです。 また、削除するときには foreign_key_constraint 関数が使えます。これを使うとカテゴリが削除出来ない理由をユーザに示す事ができます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 iex> alias Rumbl.Repo iex> alias Rumbl.Category iex> alias Rumbl.Video iex> import Ecto.Query iex> import Ecto.Changeset iex> category = Repo.get_by Category, name: \"Drama\" iex> changeset = Ecto.Changeset.change ( category ) iex> changeset = foreign_key_constraint ( changeset, :videos, name: :videos_category_id_fkey, message: \"still exist\" ) iex> Repo.delete changeset [ debug ] QUERY ERROR db = 312.0ms DELETE FROM \"categories\" WHERE \"id\" = $1 [ 6 ] { :error, #Ecto.Changeset<action: :delete, changes: %{}, errors: [ videos: { \"still exist\" , []}] , data: #Rumbl.Category<>, valid?: false> } video のデータの中に既に Drama カテゴリーのIDを参照しているものがあれば設定したエラーを出してくれます。ちなみにどっかで書いたかもしれませんが Ecto.Changeset.change 関数は構造体とかからチェンジセット作ってくれる関数です。 cast やバリデーションを使いたくない時に使えるみたいです。（ 参考 ） もう一つの選択肢として、マイグレーション時に参照先が削除された時どうするかの設定が書けるみたいです。前に作った add_category_id_to_video を見てみます。 1 2 3 4 5 6 7 8 9 defmodule Rumbl.Repo.Migrations.AddCategoryIdToVideo do use Ecto.Migration def change do alter table ( :videos ) do add :category_id , references ( :categories ) end end end add :category_id, references(:categories) の部分が肝です。 references(:categories) には :on_delete オプションが付けられるようです。 :nothing ：デフォルト値。何もしない :delete_all ：関連するものも一緒に削除する :nilify_all ：関連するものが削除されたとき NULL にする まとめ Query のAPIを使うことでデータベースへの柔軟な問合せができる。 *_constraints を使うことで各制約のバリデーションを使える。 書籍の中には頻繁にデータベースでやることはデータベースの中でやるべきだとありました。また、全部に *_constraints 付けるのではなくクラッシュすべきところはクラッシュすべきとも書いてありました。ココらへんはElixirのLet's Crashの思想から来ているのかと思います。ユーザ側がどうにか出来る制約エラーの場合はカスタムエラーメッセージを出すと良いらしいです。（また英語力が・・・）","url":"https://zonuko.github.io/posts/2017/01/24/programming-phoenix10/","title":"Programming Phoenix勉強その10","tags":"programming"},{"text":"その9です。 ここからchapter7です。 Ecto の続きっぽいです。 videoのカテゴリー追加 ビデオにカテゴリーを付けられるようにします。ジェネレータを使って category モデルを生成します。ついでに色々準備もします。 以下のコマンドを実行します。 1 rumbl $ mix phoenix.gen.model Category categories name:string 出来上がったマイグレーションファイルを編集します。 NOT NULL 制約とか付けます。 1 2 3 4 5 6 7 8 9 10 11 12 13 defmodule Rumbl.Repo.Migrations.CreateCategory do use Ecto.Migration def change do create table ( :categories ) do add :name , :string , null : false timestamps () end create unique_index ( :categories , [ :name ]) end end video.ex を Category に紐付けるように変更します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 defmodule Rumbl.Video do use Rumbl.Web , :model schema \"videos\" do field :url , :string field :title , :string field :description , :string belongs_to :user , Rumbl.User belongs_to :category , Rumbl.Category timestamps () end @doc \"\"\" Builds a changeset based on the `struct` and `params`. \"\"\" def changeset ( struct , params \\\\ %{}) do struct |> cast ( params , [ :url , :title , :description ]) |> validate_required ([ :url , :title , :description ], [ :category_id ]) end end 例に漏れず cast/4 じゃなくなってるので適当に公式ドキュメント見て辻褄合わせしてます。 video モデルに category_id を追加するためのマイグレーションファイルを作ります。 1 rumbl $ mix ecto.gen.migration add_category_id_to_video 出来上がったファイルを編集します。 1 2 3 4 5 6 7 8 9 10 defmodule Rumbl.Repo.Migrations.AddCategoryIdToVideo do use Ecto.Migration def change do alter table ( :videos ) do add :category_id , references ( :categories ) end end end マイグレーションを実行します。いつものコマンドです。 マイグレーション出来たら seeds.exs を編集して初期データを作ります。カテゴリー名は他の要素で編集されない固定の値だからです。 1 2 3 4 5 6 7 alias Rumbl.Repo alias Rumbl.Category for category <- ~w(Action Drama Romance Comedy Sci-fi) do # カテゴリがすでに存在するか確認して無ければ入れる Repo . get_by ( Category , name : category ) || Repo . insert! (% Category { name : category }) end 用意したら mix run priv/repo/seeds.ex コマンドを実行すればシードデータ投入完了です。 ここまでの流れも余り違和感も不思議なところも無いかと思います。 Ectoについて ここで Ecto の Query とかについて軽く解説がありました。 iex で以下のコマンドを入力すると何が起こっているかわかります。 1 2 3 4 5 6 7 8 9 10 11 iex ( 1 ) > import Ecto.Query Ecto.Query iex ( 2 ) > alias Rumbl.Repo Rumbl.Repo iex ( 3 ) > alias Rumbl.Category Rumbl.Category iex ( 4 ) > Repo.all from c in Category, select : c.name [ debug ] QUERY OK source = \"categories\" db = 188.0ms decode = 15.0ms SELECT c0. \"name\" FROM \"categories\" AS c0 [] [ \"Action\" , \"Drama\" , \"Romance\" , \"Comedy\" , \"Sci-fi\" ] iex ( 5 ) > 上記を見てわかるのは Repo.all は Ecto.Query を取る Ecto.Query は from マクロで作れる from マクロ以降の使い方は LINQ to SQL のクエリ式っぽく書ける LINQ to SQL のクエリ式に馴染みがあるとすんなり受け入れられそうです。メソッドとかでラップされない分柔軟に使えそうだなと思いました。分解して構築することも可能です。 1 2 3 4 5 6 7 8 9 10 11 iex ( 6 ) > query = Category Rumbl.Category iex ( 7 ) > query = from c in query, order_by: c.name #Ecto.Query<from c in Rumbl.Category, order_by: [asc: c.name]> iex ( 8 ) > query = from c in query, select : c.name #Ecto.Query<from c in Rumbl.Category, order_by: [asc: c.name], select: c.name> iex ( 9 ) > Repo.all query [ debug ] QUERY OK source = \"categories\" db = 47.0ms SELECT c0. \"name\" FROM \"categories\" AS c0 ORDER BY c0. \"name\" [] [ \"Action\" , \"Comedy\" , \"Drama\" , \"Romance\" , \"Sci-fi\" ] iex ( 10 ) > 実際に Repo.all/1 とかが引数として取れるものは Ecto.Queryable プロトコルを実装したものらしいです。 Repo.all(Category) とかのような使い方が許されるのはこれらがプロトコルを実装しているからです。 Ecto.Queryableについて ふと疑問に思って Category とか User とか Video とかに Ecto.Queryable プロトコル実装している部分はどこかと思って探しました。 ざっくり探った感じまず、 Ecto.Queryable の該当ソースを見ると以下のようになっています。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 defimpl Ecto.Queryable , for : Atom do def to_query ( module ) do try do module . __schema__ ( :query ) rescue UndefinedFunctionError -> message = if :code . is_loaded ( module ) do \"the given module does not provide a schema\" else \"the given module does not exist\" end raise Protocol.UndefinedError , protocol : @protocol , value : module , description : message end end end for: Atom なんだからモジュールはだめじゃん？とか思われるかもしれませんが、モジュール名の実体は Atom なので問題ないです。 モジュールに to_atom すると true になります。ちなみに Erlang のモジュールは小文字から始まって Elixir のモジュールは :'Elixir.Module' とかになっています。ココらへんはプログラミングElixirとかを参考にするとよいかもしれないです。 話を戻して、 try の部分を見ると module.__schema__(:query) となっていることがわかります。 じゃあ __schema__/1 はどこにあるかというと Ecto.Schema に書いてあります。（内容は直接は関係ないのでおいておきます。） ここまで見て一旦自分で Queryable なモジュールを作ってみました。 1 2 3 defmodule Test do use Ecto.Schema end これで以下を呼び出してみます。 1 2 3 iex ( 0 ) > Ecto.Queryable.to_query ( Test ) ** ( Protocol.UndefinedError ) protocol Ecto.Queryable not implemented for Test, the given module does not provide a schema ( ecto ) lib/ecto/queryable.ex:37: Ecto.Queryable.Atom.to_query/1 モジュールの中に schema がないとだめとか言われているので適当に作ってみます。 1 2 3 4 5 6 defmodule Test do use Ecto.Schema schema \"test\" do end end これでさっきのをもっかい打ち込んでみます。 1 2 iex ( 0 ) > Ecto.Queryable.to_query ( Test ) #Ecto.Query<from t in Test> これでOKです。まとめておくと以下の点を満たすものが Queryable になっていると言ってよさそうです。 Ecto.Schema を use している モジュール内で schema マクロを使っている おまけ Ecto.Schema の __using__ マクロを見てみると以下のようになっています。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 defmacro __using__ ( _ ) do quote do import Ecto.Schema , only : [ schema : 2 , embedded_schema : 1 ] @primary_key nil @timestamps_opts [] @foreign_key_type :id @schema_prefix nil Module . register_attribute ( __MODULE__ , :ecto_primary_keys , accumulate : true ) Module . register_attribute ( __MODULE__ , :ecto_fields , accumulate : true ) Module . register_attribute ( __MODULE__ , :ecto_assocs , accumulate : true ) Module . register_attribute ( __MODULE__ , :ecto_embeds , accumulate : true ) Module . register_attribute ( __MODULE__ , :ecto_raw , accumulate : true ) Module . register_attribute ( __MODULE__ , :ecto_autogenerate , accumulate : true ) Module . register_attribute ( __MODULE__ , :ecto_autoupdate , accumulate : true ) Module . put_attribute ( __MODULE__ , :ecto_autogenerate_id , nil ) end end import Ecto.Schema, only: [schema: 2, embedded_schema: 1] となっているので schema/2 マクロを見てみます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 defmacro schema ( source , [ do : block ]) do schema ( source , true , :id , block ) end defp schema ( source , meta? , type , block ) do quote do ... Module . eval_quoted __ENV__ , [ Ecto.Schema . __defstruct__ ( @struct_fields ), Ecto.Schema . __changeset__ ( @changeset_fields ), Ecto.Schema . __schema__ ( prefix , source , fields , primary_key_fields ), Ecto.Schema . __types__ ( fields ), Ecto.Schema . __assocs__ ( assocs ), Ecto.Schema . __embeds__ ( embeds ), Ecto.Schema . __read_after_writes__ ( @ecto_raw ), Ecto.Schema . __autogenerate__ ( @ecto_autogenerate_id , autogenerate , autoupdate )] end end Module.eval_quoted となっています。 eval_quoted の ドキュメントを見ると quote を展開してモジュールに sum 関数を導入している例が見れます。 Ecto.Schema.__schema__ をみてみます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def __schema__ ( prefix , source , fields , primary_key ) do field_names = Enum . map ( fields , & elem ( &1 , 0 )) # Hash is used by the query cache to specify # the underlying schema structure did not change. # We don't include the source because the source # is already part of the query cache itself. hash = :erlang . phash2 ({ primary_key , fields }) quote do def __schema__ ( :query ), do : % Ecto.Query { from : { unquote ( source ), __MODULE__ }, prefix : unquote ( prefix )} def __schema__ ( :prefix ), do : unquote ( prefix ) def __schema__ ( :source ), do : unquote ( source ) def __schema__ ( :fields ), do : unquote ( field_names ) def __schema__ ( :primary_key ), do : unquote ( primary_key ) def __schema__ ( :hash ), do : unquote ( hash ) end end quote の部分が評価されるのでこれで上記のドキュメントの例と同様に __schema__ 関数がモジュールで使えるようになることがわかります。 やっぱメタプログラミングをもっと勉強しないとちゃんとソースの中身見るのはつらそうな気がします。 まとめ Ecto.Query は分解して書ける Repo.all の引数に取れるのは Ecto.Queryable プロトコルを実装したもののみ Ecto.Queryable になれるモジュールは use Ecto.Schema と schema を定義したモジュールになる。 気になったことを調べたら本題とは別の部分で長くなってしまいました・・・","url":"https://zonuko.github.io/posts/2017/01/22/programming-phoenix9/","title":"Programming Phoenix勉強その9","tags":"programming"},{"text":"その8です。 ここからchapter6です。 Ecto をコードジェネレータを色々探るみたいです。 コードジェネレータの利用 早速コードジェネレータを使ってみます。 rumbl ビデオにコメントを付けられるアプリなので Video 周りが色々と必要そうです。 Video 周りのものはコードジェネレータにおまかせしてみます。以下のコマンドを入力します。 1 rumbl $ mix phoenix.gen.html Video videos user_id:references:users url:string title:string description:text モデル名の複数形とかモジュール名とかフィールドの型情報とかを与えてやっています。 マイグレーションの前に下準備を行います。 認証処理は共有で使いたいので user_controller.ex にあった authenticate/2 関数は auth.ex に外出して置きます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 defmodule Rumbl.Auth do import Phoenix.Controller alias Rumbl.Router.Helpers ... def authenticate_user ( conn , _opts ) do # Plugで追加したassignの呼び出しが可能かどうか if conn . assigns . current_user do conn else conn |> put_flash ( :error , \"You must be logged in to access that page\" ) |> redirect ( to : Helpers . page_path ( conn , :index )) |> halt () end end end web.ex に以下を追加して全コントローラーとルーターで上記の認証関数を使えるようにします。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ... def controller do quote do use Phoenix.Controller alias Rumbl.Repo import Ecto import Ecto.Query import Rumbl.Router.Helpers import Rumbl.Gettext import Rumbl.Auth , only : [ authenticate_user : 2 ] # 追加 end end ... def router do quote do use Phoenix.Router import Rumbl.Auth , only : [ authenticate_user : 2 ] # 追加 end end 当然、 user_controller.ex の認証プラグも authenticate_user に変えておきます。 router.ex に新しいスコープを追加します。 1 2 3 4 5 scope \"/manage\" , Rumbl do pipe_through [ :browser , :authenticate_user ] resouces \"/videos\" , VideoController end ここまで行ってマイグレーションを行います。 空白文字の扱いについては、 controller 内に scrub_param という Plug が定義されており、これによって自動で nil に変換されているらしいです。 ついでに Model を見に行くとバージョンの違いが結構生成されたものが異なってます。何個か前の章で書いた用に cast/4 関数が非推奨になっているからです。 user_id を外部キーにしてるので、 user.ex も変更しておきます。 1 2 3 4 5 6 7 8 9 schema \"users\" do field :name , :string field :username , :string field :password , :string , virtual : true field :password_hash , :string has_many :videos , Rumbl.Video # 追加 timestamps () end Ectoについて ここで説明される Ecto の関数は以下 Ecto.build_assoc/3 第一引数と関連する第二引数引数の構造体を第三引数の Map の構造で作る Ecto.assoc/2 第一引数に対して has_many になっている第二引数の構造体を取り出すクエリを生成する。コンソール見ると LINQ to SQLっぽいのが流れてた 毎回のように翻訳と理解が正しいか怪しい・・・ 自動生成されたコードの調整 自動生成されたコードを調整します。 まずは video_controller.ex の :new アクションを変更します。 1 2 3 4 5 6 7 8 def new ( conn , _params ) do changeset = conn . assigns . current_user |> build_assoc ( :videos ) # current_userに関連するVideo構造体を作成 |> Video . changeset () # 上記Video構造体からchangeset作成 render ( conn , \"new.html\" , changeset : changeset ) end Video の changeset を作るだけだったのをログイン中のユーザに関連する Video にするように変更しました。 current_user は色んな所で出てきそうで鬱陶しいのでまとめられう方法を探します。幸いなことにカスタムアクションなるものがあるようです。 以下の関数を video_controller.ex に追加します。 1 2 3 def action ( conn , _ ) do apply ( __MODULE__ , action_name ( conn ), [ conn , conn . params , conn . assigns . current_user ]) end パット見わけがわかりませんが簡単です。 まず apply/3 関数はモジュール名、関数名のアトム、その関数に適用する引数を取る関数です。（ Elixirの組み込みです。 ） __MODULE__ は現在のモジュール名で、 action_name/1 は conn が要求するアクション名を返してくる関数です。（ Phoenix側で用意されている。 ） こんな感じにしてやると video_controller.ex の全アクションは上記の第三引数の引数を取るようにカスタマイズされてくれます。 なのでアクションを書き換えます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 defmodule Rumbl.VideoController do use Rumbl.Web , :controller alias Rumbl.Video # カスタムアクションで各アクションをカスタマイズする def action ( conn , _ ) do # 第一引数のモジュールの第二引数の関数に第三引数の引数を渡して実行する apply ( __MODULE__ , action_name ( conn ), [ conn , conn . params , conn . assigns . current_user ]) end def index ( conn , _params , user ) do videos = Repo . all ( user_videos ( user )) render ( conn , \"index.html\" , videos : videos ) end def new ( conn , _params , user ) do changeset = user |> build_assoc ( :videos ) # current_userに関連するVideo構造体を作成 |> Video . changeset () # 上記Video構造体からchangeset作成中身は空 render ( conn , \"new.html\" , changeset : changeset ) end def create ( conn , %{ \"video\" => video_params }, user ) do changeset = user |> build_assoc ( :videos ) # current_userに関連するVideo構造体を作成 |> Video . changeset ( video_params ) # 上記Video構造体からchangeset作成 case Repo . insert ( changeset ) do { :ok , _video } -> conn |> put_flash ( :info , \"Video created successfully.\" ) |> redirect ( to : video_path ( conn , :index )) { :error , changeset } -> render ( conn , \"new.html\" , changeset : changeset ) end end def show ( conn , %{ \"id\" => id }, user , user ) do video = Repo . get! ( user_videos ( user ), id ) render ( conn , \"show.html\" , video : video ) end def edit ( conn , %{ \"id\" => id }, user ) do video = Repo . get! ( user_videos ( user ), id ) changeset = Video . changeset ( video ) render ( conn , \"edit.html\" , video : video , changeset : changeset ) end def update ( conn , %{ \"id\" => id , \"video\" => video_params }, user ) do video = Repo . get! ( user_videos ( user ), id ) changeset = Video . changeset ( video , video_params ) case Repo . update ( changeset ) do { :ok , video } -> conn |> put_flash ( :info , \"Video updated successfully.\" ) |> redirect ( to : video_path ( conn , :show , video )) { :error , changeset } -> render ( conn , \"edit.html\" , video : video , changeset : changeset ) end end def delete ( conn , %{ \"id\" => id }, user ) do video = Repo . get! ( user_videos ( user ), id ) # Here we use delete! (with a bang) because we expect # it to always work (and if it does not, it will raise). Repo . delete! ( video ) conn |> put_flash ( :info , \"Video deleted successfully.\" ) |> redirect ( to : video_path ( conn , :index )) end defp user_videos ( user ) do assoc ( user , :videos ) end end current_user を取り出して使っていたのをカスタムアクションによって引数で取ることができるようになりました。 show アクションなどではユーザに関係のある一覧が欲しいので user_videos/1 関数を用意してあります。 これで Video 周りの実装は一旦修了です。 まとめ assoc で対象に関係のあるデータが取得できる。 コードジェネレータやルーティングについては他の言語とほとんど変わりがない","url":"https://zonuko.github.io/posts/2017/01/21/programming-phoenix8/","title":"Programming Phoenix勉強その8","tags":"programming"},{"text":"その7です。 ここからchapter5です。認証周りをやるらしいです。 パスワードのハッシュ化 まずはパスワードのハッシュ化を行います。必要なライブラリをインストールするために mix.exs に以下のように追記を行います。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ... def application do [ mod : { Rumbl , []}, applications : [ :phoenix , :phoenix_pubsub , :phoenix_html , :cowboy , :logger , :gettext , :phoenix_ecto , :postgrex , :comeonin ]] # comeoninを追加 end ... defp deps do [{ :phoenix , \"~> 1.2.1\" }, { :phoenix_pubsub , \"~> 1.0\" }, { :phoenix_ecto , \"~> 3.0\" }, { :postgrex , \">= 0.0.0\" }, { :phoenix_html , \"~> 2.6\" }, { :phoenix_live_reload , \"~> 1.0\" , only : :dev }, { :gettext , \"~> 0.11\" }, { :cowboy , \"~> 1.0\" }, { :comeonin , \"~> 2.0\" }] # 追加 end application に対して追加しているのはこのアプリの依存ライブラリを書いているようです。 comeonin とか言うライブラリを追加しています。 リポジトリ を見るとそのまんまパスワードをハッシュ化してくれるライブラリだとわかります。 mix deps.get で追加できたらモデルでこいつを使うように変更してやります。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def changeset ( model , params \\\\ %{}) do model |> cast ( params , [ :name , :username ]) # 更新予定のパラメータカラムを第三引数でとる(?) |> validate_required ([ :name , :username ]) # このリストがcastが返すchangesetに存在するか検証 |> validate_length ( :username , min : 1 , max : 20 ) end def registration_changeset ( model , params ) do model |> changeset ( params ) |> cast ( params , [ :password ]) |> validate_required ([ :password ]) |> validate_length ( :password , min : 6 , max : 100 ) |> put_pass_hash () end defp put_pass_hash ( changeset ) do case changeset do % Ecto.Changeset { valid? : true , changes : %{ password : pass }} -> put_change ( changeset , :password_hash , Comeonin.Bcrypt . hashpwsalt ( pass )) _ -> changeset end end Ecto の最新版を使っているので書籍と若干異なっています。新しい方の Ecto では cast/4 は推奨されなくなっているようです。 なので、 Phoenixのガイド とか、 Ectoのドキュメント とかを見て適当に修正してます。（このやり方でいいか不安ですが・・・） また、 :empty もWarningになるので、空のハッシュに変えています。 ついでに create アクションで User.changeset の部分を User.registration_changeset に変更します。 ここまでやってMacだとOKでしたが、Windowsだとエラーになりました。 Windowsでのエラー（comeonin） Windowsから comeonin を使おうとするとコンパイルを促すエラーが出るので ここ を参考にコンパイルします。 ちなみにVisualStudioインストールしてあったので最下部付近にあるVSインストール済みの場合の方法を取っています。 VSに付属している開発者コマンドプロンプトを起動します。 開発者コマンドプロンプト上で以下のコマンドを実行しておきます。 1 > vcvarsall.bat amd64 vcvarsall.bat にパスが通ってない場合は、適当にフルパスで指定すればいいと思います。これを行わなくてもコンパイル自体は出来ますが、実行時にエラーになりました。（ vcvarsall.bat については MSDN ） 本プロジェクト（ rumbl ）のディレクトリまで移動して以下のコマンドを実行します。 1 rumbl > mix deps.compile 自分の環境ではこれでうまくいきました。 Plugについて Plug を使ってログイン機能を作る前に Plug についてちょっと掘ります。 Plug にはモジュールプラグと関数プラグの二種類が存在する。 モジュールプラグは名前の通り幾つかの関数を集めたモジュールのプラグ 関数プラグは関数名をアトムとして指定したプラグ ログイン機能としてモジュールプラグを作成します。 モジュールプラグ モジュールプラグとして設定するモジュールには init/1 関数と call/2 関数が必要とされます。 以下は何もしないモジュールプラグの例です。 1 2 3 4 5 6 7 8 9 defmodule NothingPlug do def init ( opts ) do opts end def call ( conn , _opts ) do conn end end call 関数の引数を見るとわかりますが、モジュールプラグは conn を変換するようです。 Plug.Connについて(conn) Plug.Conn が持つフィールドについて見てみます。 書籍の方には色々書いてありますが割愛します。 Plug.Connの公式ドキュメント を参照して下さい。ここではリクエストフィールドが持つものだけを見てみます。 host リクエストのホスト名 ex) www.pragprog.com method リクエストのWebメソッド（GETとかPOSTとか） path_info パスを分割したリスト req_headers リクエストヘッダ scheme プロトコル（httpとか） Webのリクエスト周りに関係するものが存在していることがわかります。 認証プラグの実装 やっと認証用のプラグを実装します。 controllers/auth.ex を以下の内容で実装します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 defmodule Rumbl.Auth do import Plug.Conn def init ( opts ) do # キーワードリストから:repoの箇所の値を取得する # 無ければexception(つまりは必須) Keyword . fetch! ( opts , :repo ) end def call ( conn , repo ) do user_id = get_session ( conn , :user_id ) user = user_id && repo . get ( Rumbl.User , user_id ) # assignでconnを変更する(importされた関数) # これによって:current_userがコントローラやビューで使えるようになる assign ( conn , :current_user , user ) end end コメント通りなので余り言うことはないです。 init で repo を取得してそれが conn の第二引数に渡されるようです。セッションにあるユーザIDからユーザを取得しています。 パイプラインの流れの一部として処理してほしいので router.ex を以下のように変更します。 1 2 3 4 5 6 7 8 pipeline :browser do plug :accepts , [ \"html\" ] plug :fetch_session plug :fetch_flash plug :protect_from_forgery plug :put_secure_browser_headers plug Rumbl.Auth , repo : Rumbl.Repo # 追加 end アクセス制限の実装 Plug は出来たのでアクセス制限とログインを作ります。ログインしない限りは :index アクションと :show アクションにアクセス出来ないようにします。 user_controller.ex を以下のように変更します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 defmodule Rumbl.UserController do ... def index ( conn , _params ) do case authenticate ( conn ) do # 構造体connのhaltedメンバのパターンマッチによる振り分け % Plug.Conn { halted : true } = conn -> conn conn -> users = Repo . all ( Rumbl.User ) render conn , \"index.html\" , users : users end end ... defp authenticate ( conn ) do # Plugで追加したassignの呼び出しが可能かどうか if conn . assigns . current_user do conn else conn |> put_flash ( :error , \"You must be logged in to access that page\" ) |> redirect ( to : page_path ( conn , :index )) |> halt () end end end 先程の Plug で変更した値を authenticate/1 関数で使っています。また、 :index アクションのアクセス時に authenticate 関数で認証済みかチェック掛けています。 authenticate の関数プラグ化 user_controller.ex の Rumbl.Web の直下のあたりに以下を追加します。 1 plug :authenticate when action in [ :index , :show ] また、 index アクションを case 文を使う以前のものに戻しておきます。 authenticate 関数も以下のように2引数にしておきます。 1 2 3 4 5 6 7 8 9 10 11 defp authenticate ( conn , _opts ) do # Plugで追加したassignの呼び出しが可能かどうか if conn . assigns . current_user do conn else conn |> put_flash ( :error , \"You must be logged in to access that page\" ) |> redirect ( to : page_path ( conn , :index )) |> halt () end end _opts を追加しただけです。関数 Plug 化したためです。 Plug をマクロ展開したときの例が出てますが割愛します。 ログインの実装 認証までしか無いので実際のログイン処理を実装します。取り敢えず create アクションでユーザが作成された時に自動でログインするようにしてみます。 先程作った auth.ex に以下の関数を追加します。 1 2 3 4 5 6 def login ( conn , user ) do conn |> assign ( :current_user , user ) |> put_session ( :user_id , user . id ) |> configure_session ( renew : true ) # セッションキーとかを新しくしている(セキュリティのため) end 次に create アクションでこの関数を呼び出すようにしてやります。 1 2 3 4 5 6 7 8 9 10 11 12 def create ( conn , %{ \"user\" => user_params }) do changeset = User . registration_changeset (% User {}, user_params ) case Repo . insert ( changeset ) do { :ok , user } -> conn |> Rumbl.Auth . login ( user ) # ユーザを作成したらログイン |> put_flash ( :info , \" #{ user . name } created!\" ) |> redirect ( to : user_path ( conn , :index )) { :error , changeset } -> render ( conn , \"new.html\" , changeset : changeset ) end end これで完了です。 ログイン画面の実装 ここまででログインするための素材は揃ったので、ログイン/ログアウト画面を作ります。今まで作ったものの合わせ技なので一気に行きます。 session_controller.ex を実装します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 defmodule Rumbl.SessionController do use Rumbl.Web , :controller def new ( conn , _ ) do render conn , \"new.html\" end def create ( conn , %{ \"session\" => %{ \"username\" => user , \"password\" => pass }}) do case Rumbl.Auth . login_by_username_add_pass ( conn , user , pass , repo : Repo ) do { :ok , conn } -> conn |> put_flash ( :info , \"Welcome back!\" ) |> redirect ( to : page_path ( conn , :index )) { :error , _reason , conn } -> conn |> put_flash ( :error , \"Invalid username/password combination\" ) |> render ( \"new.html\" ) end end def delete ( conn , _ ) do conn |> Rumbl.Auth . logout () |> redirect ( to : page_path ( conn , :index )) end end session_view.ex も作っておきます。内容は割愛します。関数などは定義しなくて良いです。 router.ex も上で作った session_controller.ex 用に追加しておきます。 1 2 3 4 5 6 7 scope \"/\" , Rumbl do pipe_through :browser # Use the default browser stacks. get \"/\" , PageController , :index resources \"/users\" , UserController , only : [ :index , :show , :new , :create ] resources \"/sessions\" , SessionController , only : [ :new , :create , :delete ] # 追加 end usernameとpasswordでログインするための関数とログアウト用の関数を auth.ex に用意しておきます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ... import Comeonin.Bcrypt , only : [ checkpw : 2 , dummy_checkpw : 0 ] ... def logout ( conn ) do configure_session ( conn , drop : true ) end def login_by_username_add_pass ( conn , username , given_pass , opts ) do repo = Keyword . fetch! ( opts , :repo ) user = repo . get_by ( Rumbl.User , username : username ) # 複数の値で分岐しているためcaseではなくcond(caseは与えられた1つの値に対する分岐) cond do user && checkpw ( given_pass , user . password_hash ) -> { :ok , login ( conn , user )} user -> { :error , :unauthorized , conn } true -> dummy_checkpw () { :error , :not_found , conn } end end ログイン画面用のテンプレートも作ります。まず session/new.html.eex を以下のように実装します。 1 2 3 4 5 6 7 8 9 10 11 12 <h1>Login</h1> <%= form_for @conn , session_path ( @conn , :create ), [ as : :session ] , fn f -> %> <div class=\"form-group\"> <%= text_input f , :username , placeholder : \"Username\" , class : \"form-control\" %> </div> <div class=\"form-group\"> <%= password_input f , :password , placeholder : \"Password\" , class : \"form-control\" %> </div> <%= submit \"Log in\" , class : \"btn btn-primary\" %> <% end %> 最後に今まで作ったもののリンクを表示します。 layout/app.html.eex を以下のように変更します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <header class=\"header\"> <ol class=\"breadcrumb text-right\"> <!-- assignsで突っ込んだものが使えている --> <%= if @current_user do %> <li> <%= @current_user . username %> </li> <li> <%= link \"Log out\" , to : session_path ( @conn , :delete , @current_user ), method : \"delete\" %> </li> <% else %> <li> <%= link \"Register\" , to : user_path ( @conn , :new ) %> </li> <li> <%= link \"Log in\" , to : session_path ( @conn , :new ) %> </li> <% end %> </ol> <span class=\"logo\"></span> </header> これでOKなはずです。 まとめ Plug.Conn を使ったセッションやコネクションの管理はスマートだし中身が分かればわかりやすいと思いました。関数の引数に毎回 conn が出てきちゃいますが・・・ 本のおかげかもしれませんが余りブラックボックスな部分を残さないよう理解出来ている感があるのが良いです。 関数型だけあってかロジックを関数毎に分離しているのがとても良かったです。書いてて理解し易い気がします。 1記事がやたらと長くなりましたが実験ということで・・・","url":"https://zonuko.github.io/posts/2017/01/19/programming-phoenix7/","title":"Programming Phoenix勉強その7","tags":"programming"},{"text":"その6です。 実際にDBを操作するところからです。 新規ユーザ生成処理 Rumbl.UserController に以下の関数を実装します。 1 2 3 4 def new ( conn , _params ) do changeset = User . changeset (% User {}) render conn , \"new.html\" , changeset : changeset end changeset 周りとかが謎めいていますが一旦置いときます。単に自分が今理解してないだけですが・・・ DBの操作とそれ以外の検証とかエラーとかセキュリティとかを分離するのに役立つっぽいです。 user.ex に上記で利用している User.changeset 関数を実装します。 1 2 3 4 5 def changeset ( model , params \\\\ :empty ) do model |> cast ( params , ~w(name username) , []) |> validate_length ( :username , min : 1 , max : 20 ) end Ecto を使う関数を定義しました。 cast で Ecto.changeset を生成してバリデーションチェックを掛けているようです。 前準備 :new アクションを実装する前に前準備をします。 今まで書いてあったルーティング設定を消して以下を追加します。まぁ説明不要だと思います。 1 resouces \"/users\" , UserController , only : [ :index , :show , :new , :create ] テンプレート実装 :new に対応するテンプレートを適当に作ります。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 <h1>New User</h1> <%= form_for @changeset , user_path ( @conn , :create ), fn f -> %> <div class=\"form-group\"> <%= text_input f , :name , placeholder : \"Name\" , class : \"form-control\" %> </div> <div class=\"form-group\"> <%= text_input f , :username , placeholder : \"Username\" , class : \"form-control\" %> </div> <div class=\"form-group\"> <%= password_input f , :password , placeholder : \"Password\" , class : \"form-control\" %> </div> <%= submit \"Create User\" , class : \"btn, btn-primary\" %> <% end %> ここまでやって起動したところ、何やらWarningが出たので解消します。 1 2 3 4 5 6 7 8 9 10 11 warning: ` Ecto.Changeset.cast/4 ` is deprecated, please use ` cast/3 ` + ` validate_required/3 ` instead ( rumbl ) web/models/user.ex:15: Rumbl.User.changeset/2 ( rumbl ) web/controllers/user_controller.ex:16: Rumbl.UserController.new/2 ( rumbl ) web/controllers/user_controller.ex:1: Rumbl.UserController.action/2 ( rumbl ) web/controllers/user_controller.ex:1: Rumbl.UserController.phoenix_controller_pipeline/2 warning: passing :empty to Ecto.Changeset.cast/3 is deprecated, please pass an empty map or :invalid instead ( rumbl ) web/models/user.ex:15: Rumbl.User.changeset/2 ( rumbl ) web/controllers/user_controller.ex:16: Rumbl.UserController.new/2 ( rumbl ) web/controllers/user_controller.ex:1: Rumbl.UserController.action/2 ( rumbl ) web/controllers/user_controller.ex:1: Rumbl.UserController.phoenix_controller_pipeline/2 Warningの解消 Ecto とかのバージョの違いのせいか2つWarningが出てました。1つは user.ex の changeset/2 関数のデフォルト引数で :empty としていた部分です。 その部分を以下のように変えます。 1 def changeset ( model , params \\\\ %{}) do 単純に空の Map にしただけですね。 もう1つ cast/4 関数を呼び出している部分でもWarningが出ているので修正します。 1 2 3 4 model |> cast ( params , [ :name , :username ]) |> validate_required ([ :name , :username ]) |> validate_length ( :username , min : 1 , max : 20 ) ここ とか ここらへん 参考にしましたが英語力の無さ故にあってるかわからないです。誰か教えて!! パラメータの名前的にはあってそうですが・・・ また、これを見ると cast が changeset を返してきて、それに対してバリデーションを掛けているのがわかります。 Createアクションの実装 new アクションを実装したので実際にDBにインサートする create アクションを実装します。 1 2 3 4 5 6 7 8 9 10 11 def create ( conn , %{ \"user\" => user_params }) do changeset = User . changeset (% User {}, user_params ) case Repo . insert ( changeset ) do { :ok , user } -> conn |> put_flash ( :info , \" #{ user . name } created!\" ) |> redirect ( to : user_path ( conn , :index )) { :error , changeset } -> render ( conn , \"new.html\" , changeset : changeset ) end end あんまり説明することはないですが、 conn からのパイプラインで作成後の template 用の処理を読んでる点くらいでしょうか。パイプラインが最大の特徴かもしれませんが・・・ また、 new.html.eex もエラーを表示するように変えます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 <h1>New User</h1> <%= if @changeset . action do %> <div class=\"alert alert-danger\"> <p>Oops, something went wrong! Please check the errors below.</p> </div> <% end %> <%= form_for @changeset , user_path ( @conn , :create ), fn f -> %> <div class=\"form-group\"> <%= text_input f , :name , placeholder : \"Name\" , class : \"form-control\" %> <%= error_tag f , :name %> </div> <div class=\"form-group\"> <%= text_input f , :username , placeholder : \"Username\" , class : \"form-control\" %> <%= error_tag f , :username %> </div> <div class=\"form-group\"> <%= password_input f , :password , placeholder : \"Password\" , class : \"form-control\" %> <%= error_tag f , :password %> </div> <%= submit \"Create User\" , class : \"btn, btn-primary\" %> <% end %> error_tag/2 関数は view の error_helpers.ex に定義されている関数です。 Changesetについて このchapterの最後に changeset について触れられています。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 iex ( 1 ) > changeset = Rumbl.User.changeset ( %Rumbl.User { username: \"eric\" }) #Ecto.Changeset<action: nil, changes: %{}, errors: [ name: { \"can't be blank\" , [ validation: :required ]}] , data: #Rumbl.User<>, valid?: false> iex ( 2 ) > changeset #Ecto.Changeset<action: nil, changes: %{}, errors: [ name: { \"can't be blank\" , [ validation: :required ]}] , data: #Rumbl.User<>, valid?: false> iex ( 3 ) > import Ecto.Changeset Ecto.Changeset iex ( 4 ) > changeset.changes % {} iex ( 5 ) > changeset = put_change ( changeset, :username, \"ericmj\" ) #Ecto.Changeset<action: nil, changes: %{username: \"ericmj\"}, errors: [ name: { \"can't be blank\" , [ validation: :required ]}] , data: #Rumbl.User<>, valid?: false> iex ( 6 ) > changeset.changes % { username: \"ericmj\" } iex ( 7 ) > get_change ( changeset, :username ) \"ericmj\" これを見ると changeset はバリデーション以外にも変更をの追跡と保持を行っていることがわかります。 まとめ 簡単なDB操作を行いました。今回はテンプレート周りはおまけだったように思います。 何かしらフレームワーク触ったことあればそんなに違和感はなく使えると思います。 ずっと changeset が謎だったんですが、少し理解できたと思います。 基本的なところは結構網羅されてきたんじゃないかと思いますのでサクサク行きたいです。","url":"https://zonuko.github.io/posts/2017/01/11/programming-phoenix6/","title":"Programming Phoenix勉強その6","tags":"programming"},{"text":"その5です。ここからChapter4です。 Ecto を使って独自実装してた Repository を Postgres に置き換えていきます。 まず lib/rumbl/repo.ex をもとに戻します。 1 2 3 defmodule Rumbl.Repo do use Ecto.Repo , otp_app : :rumbl end さらに lib/rumbl.ex でコメントアウトした部分をもとに戻します。 1 2 # Start the Ecto repository supervisor ( Rumbl.Repo , []), # ここのコメントアウトを戻す まだ mix ecto.create をしてなければしておきます。 modelの実装 次に model の実装を行います。 web/model/user.ex を以下の内容で実装します。 1 2 3 4 5 6 7 8 9 10 11 12 defmodule Rumbl.User do use Rumbl.Web , :model schema \"users\" do field :name , :string field :username , :string field :password , :string , virtual : true field :password_hash , :string timestamps end end ActiveRecord 使ったことがあればそんなに違和感なく受け入れられると思います。 :virtual オプションは値として受け取るが、DBには保存しない値です。 ここまで行って起動してみたら以下のような警告が出ました。 1 2 3 warning: variable \"timestamps\" does not exist and is being expanded to \"timestamps()\" , please use parentheses to remove the ambiguity or change the variable name web/models/user.ex:10 timestamps が変数なのか timestamps/0 の関数呼び出しか曖昧だと言われてるようです。 今回は timestamps/0 の呼び出しなので timestamps の部分を timestamps() にすると警告がでなくなります。 ここらへん を参考にしました。 最後に web/web.ex の model 関数を以下のように変更します。 1 2 3 4 5 6 7 8 9 def model do quote do use Ecto.Schema import Ecto import Ecto.Changeset import Ecto.Query , only : [ from : 1 , from : 2 ] # only以下を追加 end end DBのマイグレーション DB側にもテーブルとかを作る必要があるので以下のコマンドを実行します。 1 2 3 rumbl $ mix ecto.gen.migration create_user * creating priv/repo/migrations * creating priv/repo/migrations/20170108070642_create_user.exs 生成された priv/repo/migrations/{日付}_create_user.exs ファイルを以下のように変更します。 これもRailsやったことあれば説明不要だと思います。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 defmodule Rumbl.Repo.Migrations.CreateUser do use Ecto.Migration def change do create table ( :users ) do add :name , :string add :username , :string , null : false add :password_hash , :string timestamps () end create unique_index ( :users , [ :username ]) end end mix ecto.migrate でマイグレーションを実行します。 まとめ Model 周りの話でした。O/Rマッパー使ったことあればあまり違和感なく受け入れられそうでした。 関係ないですけど、基本的な部分終わったらガンガン飛ばしていこうと思います。亀のようなペースだと全然おわらないので。","url":"https://zonuko.github.io/posts/2017/01/09/programming-phoenix5/","title":"Programming Phoenix勉強その5","tags":"programming"},{"text":"その4です。 その3の続きです。 :show アクションの実装からです. :showアクションの実装 :show アクションで各ユーザの詳細を表示できるようにします. まず Controler を実装します. 1 2 3 4 def show ( conn , %{ \"id\" => id }) do user = Repo . get ( Rumbl.User , id ) render conn , \"show.html\" , user : user end 次に, web/templates/user/show.html.eex を以下の内容で実装します. 1 2 <h1>Showing User</h1> <b> <%= first_name ( @user ) %> </b> ( <%= @user . id %> ) よく見ると <b> タグの部分が index.html.eex とかぶっているのがわかります. templateの分離 各テンプレートで重複している部分を別テンプレートに分離します. web/templates/user/user.html.eex を以下の内容で実装します. 1 <b> <%= first_name ( @user ) %> </b> ( <%= @user . id %> ) 共通部分をくくりだしたので,既存のテンプレートを編集します. web/templates/user/index.html.eex を以下の内容に変更します. <%= render \"user.html\", user: user %> の部分が変更点です. 1 2 3 4 5 6 7 8 9 10 <h1>Listing Users</h1> <table class=\"table\"> <%= for user <- @users do %> <tr> <td> <%= render \"user.html\" , user : user %> </td> <td> <%= link \"View\" , to : user_path ( @conn , :show , user . id ) %> </td> </tr> <% end %> </table> web/templates/user/show.html.eex も同様に変更します. 1 2 <h1>Showing User</h1> <%= render \"user.html\" , user : @user %> view はモジュール, template は関数と捉えると良いみたいです. iex -S mix で以下のコマンドを入力すると何が起きているかなんとなくわかります. view の部分が :safe とリストの入れ子のタプルになってて一見わかりにくいですが,リストの部分は単なるタグの入れ子になってるみたいです. 素のタグ部分と, <%= %> とか <% %> の部分とでわけられてるみたいです. 1 2 3 4 5 6 iex ( 1 ) > user = Rumbl.Repo.get Rumbl.User, \"1\" %Rumbl.User { id: \"1\" , name: \"Jose\" , password: \"elixir\" , username: \"josevalim\" } iex ( 2 ) > view = Rumbl.UserView.render ( \"user.html\" , user: user ) { :safe, [[[[[ \"\" | \"<b>\" ] | \"Jose\" ] | \"</b> (\" ] | \"1\" ] | \")\\n\" ]} iex ( 3 ) > Phoenix.HTML.safe_to_string ( view ) \"<b>Jose</b> (1)\\n\" :safe はこのHTMLが安全であることを示しています. また、リストになっているのはパフォーマスのためだそうです. ぱっと見どのテンプレートも render 関数呼び出しで呼び出されるっぽいですがテンプレート名でパターンマッチが行われることによってレンダリングしてるようです. error 見るとよりわかりやすそうです. 1 2 3 4 5 6 7 def render ( \"404.html\" , _assigns ) do \"Page not found\" end def render ( \"500.html\" , _assigns ) do \"Internal server error\" end render 関数が2つあって第一引数のテンプレート名でパターンマッチしてるのがわかります. レンダリングについて 一番初めに templates/layout/app.html.eex がレンダリングされて,その後正規のテンプレートがレンダリングされる. まぁRailsとかもおんなじ感じだったと思うのでここらへんは適当にすっ飛ばします. まとめ ここでChapter3終わるのでちょっと短いですがここまでです. @conn みたいな度々出てくる conn の正体がまだイマイチ理解しきれてないので具体的にどういうものがどういう流れで入ってきてるのかぼちぼちしらべたいです.","url":"https://zonuko.github.io/posts/2017/01/07/programming-phoenix4/","title":"Programming Phoenix勉強その4","tags":"programming"},{"text":"その3です。 その2の続きです。 今回からChpater3です. このChapterではまず rumbl と呼ばれるアプリを作ります. ビデオにたいしてリアルタイムでコメントを付けられるアプリになる予定らしい. 準備 Chapter1と同様に以下のコマンドでPhoenixの新しいプロジェクトを作成します.（詳細は割愛） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ mix phoenix.new rumbl * creating rumbl/ config/ config.exs ... Fetch and install dependencies? [ Yn ] y * running mix deps.get * running npm $ cd rumbl rumbl $ mix ecto.create == > connection Compiling 1 file （.ex） Generated connection app ... Modelの追加 実際はコマンドで自動生成されるものを手製で実装します. web/models/user.ex を以下の内容で実装します. 1 2 3 defmodule Rumbl.User do defstruct [ :id , :name , :username , :password ] endD これは id, name, username, password 構造体として持つUserモジュールです. Repositoryの変更 現段階では,RepositoryはRDBからではなく独自にハードコーディングします. このようにすることで,データの概念とデータベースの概念が分離されていることがわかります. （ Repo と Model として） まず, lib/rumbl/repo.ex を以下のように変更します. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 defmodule Rumbl.Repo do @moduledoc \"\"\" In memory repository. \"\"\" def all ( Rumbl.User ) do [% Rumbl.User { id : \"1\" , name : \"Jose\" , username : \"josevalim\" , password : \"elixir\" }, % Rumbl.User { id : \"2\" , name : \"Bruce\" , username : \"redropids\" , password : \"7longs\" }, % Rumbl.User { id : \"3\" , name : \"Chris\" , username : \"chrismccord\" , password : \"phx\" }] end def all ( _module ), do : [] def get ( module , id ) do Enum . find all ( module ), fn map -> map . id == id end end def get_by ( module , params ) do Enum . find all ( module ), fn map -> Enum . all? ( params , fn { key , val } -> Map . get ( map , key ) == val end ) end end end Ecto を使わないようにしたので, lib/rumbl.ex を編集して上記の repo.ex をプロセス管理対象から外します. 1 2 # Start the Ecto repository # supervisor(Rumbl.Repo, []), # これをコメントアウト 上手く行っているか試すにはコンソールでプロジェクトフォルダに移動して iex -S mix コマンドで iex を起動します. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 rumbl $ iex -S mix Erlang/OTP 19 [ erts-8.2 ] [ source ] [ 64-bit ] [ smp:4:4 ] [ async-threads:10 ] [ hipe ] [ kernel-poll:false ] [ dtrace ] Compiling 7 files ( .ex ) Interactive Elixir ( 1.3.4 ) - press Ctrl+C to exit ( type h () ENTER for help ) iex ( 1 ) > alias Rumbl.User Rumbl.User iex ( 2 ) > alias Rumbl.Repo Rumbl.Repo iex ( 3 ) > Repo.all User [ %Rumbl.User { id: \"1\" , name: \"Jose\" , password: \"elixir\" , username: \"josevalim\" } , %Rumbl.User { id: \"2\" , name: \"Bruce\" , password: \"7longs\" , username: \"redropids\" } , %Rumbl.User { id: \"3\" , name: \"Chris\" , password: \"phx\" , username: \"chrismccord\" }] iex ( 4 ) > Repo.all Rumbl.Other [] iex ( 5 ) > Repo.get User, \"1\" %Rumbl.User { id: \"1\" , name: \"Jose\" , password: \"elixir\" , username: \"josevalim\" } iex ( 6 ) > Repo.get_by User, name: \"Brunce\" nil iex ( 7 ) > Repo.get_by User, name: \"Bruce\" %Rumbl.User { id: \"2\" , name: \"Bruce\" , password: \"7longs\" , username: \"redropids\" } iex ( 8 ) > Controllerの実装 上記で作成した Repository を扱う Controller を実装します. まず,専用のルーティング設定を web/router.ex に設定します. 1 2 3 4 5 6 7 scope \"/\" , Rumbl do pipe_through :browser # Use the default browser stacks. get \"/users\" , UserController , :index # 追加 get \"/users/:id\" , UserController , :show # 追加 get \"/\" , PageController , :index end みて分かる通り UserControler の index アクションと show アクションに対応するルーティング設定を行います. get マクロはHTTPメソッドのGETで呼び出されることを想定されています. 次に,設定したルーティングに対応する Controller を実装します. 1 2 3 4 5 6 7 8 defmodule Rumbl.UserController do use Rumbl.Web , :controller def index ( conn , _params ) do users = Repo . all ( Rumbl.User ) render conn , \"index.html\" , users : users end end hello アプリで作成したものと対して変わらないと思います. 違いは Repo.all/1 関数でユーザ一覧を取ってきてることくらいだと思います. この時点でもまだ View がないとエラーになるので, View の実装をします. Viewの実装 web/views/user_view.ex を以下の内容で実装します. 1 2 3 4 5 6 7 8 9 10 defmodule Rumbl.UserView do use Rumbl.Web , :view alias Rumbl.User def first_name (% User { name : name }) do name |> String . split ( \" \" ) |> Enum . at ( 0 ) end end 単純に名前を名字と名前で分解しているだけの関数です. View モジュール名は Controller 名から自動で推測されます. （ UserController なら UserView といった具合） Templateの実装 web/templates/user/index.html.eex を以下の内容で実装します. 1 2 3 4 5 6 7 8 9 10 <h1>Listing Users</h1> <table class=\"table\"> <%= for user <- @users do %> <tr> <td><b> <%= first_name ( user ) %> </b> ( <%= user . id %> )</td> <td>> <%= link \"View\" , to : user_path ( @conn , :show , user . id ) %> </td> </tr> <% end %> </table> Template は View 名から自動で推測されます. （ UserView なら user フォルダといった具合） ここまでくれば http://localhost:4000/users でユーザ一覧が表示されます. EEx のハイライトないので ERB でハイライトしてます. Viewのuse Rumbl.Web, :viewについて view に記述した use Rumbl.Web, :view の実体は web/web.ex に存在します. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 defmodule Rumbl.Web do … def view do quote do use Phoenix.View , root : \"web/templates\" # Import convenience functions from controllers import Phoenix.Controller , only : [ get_csrf_token : 0 , get_flash : 2 , view_module : 1 ] # Use all HTML functionality (forms, tags, etc) use Phoenix.HTML import Rumbl.Router.Helpers import Rumbl.ErrorHelpers import Rumbl.Gettext end end … end Phoenix.HTML をHTML周りのことを色々やってくれているようです. また,これによって生成されるHTMLは安全で,XSS対策なども行ってくれているようです. ここには勝手に関数を書くのはNG.書きたいなら真似して import を使うこと. まとめ 今回は前回より具体的に各機能を実装しました. 個人的には今までよくわからなかった Repository と Model の関係がちょっとわかったのが収穫でした. 他のフレームワーク触ってると, View と Template が分離しているのが一瞬戸惑いそうだとおもいました.","url":"https://zonuko.github.io/posts/2017/01/04/programming-phoenix3/","title":"Programming Phoenix勉強その3","tags":"programming"},{"text":"その2です。 その1の続きです。 デフォルトのディレクトリ構成について config ディレクトリ Phoenixの設定ファイル置き場.名前のまま. prod.secret.exs は秘密情報が入っているファイルなので,VCSからは外すこと. config.exs の endpoint はWebサーバーとアプリケーションの接続の境界部分. lib ディレクトリ Supervision treeと,長く起動するプロセスが置かれる.（?,あってるか微妙） DBとのコネクションプールとかのような長く使われるものが置かれるっぽい. test ディレクトリ 名前の通りテストが置かれる. web ディレクトリ Webアプリに必要な model , view , template , controller が置かれる. Plugについて Plug ライブラリは接続の統一化のために使われる. Plug のリポジトリ [Plugリポジトリ] には以下のように書いてある. ・ A specification for composable modules between web applications ・ Connection adapters for different web servers in the Erlang VM なので,各機能のモジュールの仕様の記述と,Erlang VMと各Webサーバーとの接続をやってくれるみたいです. （あまり理解してない感が） 実際にPhoenixが作ってくれる物を見てみます. config/endpoint.exs を見てみます. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 defmodule Hello.Endpoint do use Phoenix.Endpoint , otp_app : :hello socket \"/socket\" , Hello.UserSocket # Serve at \"/\" the static files from \"priv/static\" directory. # # You should set gzip to true if you are running phoenix.digest # when deploying your static files in production. plug Plug.Static , at : \"/\" , from : :hello , gzip : false , only : ~w(css fonts images js favicon.ico robots.txt) # Code reloading can be explicitly enabled under the # :code_reloader configuration of your endpoint. if code_reloading? do socket \"/phoenix/live_reload/socket\" , Phoenix.LiveReloader.Socket plug Phoenix.LiveReloader plug Phoenix.CodeReloader end plug Plug.RequestId plug Plug.Logger plug Plug.Parsers , parsers : [ :urlencoded , :multipart , :json ], pass : [ \"*/*\" ], json_decoder : Poison plug Plug.MethodOverride plug Plug.Head # The session will be stored in the cookie and signed, # this means its contents can be read but not tampered with. # Set :encryption_salt if you would also like to encrypt it. plug Plug.Session , store : :cookie , key : \"_hello_key\" , signing_salt : \"zzWE+Yw+\" plug Hello.Router end とりあえず plug ってのがいっぱい出てきています. なんとなく見てると, plug Plug.Static で静的ファイルについての設定っぽいものが書いてあったり, plug Plug.Logger とか, plug Plug.Parsers とかあったりして,Webアプリに必要な設定が書いてあるっぽいなと言う感覚です. ココらへんの一連の plug は関数のパイプラインとして処理されるようです. 1 2 3 4 5 6 7 8 9 connection |> Plug.Static . call |> Plug.RequestId . call |> Plug.Logger . call |> Plug.Parsers . call |> Plug.MethodOverride . call |> Plug.Head . call |> Plug.Session . call |> Hello.Router . call ソースに書いた順になってるっぽいです.Servletの設定順ミスってハマった思い出が… ちなみに endpoint 自体も plug で,アプリケーション自体は endpoint で始まり controller で終わる一連のパイプラインらしい. Routerについて web/router.ex のソースを見ると,2つのパイプラインがあることがわかる. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 defmodule Hello.Router do use Hello.Web , :router pipeline :browser do plug :accepts , [ \"html\" ] plug :fetch_session plug :fetch_flash plug :protect_from_forgery plug :put_secure_browser_headers end pipeline :api do plug :accepts , [ \"json\" ] end scope \"/\" , Hello do pipe_through :browser # Use the default browser stack get \"/hello/:name\" , HelloController , :world get \"/\" , PageController , :index end # Other scopes may use custom stacks. # scope \"/api\", Hello do # pipe_through :api # end end browser パイプライン HTMLのみを受け付ける. セッション管理とか,フラッシュメッセージとか,セキュリティ対策とかを提供してくれるらしい. api パイプライン 基本的なJSON API用のパイプライン.JSONのみ受け付ける. XMLにしたいときとかはここ一箇所変更すれば全部変更される. pipe_through でどのパイプラインを使うか書く. 処理の流れとしては接続を取得→パイプラインを呼び出し→コントローラーを呼び出し. 呼び出し順を纏めると以下になる. 1 2 3 4 5 connection |> endpoint |> router |> pipeline |> controller まとめ 今回は,内部的な処理の流れとかおまじない的な部分が何をしてるかの勉強だった感じです. 英語がヘタレ過ぎて自分が理解している意味とあってるか若干の不安が... リンク [Plugリポジトリ] https://github.com/elixir-lang/plug","url":"https://zonuko.github.io/posts/2016/12/31/programming-phoenix2/","title":"Programming Phoenix勉強その2","tags":"programming"},{"text":"買ってあったけど読んでなかったので読みます.プログラミングElixirは原著の方も翻訳の方も一応読んでます. プログラミングElixirについては色々なところで書評なり見る気がするけど,こっちの方は余り見ない気がします. ちなみに実際にコードを書くPart1のChapter2からやってきます. あとPhoenix自体は何回か触ってます.趣味で. 前提 PostgreSQL9.5 Elixir 1.3.2 Phoenix Framework1.2.1 本より新し目のバージョンにしてるので,色々問題ありそうですが頑張る感じで行きます. 初期構築 プロジェクトテンプレートの生成としてはじめに以下のコマンドを入力します. 1 2 3 4 5 6 7 $ mix phoenix.new hello * creating hello/ config/ config.exs ... Fetch and install dependencies? [ Yn ] y * running mix deps.get * running npm これでカレントディレクトリにhelloってフォルダが掘られて,色々勝手に整備してくれる. 次に以下のコマンドでDB作ったりします. 1 2 3 4 5 6 $ cd hello hello $ mix ecto.create == > connection Compiling 1 file （.ex） Generated connection app ... これで hello_dev とか言うデータベースができていればOKです. 出来てなければ, config/dev.exs ってファイルにDBとの接続設定があるので見直します. 起動 以下のコマンドでサーバー起動. 1 2 $ cd hello $ mix phoenix.server mix phoenix.server の部分は iex -S mix phoenix.server でもOK.こちらはIEXの内部でサーバーが起動する. ちなみにデフォルトでは localhost:4000 で起動する. ルーティング 特定のURLとのルーティングを行うには, web/router.exs に設定を書く. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 defmodule Hello.Router do # 省略 scope \"/\" , Hello do pipe_through :browser # Use the default browser stack get \"/hello\" , HelloController , :world # 追加 get \"/\" , PageController , :index end # Other scopes may use custom stacks. # scope \"/api\", Hello do # pipe_through :api # end end 見ればなんとなくわかると思いますが, get マクロに対して色々ルーティングの設定をします. この場合は /hello にアクセスが来たら HelloController （モジュール）の :world アクション（関数）を呼び出すようにしてます. ただ,この段階だと HelloController がないのでアクセスしてもエラー画面です. エラー画面が若干本と違ってたので貼っておきます. Controller実装 エラーを解消するために web/controllers/hello_controller.ex を以下の内容で作ります. 1 2 3 4 5 6 7 defmodule Hello.HelloController do use Hello.Web , :controller def world （ conn , _param ） do render conn , \"world.html\" end end ファイル名はController名をスネークケース,モジュール名は, （ scope で設定した名前） . （ get に設定したController名）で作ります. （ココらへんの理解が微妙に曖昧） で,また /hello にアクセスすると,今度はviewがないと怒られます。 View実装 web/views/hello_view.ex を以下の内容で作ります. 1 2 3 defmodule Hello.HelloView do use Hello.Web , :view end で,今度はtemplateが無いって怒られるのでまた作ります. Template実装 web/templates/world.html.eex を以下の内容で作ります. 1 < h1 > From template: Hello world! </ h1 > これで晴れて /hello にアクセスしても怒られなくなります. Routing時のパラメータ 次に,ルーティング時にパラメータを渡す方法を実装します. （ /hoge/1/ のような感じに） web/router.ex に上の方で追加したルーティング設定を修正します. 1 get \"/hello/:name\" , HelloController , :world こうすると :name の部分が色々変えられてControllerに渡されてきます. なので,Controllerを以下のように変更して渡された値を取得できるようにします. 1 2 3 def world ( conn , %{ \"name\" => name }) do render conn , \"world.html\" , name : name end パターンマッチにより渡されてきた値が name にバインドされます. パターンマッチについては本の中で解説されてますが,飛ばします.プログラミングElixirとかElixirのチュートリアルとか読んでもらえれば. 最後に,template側で渡された値を表示するようにしてあげれば完成. 1 < h1 > Hello < %= String.capitalize @name %>! </ h1 > <%= ～ %> の部分にElixirの関数が書けて, @name の部分にControllerから渡された値が入ってくるようです. まとめ とりあえず今回はここまでとしておきます。 かなり復習感ありましたが,基本的な部分はなんとなくわかったと思います。 やっぱりRailsにかなり近くて,Railsやってた人はここらへんはあまり深く読まなくても良い気がします. あと名前付けとかのルールとかは追々という感じで調べていきたいです.","url":"https://zonuko.github.io/posts/2016/12/28/programming-phoenix1/","title":"Programming Phoenix勉強その1","tags":"programming"},{"text":"大した理由は無いけど色々あってブログを書くことにしました。 動機 始めようと思った理由は以下のような感じです。 勉強だけは色々するけど、発表する場が社内でもない。（自分で作ればあるけど・・・） EvernoteとかOnenoteにまとめてたけど中々見づらくてあとで振り返りづらい。 社外の人とも技術的な交流がする場が欲しい。 技術的なアウトプットを目に見える形で出すことにメリットが有ると思ったから。 構成 Pelicanと適当にテーマ使って作ってます。なので見た目はちょくちょく変わるかも。 サーバー自体はGitHub Pages使ってます。 Pelican選んだ理由は以下のような感じです。 Python好きだったから。 流行ってるもの嫌いな天邪鬼だから。（流行ってるものが素晴らしかったり楽しいのは理解してるんですが・・・） 方向性 基本的には技術的な内容にしていきたいですが、好きなゲームとか音楽とかアニメとかも話すかもしれないです。 あと、数学も大学院終わって大分忘れてきているので、勉強したらその内容でも投稿しようかと。 Pelicanについて ググればいくらでも出ると思いますが、PelicanはPython製の静的サイトジェネレーターです。 （Rubyで言うJekyllとかに値するやつ） 元々個人的に作った社内資料まとめとかにはSphinx使ってて、その流れって感じです。 具体的なPelicanの設定うんぬんは気が向けばそのうち書きます。環境は以下の感じ。 OS Windows10 64bit or Mac OS X El Capitan 諸事情でSierraじゃないです。 Python3.5.2 Pelican 3.6.3 エディタの類 Visual Studio Code Vim その他 Pelican良いと思いますが、ブログを書くという一点のみに着目すると車輪の再発明感も否めないです。 多分好き勝手書いていくと思うので、何か間違ってるとかあればコメントしてもらうか、Twitterにリプなりくれれば多分反応します。 うさぎの画像がたまに出てくるのは大久野島にたまに行くからです。うさぎ好きならおすすめします。一人なら泊る場所は島外にしよう！ PS. 何故か社内Redmineとかも丁寧語になってしまう現象が・・・","url":"https://zonuko.github.io/posts/2016/12/25/my-first-article/","title":"ブログ書くことにした","tags":"misc"}]}