{"pages":[{"title":"About","text":"About me 名前 y-fujiwara nuhera or zonuko (HN) 経歴 千葉県の私立理系大学院修了(2015/3) 数理計画の類をやってた。 Pythonつかって色々やってた。 都内のIT企業に就職(2015/4 ～ 今まで) メインはC++かC#かJava たまにRubyとかJavaScript Interests アニメ SHOW BY ROCK!! 2期円盤マラソン中 Game STG どれも下手くそ レイストーム ダライアス外伝 格闘ゲーム コンボゲーと呼ばれる物 Music ゲームサントラ集め Technology 業務でつかった物 Vim 修行中 Python Elixir Haskell,Rust 勉強中・・・ Elm 線形代数 プログラミング言語作成 将来的に・・・","tags":"pages","url":"pages/about.html"},{"title":"最近買ったゲームサントラ","text":"ちょっとYouTubeのプラグインとAmazonのリンクを貼るすべを身に着けたので 練習がてらサントラの紹介を動画と合わせてしてみます。 2016/12月 バトルガレッガ色々 バトルガレッガのコンシューマ版とか一緒に出たアレンジサントラとか買いました。 バトルガレッガ Rev.2016 Premium Edition 【同梱物】\"バトルガレッガ2016Edition\"サウンドトラックCD、設定資料集、復刻インストラクションカード&基板マニュアル - PS4 posted with カエレバ エムツー 2016-12-15 Amazon バトルガレッガ コンプリートサウンドトラック posted with カエレバ ゲーム・ミュージック Sweep Record 2016-12-30 Amazon どの曲もめちゃくちゃ良いのですが個人的に一番好きなのは以下の thrust and thrash! って曲です 曲自体も好きなんですが、何より6面ボスジャンキーモンキーでひたすら稼いでいる動画が凄く好きで この曲も好きになってます。その稼いでいる動画が以下(30分くらいから) 形態変化が結構あるのとか、最終段階の手の動きとか、稼ぐための死闘感とかが好きです。 2017/3月 飛んで3月です。 1～2月はサントラ以外のCDをよく買ってたみたいです。 星霜鋼機ストラニア ザ・フォース・シグナル 星霜鋼機ストラニアってゲームの作曲者によるセルフアレンジCDですね。 このCDも全曲良かったです。基本的にはオリジナル至上主義なんでアレンジとか余り好きじゃないんですが、 このCDに関してはとても良かったです。 星霜鋼機ストラニア ザ・フォース・シグナル posted with カエレバ 与猶啓至 Sweep Record 2017-04-04 Amazon で、一番気に入っているのが以下のラスボス用の曲 曲もかなり気に入っているんですが、何より気に入っているのはこのステージの演出です。(10分くらいからです。) ゲームの曲はやっぱりゲームとセットで本領発揮だなと改めて思わせてくれます。 3月はもう一個買ってます。 パックマン チャンピオンシップエディション サウンドトラックス パックマンチャンピオンシップエディションのシリーズをまとめたようなサントラを買いました。 シリーズ幾つかやったことあったし、iTunesとかで過去のサントラ買ったりしてましたが買ってしまいました。 パックマン チャンピオンシップエディション サウンドトラックス posted with カエレバ ゲーム・ミュージック Sweep Record 2017-04-04 Amazon 全体的にリッジレーサーとかあのへんのナムコサウンズのノリを感じます。その中で好きだったのが以下の曲 ノリノリって感じの曲ですね。ゲーム本編の動画も見てて楽しいのでおすすめです。 まとめ 以上のような感じでした。 YouTubeプラグインに関してはレスポンシブに対応するためにCSS書く必要ありましたがテンプレート用意されているので大した手間ではなく使うことが出来ました。 アマゾンのアフィリエイトもHTMLのタグをそのまま貼り付けられるのでアカウントさえあれば簡単でした。 それにしてもこの手のリンクたくさん貼り付けるとめちゃくちゃ見づらいですな・・・","tags":"music","url":"posts/2017/04/20/recently-bought-ost/"},{"title":"Programming Phoenix勉強その20","text":"なんとその20です。 channel のテストの続きです。 wolfram のテストはしたので channel 周りのテストからです。 Channelの認証テスト wolfram のサービス用テストは作ったのでそれを呼び出す channel 側のテストを書きます。 まず認証をテストします。 rumbl/test/channel/user_socket_test.exs を実装します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 defmodule Rumbl.Channels.UserSocketTest do use Rumbl.ChannelCase , async : true alias Rumbl.UserSocket test \"socket authentication with valid token\" do token = Phoenix.Token . sign ( @endpoint , \"user socket\" , \"123\" ) assert { :ok , socket } = connect ( UserSocket , %{ \"token\" => token }) assert socket . assigns . user_id == \"123\" end test \"socket authentication with invalid token\" do assert :error = connect ( UserSocket , %{ \"token\" => \"123\" }) assert :error = connect ( UserSocket , %{}) end end 単純にトークンを作った後にちゃんと処理ができるということを確かめているテストとトークン作らない場合に失敗するテストを書いています。 Channelのテスト 認証が正しく出来ていることは確認できたので、本物の channel のテストを行います。 video_channel_test.exs を以下の内容で実装します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 defmodule Rumbl.Channels.VideoChannelTest do use Rumbl.ChannelCase import Rumbl.TestHelpers setup do user = insert_user ( name : \"Rebecca\" ) video = insert_video ( user , title : \"Testing\" ) token = Phoenix.Token . sign ( @endpoint , \"user socket\" , user . id ) # コネクションのシュミレート { :ok , socket } = connect ( Rumbl.UserSocket , %{ \"token\" => token }) { :ok , socket : socket , user : user , video : video } end test \"join replies with video annotations\" , %{ socket : socket , video : vid } do for body <- ~w(one two) do vid |> build_assoc ( :annotations , %{ body : body }) |> Repo . insert! () end # チャンネルへの参加 { :ok , reply , socket } = subscribe_and_join ( socket , \"videos: #{ vid . id } \" , %{}) # 正しいチャンネルに参加していること assert socket . assigns . video_id == vid . id # annotationがすべて取得出来ていること assert %{ annotations : [%{ body : \"one\" }, %{ body : \"two\" }]} = reply end test \"inserting new annotations\" , %{ socket : socket , video : vid } do { :ok , _ , socket } = subscribe_and_join ( socket , \"videos: #{ vid . id } \" , %{}) # イベントをチャンネルにプッシュ ref = push socket , \"new_annotation\" , %{ body : \"the body\" , at : 0 } assert_reply ref , :ok , %{} assert_broadcast \"new_annotation\" , %{} end test \"new annotations triggers InfoSys\" , %{ socket : socket , video : vid } do insert_user ( username : \"wolfram\" ) { :ok , _ , socket } = subscribe_and_join ( socket , \"videos: #{ vid . id } \" , %{}) ref = push socket , \"new_annotation\" , %{ body : \"1 + 1\" , at : 123 } assert_reply ref , :ok , %{} assert_broadcast \"new_annotation\" , %{ body : \"1 + 1\" , at : 123 } assert_broadcast \"new_annotation\" , %{ body : \"2\" , at : 123 } end end 普通にテストしているので余り書くことも無い気がします・・・ 強いていうなら push でイベントをシュミレートしているのと、ユーザが wolfram であること前提となっているのを カバーしている点くらいな気がします。 ここまでで mix test を実施すればすべて通るはずです。 書籍の内容はここまでで完了ですが、個人的にリリース方法が知りたかったのもあったので調べてやってみます。 リリース準備 Phoenix を含む umbrella プロジェクトをリリースしてみます。 プログラミングElixirとかだと Exrm を利用しているようですが、 新しい方ということで distillery を使います。 また、 prod.secret.ex の有無とかも省きます。なければ適当に用意してください。 これもリリース用のライブラリですが、 Exrm より強化されて umbrella プロジェクトへの 対応など強化されているようです。 rumbrella/mix.exs の deps に以下を追加します。 1 2 3 defp deps do [{ :distillery , \"~> 1.0\" }] end mix deps.get を実行しておきます。 ここから先は ここ とか、 公式ドキュメント とかを参考にします。 まず初めに production 環境で ecto.create とかをしておきます。 1 2 3 4 rumbrella $ MIX_ENV = prod mix ecto.create rumbrella $ MIX_ENV = prod mix ecto.migrate rumbrella $ MIX_ENV = prod mix run ./apps/rumbl/priv/repo/seeds.exs rumbrella $ MIX_ENV = prod mix run ./apps/rumbl/priv/repo/backend_seeds.exs こんな感じで適当にDBを準備しておきます。 次に assets ファイルを準備します。 1 rumbrella $ MIX_ENV = prod mix phoenix.digest また、 package.json に書いてあるとおり、静的ファイルをリリース用にビルドします。 1 2 rumbrella $ cd ./apps/rumbl rumbl $ npm run deploy 次にリリース用に設定ファイルとかを生成します。 1 rumbrella $ MIX_ENV = prod mix release.init これやると rumbrella/rel とかいうフォルダが生成されます。 これでリリースといきたいですが、 :httpc の依存を設定ファイルに切っておきます。 rumbl/mix.exs です。 1 2 3 4 5 def application do [ mod : { Rumbl , []}, applications : [ :phoenix , :phoenix_pubsub , :phoenix_html , :cowboy , :logger , :gettext , :phoenix_ecto , :postgrex , :comeonin , :inets , :info_sys ]] end :inets を追加しました。これがないとリリースビルド後の実行でエラーになります。 また、リリース用設定を rumbl 側にもしておきます。 prod.exs です。 1 2 3 4 5 config :rumbl , Rumbl.Endpoint , http : [ port : 4001 ], url : [ host : \"localhost\" , port : 8080 ], cache_static_manifest : \"priv/static/manifest.json\" , server : true # リリース用サーバー開始設定 ここまでやってリリースビルドです。 1 2 3 4 5 6 7 8 9 10 rumbrella $ MIX_ENV = prod mix release --env = prod == > Assembling release.. == > Building release rumbrella:0.1.0 using environment prod == > Including ERTS 8 .2 from /usr/local/Cellar/erlang/19.2/lib/erlang/erts-8.2 == > Packaging release.. == > Release successfully built! You can run it in one of the following ways: Interactive: _build/prod/rel/rumbrella/bin/rumbrella console Foreground: _build/prod/rel/rumbrella/bin/rumbrella foreground Daemon: _build/prod/rel/rumbrella/bin/rumbrella start こんな感じのメッセージがでるので _build/prod/rel/rumbrella/bin/rumbrella console コマンドを実行すると 実行できます。 http://localhost:4001 でいけるはずです。 まとめ channel のテストも他のと同様な感覚で書くことが可能 リリースには distillery を利用する これで本の内容+αが終了です。リリースも簡単ですね。 そのうち何か作ろうと思いますが、趣味の言語あさりとかを優先してるかもしれないです。","tags":"programming","url":"posts/2017/02/17/programming-phoenix20/"},{"title":"Programming Phoenix勉強その19","text":"その19です。ここからChapter12です。今まで作った InfoSys アプリとかを アンブレラプロジェクトに変更してテストしやすくするみたいです。 rumbrellaプロジェクトの作成と設定 以下のコマンドでアンブレラプロジェクトを新たに生成します。 既存の rumbl プロジェクトと混じらないように適当な場所で実行します。 1 $ mix new rumbrella --umbrella アンブレラプロジェクトが作成されたので、 cd rumbrella/app に移動して以下のコマンドを実行します。 1 app $ mix new info_sys 準備が出来たので既存の Rumbl.InfoSys と Rumbl を rumbrella 管理下に移植していきます。 まず Rumbl.InfoSys からやっていきます。以下の流れです。 Rumbl.InfoSys のモジュール名を InfoSys に変更して、 lib/rumbl/info_sys.ex を app フォルダで作成した info_sys/lib/info_sys.ex となるように移動します。 Rumbl.InfoSys.Supervisor も同じようにリネームして info_sys/lib/info_sys/supervisor.ex となるように移動します。 Rumbl.InfoSys.Wolfram も supervisor と同じようにして同じフォルダに移動します。 Rumbl.InfoSys となっている箇所をすべて InfoSys に置換します。 Wolfram Alpha のAPIキーを取得する関数を以下のように変更します。 1 defp app_id , do : Application . get_env ( :info_sys , :wolfram )[ :app_id ] 依存関係を移し替えておきます。 info_sys の mix.exs の deps に {:sweet_xml, \"~> 0.5.0\"} を追加します。 これで InfoSys の移動は完了です。以下を実行しておきます。 1 2 rumbrella $ mix deps.get rumbrella $ mix test 次は Rumbl 本体の移植を行います。 Rumblプロジェクトのrumbrellaへの移植 Rumbl プロジェクトを rumbrella に移植します。 rumbl ディレクトリを rumbrella/apps 以下に移動します。 rumbl の mix.exs 内の project 関数に info_sys の mix.exs と合わせるような感じで以下を追加します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def project do [ app : :rumbl , version : \"0.0.1\" , elixir : \"~> 1.2\" , elixirc_paths : elixirc_paths ( Mix . env ), compilers : [ :phoenix , :gettext ] ++ Mix . compilers , build_embedded : Mix . env == :prod , start_permanent : Mix . env == :prod , aliases : aliases (), build_path : \"../../_build\" , config_path : \"../../config/config.exs\" , deps_path : \"../../deps\" , lockfile : \"../../mix.lock\" , deps : deps ()] end mix.exs の application 関数に :info_sys を追加します。 :comeonin の後に追加する感じです。 deps の :sweet_xml を削除して {:info_sys, in_umbrella: true} を追加します。 lib/rumbl.ex から children として追加していた Rumbl.InfoSys を削除します。 video_channel.ex で使っていた Rumbl.InfoSys を InfoSys に変更します。 dev.secret.exs の WolframAlpha のキー部分を :rumbl から :info_sys に変更します。 これで準備OKです。 最後に mix deps.get と mix test を実行しておきます。 OTPのテスト ここで終わると短いので、このまま chapter13 に入って OTP のテストを行います。 自動で生成されている info_sys_test.exs を以下のように変更します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 defmodule InfoSysTest do use ExUnit.Case alias InfoSys.Result defmodule TestBackend do def start_link ( query , ref , owner , limit ) do Task . start_link ( __MODULE__ , :fetch , [ query , ref , owner , limit ]) end def fetch ( \"result\" , ref , owner , _limit ) do send ( owner , { :results , ref , [% Result { backend : \"test\" , text : \"result\" }]}) end def fetch ( \"none\" , ref , owner , _limit ) do send ( owner , { :results , ref , []}) end def fetch ( \"timeout\" , _ref , owner , _limit ) do # プロセス監視用にテスト実行元にpidを送る send ( owner , { :backend , self ()}) :timer . sleep ( :infinity ) end def fetch ( \"boom\" , _ref , _owner , _limit ) do raise \"boom!\" end end test \"compute/2 with backend results\" do assert [% Result { backend : \"test\" , text : \"result\" }] = InfoSys . compute ( \"result\" , backends : [ TestBackend ]) end test \"compute/2 with no backend results\" do assert [] = InfoSys . compute ( \"none\" , backends : [ TestBackend ]) end test \"compute/2 with timeout returns no results and kills workers\" do results = InfoSys . compute ( \"timeout\" , backends : [ TestBackend ], timeout : 10 ) assert results == [] # 上のfetch(\"timeout\", 〜) 関数から送られてくるPID assert_receive { :backend , backend_pid } ref = Process . monitor ( backend_pid ) assert_receive { :DOWN , &#94; ref , :process , _pid , _reason } # receivedはすでに受信ボックスに入っているものを取り出す # 受信をまったりはしない refute_received { :DOWN , _ , _ , _ , _ } refute_received :timeout end @tag :capture_log test \"compute/2 discards backend errors\" do assert InfoSys . compute ( \"boom\" , backends : [ TestBackend ]) == [] refute_received { :DOWN , _ , _ , _ , _ } refute_received :timeout end end wolfram などのバックエンドAPIの代わりとなるモジュールを内部に定義しています。 タイムアウトの処理は assert_receive や refute_received を使ってタイムアウト時のメッセージを受け取ることで行っています。 例外発生時のテストも似たような感じですが、普通にやるとコンソールにエラーメッセージが表示されると出 @tag :capture_log で制御しています。 今までのテストとそう変わったところは無いかと思います。 Wolfram APIの分離 現状の Wolfram API は :httpc がハードコーディングされており、こいつを使うことが前提になっています。 これだとテストが難しいのでまずはこの取得先設定を外部ファイルにします。 wolfram.ex を変更します。 1 2 3 4 5 6 7 8 @http Application . get_env ( :info_sys , :wolfram )[ :http_client ] || :httpc defp fetch_xml ( query_str ) do { :ok , { _ , _ , body }} = @http . request ( String . to_char_list ( \"http://api.wolframalpha.com/v2/query\" <> \"?appid= #{ app_id () } \" <> \"&input= #{ URI . encode_www_form ( query_str ) } &format=plaintext\" )) body end 接続に使うモジュールを @http と言うかたちで config 系統のファイルに外出しました。 また、 URI.eocode_www_form にしています。 外部ファイルを作ります。 config/text.exs を作ります。 1 2 3 4 5 use Mix.Config config :info_sys , :wolfram , app_id : \"1234\" , http_client : InfoSys.Test.HTTPClient 環境によって動的に設定ファイルを読み込むように config.exs の import_config \"#{Mix.env}.exs\" のコメントを外しておきます。 テスト以外の環境でも外部ファイルが必要となるので、 use Mix.Config だけ書いた dev.exs と prod.exs を作っておきます。 次にテスト用のXMLデータを持ってきます。 本の公式サイトのソース置き場 からソースを持ってきて test/fixtures フォルダに wolfram.xml ファイルを設置しておきます。 http のクライアントも作ります。 test/backends/http_client.exs を以下の内容で作ります。 1 2 3 4 5 6 7 8 9 10 11 12 defmodule InfoSys.Test.HTTPClient do @wolfram_xml File . read! ( \"test/fixtures/wolfram.xml\" ) def request ( url ) do url = to_string ( url ) cond do String . contains? ( url , \"1+%2B+1\" ) -> { :ok , {[], [], @wolfram_xml }} true -> { :ok , {[], [], \"<queryresult></queryresult>\" }} end end end test_helper.exs にこの外部ファイル化したモジュールが読み込まれていることを確認する設定を書きます。 1 2 3 Code . require_file \"backends/http_client.exs\" , __DIR__ ExUnit . start () rumbl の方にも似たように書きます。 1 2 3 4 5 Code . require_file \"../../info_sys/test/backends/http_client.exs\" , __DIR__ ExUnit . start Ecto.Adapters.SQL.Sandbox . mode ( Rumbl.Repo , :manual ) ここまで来てやっと最後にテストを書きます。 test/backends/woldram_test.exs です。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 defmodule InfoSys.Backends.WolframTest do use ExUnit.Case , async : true alias InfoSys.Wolfram test \"makes request, reports results, them terminates\" do ref = make_ref () { :ok , pid } = Wolfram . start_link ( \"1 + 1\" , ref , self (), 1 ) Process . monitor ( pid ) assert_receive { :results , &#94; ref , [% InfoSys.Result { text : \"2\" }]} assert_receive { :DOWN , _ref , :process , &#94; pid , :normal } end test \"no query results reports an empty list\" do ref = make_ref () { :ok , _ } = Wolfram . start_link ( \"none\" , ref , self (), 1 ) assert_receive { :results , &#94; ref , []} end end これで基本的なテストはOKです。 まとめ umbrella プロジェクトを使うことでAPI同士の結合を弱めて、テストがやりやすくなる。 テストをする際はスタブとなるような構造体などを作ってやると良い","tags":"programming","url":"posts/2017/02/14/programming-phoenix19/"},{"title":"Programming Phoenix勉強その18","text":"その18です。実際に OTP を使ったアプリを Rumbl に組み込みます。 InfoSysアプリの追加 WolframAlpha のようなサービスを利用して動画の再生中に何かしらの質問をすると何か答えが返ってくるAPI を追加します。 まず Supervisor を追加します。 lib/info_sys/supervisor.ex を実装します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 defmodule Rumbl.InfoSys.Supervisor do use Supervisor def start_link () do Supervisor . start_link ( __MODULE__ , [], name : __MODULE__ ) end def init ( _opts ) do children = [ worker ( Rumbl.InfoSys , [], restart : :temporary ) ] supervise children , strategy : :simple_one_for_one end end 今まで習ったとおりですが、戦略は :simple_one_for_one を使っています。 処理の本体が必要なので worker となる lib/info_sys.ex を実装します。これはバックエンドサービスが WolframAlpha 以外でも使えるように抽象化しておきます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 defmodule Rumbl.InfoSys do # デフォルトのバックエンドサービス @backends [ Rumbl.InfoSys.Wolfram ] defmodule Result do defstruct score : 0 , text : nil , url : nil , backend : nil end # バックエンドサービスのプロセスを開始する def start_link ( backend , query , query_ref , owner , limit ) do backend . start_link ( query , query_ref , owner , limit ) end def compute ( query , opts \\\\ []) do limit = opts [ :limit ] || 10 # 引数でバックエンドサービスが提示されてなければデフォルトを使う backends = opts [ :backends ] || @backends # 各バックエンドサービスに関してプロセスを開始する backends |> Enum . map ( & spawn_query ( &1 , query , limit ) end defp spawn_query ( backend , query , limit ) do query_ref = make_ref () opts = [ backend , query , query_ref , self (), limit ] # 起動済みのSupervisorに自分自身のプロセスを子として監視してもらう # これを呼び出すと自動でstart_linkが呼び出されてプロセス開始する { :ok , pid } = Supervisor . start_child ( Rumbl.InfoSys.Supervisor , opts ) { pid , query_ref } end end モジュールのアトリビュート（ @backends ）でバックエンドサービスを管理しています。 compute 関数を見てもらえればわかりますが、このアトリビュートに対して一つずつプロセスを起動しています。 戦略が :simple_one_for_one になっているので、子となるプロセスから Supervisor.start_child でプロセスを監視下に追加しています。 次に具体的なシステムを構築していきます。 Wolframを利用するアプリの構築 まず WolframAlpha を使うアプリを構築します。 mix.exs の deps に {:sweet_xml, \"~> 0.5.0\"}, を追加して mix deps.get を実行しておきます。 この追加したモジュールはXMLのパーサーです。 また、 ここから WolframAlpha のユーザ登録をしてAPIキーを取得します。ただし、当然ですがこのキーは dev.exs に直接書くのはNGです。 従って、 config/dev.secret.exs を用意して .gitignore に追加しておきます。 このファイルには WolframAlpha の設定を書いておきます。 1 2 3 use Mix.Config config :rumbl , :wolfram , app_id : \"XXXXXX-XXXXXXXXXX\" 最後に、元々の dev.exs に import_config \"dev.secret.exs\" を一行追加して準備完了です。 準備が終わったので lib/rumbl/info_sys/wolfram.ex を実装します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 defmodule Rumbl.InfoSys.Wolfram do import SweetXml alias Rumbl.InfoSys.Result def start_link ( query , query_ref , owner , limit ) do Task . start_link ( __MODULE__ , :fetch , [ query , query_ref , owner , limit ]) end def fetch ( query_str , query_ref , owner , _limit ) do query_str |> fetch_xml () |> xpath ( ~x\"/queryresult/pod[contains(@title, 'Result') or contains(@title, 'Definitions')] /subpod/plaintext/text()\" ) |> send_result ( query_ref , owner ) end defp send_result ( nil , query_ref , owner ) do send ( owner , { :results , query_ref , []}) end defp send_result ( answer , query_ref , owner ) do results = [% Result { backend : \"wolfram\" , score : 95 , text : to_string ( answer )}] send ( owner , { :results , query_ref , results }) end defp fetch_xml ( query_str ) do { :ok , { _ , _ , body }} = :httpc . request ( String . to_char_list ( \"http://api.wolframalpha.com/v2/query\" <> \"?appid= #{ app_id () } \" <> \"&input= #{ URI . encode ( query_str ) } &format=plaintext\" )) end defp app_id , do : Application . get_env ( :rumbl , :wolfram )[ :app_id ] end Task.start_link` でプロセスを起動しています。 ``Task は Agent と異なり、状態の保存ではなく、バックグラウンドでの関数起動に特化した OTP です。 API呼び出しをしている部分は fetch_xml/1 関数です。 Erlang の :httpc を使ってリクエストを投げているみたいです。 API呼び出しの結果を解析するのは SweetXml に含まれている xpath 関数です。自分も余り理解していないですが、 サンプル とか見るとなんとなくわかります。 xml のエレメントの queryresult/pod の属性 title が Result か Definitions の物の /subpod/plaintext/ の要素をテキストで取れという感じのようです。 最後に send_result をパターンマッチによって呼び出します。呼び出し元の PID に結果を送り返します。 動きを試すには iex -S mix から以下のコマンドで確かめられます。 1 2 3 4 5 6 7 8 9 10 11 12 iex> Rumbl.InfoSys.compute ( \"what is elixir?\" ) [{ #PID<0.566.0>, #Reference<0.0.3.1660>}] iex> flush () { :results, #Reference<0.0.3.1660>, [ %Rumbl.InfoSys.Result { backend: \"wolfram\" , score: 95 , text: \"1 | noun | a sweet flavored liquid (usually containing a small amount of alcohol) used in compounding medicines to be taken by mouth in order to mask an u npleasant taste\\n2 | noun | hypothetical substance that the alchemists believed to be capable of changing base metals into gold\\n3 | noun | a substance believed to cure all ills\" , url: nil }]} :ok 良さそうですが、このままだとプロセスが死んだときも待ち続けてしまいます。 また、機能強化としてスコア順での整列と、タイムアウト処理を入れる必要もあります。 InfoSysアプリの機能拡張 API問い合わせの結果の値の畳み込みとプロセスが死んだときの処理を追加します。 info_sys.ex を変更します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 defmodule Rumbl.InfoSys do ... def compute ( query , opts \\\\ []) do limit = opts [ :limit ] || 10 # 引数でバックエンドサービスが提示されてなければデフォルトを使う backends = opts [ :backends ] || @backends # 各バックエンドサービスに関してプロセスを開始する backends |> Enum . map ( & spawn_query ( &1 , query , limit )) |> await_result ( opts ) |> Enum . sort ( & ( &1 . score >= &2 . score )) |> Enum . take ( limit ) end defp spawn_query ( backend , query , limit ) do query_ref = make_ref () # 送り返される時に自分のPIDが必要なので第4引数はself() opts = [ backend , query , query_ref , self (), limit ] # 起動済みのSupervisorに自分自身のプロセスを子として監視してもらう # これを呼び出すと自動でstart_linkが呼び出されてプロセス開始する { :ok , pid } = Supervisor . start_child ( Rumbl.InfoSys.Supervisor , opts ) # プロセスの死活監視 monitor_ref = Process . monitor ( pid ) { pid , monitor_ref , query_ref } end defp await_result ( children , _opts ) do await_result ( children , [], :infinity ) end defp await_result ([ head | tail ], acc , timeout ) do { pid , monitor_ref , query_ref } = head # wolframなどでsendされた結果を待ち受けてパターンマッチする receive do { :results , &#94; query_ref , results } -> Process . demonitor ( monitor_ref , [ :flush ]) # 再帰でmapの結果を処理する await_result ( tail , results ++ acc , timeout ) { :DOWN , &#94; monitor_ref , :process , &#94; pid , _reason } -> # モニタリングの結果失敗していた時 await_result ( tail , acc , timeout ) end end defp await_result ([], acc , _ ) do # 最終的には結果を合体したものを返す acc end end await_result 関数の再帰によって receive 結果の畳み込みを実装しました。 また、 Process.monitor によってプロセスの監視を追加しています。 プロセスが死んでいた場合は receive のパターンマッチによって正しく処理することができるようになりました。 タイムアウトの追加 タイムアウトを追加しますが、 receive と after を使ってしまうとブロッキングが発生してしまいます。 3つシステムがあって5秒ずつタイムアウトすると15秒待つことになります。 これを避けるために違う方法を使います。 await_result 関数を以下のように変更します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 defmodule Rumbl.InfoSys do ... defp await_result ( children , opts ) do timeout = opts [ :timeout ] || 5000 # 非同期で起動して決められた時間のあとメッセージを送信してくる timer = Process . send_after ( self (), :timedout , timeout ) results = await_result ( children , [], :infinity ) # タイマー実験用 # :timer.sleep(5001) cleanup ( timer ) results end defp await_result ([ head | tail ], acc , timeout ) do { pid , monitor_ref , query_ref } = head # wolframなどでsendされた結果を待ち受けてパターンマッチする # メッセージが来るまで待ち続ける receive do { :results , &#94; query_ref , results } -> Process . demonitor ( monitor_ref , [ :flush ]) # 再帰でmapの結果を処理する await_result ( tail , results ++ acc , timeout ) { :DOWN , &#94; monitor_ref , :process , &#94; pid , _reason } -> # モニタリングの結果失敗していた時 await_result ( tail , acc , timeout ) # Process.send_afterによって送られるメッセージ :timedout -> kill ( pid , monitor_ref ) await_result ( tail , acc , 0 ) after timeout -> kill ( pid , monitor_ref ) # ひたすらここにはいることになるのでタイムアウト後は何もせずに終わる await_result ( tail , acc , 0 ) end end defp await_result ([], acc , _ ) do # 最終的には結果を合体したものを返す acc end defp kill ( pid , ref ) do Process . demonitor ( ref , [ :flush ]) Process . exit ( pid , :kill ) end defp cleanup ( timer ) do :erlang . cancel_timer ( timer ) receive do # ここでもタイムアウトメッセージが来る可能性があるため？ :timedout -> :ok after 0 -> :ok end end end Process.send_after を使って非同期タイムアウトを入れました。 設定された秒数立つとメッセージが送信されるのでそれを待ち受けるようにしました。 InfoSysアプリの組み込み 準備が整ったので InfoSys を Rumbl に組み込みます。 今まで作った OTP アプリを VideoChannel に組み込みます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 defmodule Rumbl.VideoChannel do ... # クライアントから直接送信された時に受け取るコールバック def handle_in ( \"new_annotation\" , params , user , socket ) do changeset = user |> build_assoc ( :annotations , video_id : socket . assigns . video_id ) |> Rumbl.Annotation . changeset ( params ) case Repo . insert ( changeset ) do { :ok , ann } -> # コメントを取り敢えず保存 broadcast_annotation ( socket , ann ) # コメントに対するInfoSysの結果を取得する(非同期) # 取得結果はwolframユーザのannotationとして保存される Task . start_link ( fn -> compute_additional_info ( ann , socket ) end ) { :reply , :ok , socket } { :error , changeset } -> { :reply , { :error , %{ errors : changeset }}, socket } end end defp compute_additional_info ( ann , socket ) do # computeには結果をスコア順で先頭一つだけ取るように指示 # googleとかの結果もほしいならlimit2とかにすれば良いはず # 結果は要らないのでリスト内包表記の結果は呼び出し元でも受け取っていない for result <- Rumbl.InfoSys . compute ( ann . body , limit : 1 , timeout : 10_000 ) do attrs = %{ url : result . url , body : result . text , at : ann . at } info_changeset = Repo . get_by! ( Rumbl.User , username : result . backend ) # ユーザを取得 |> build_assoc ( :annotations , video_id : ann . video_id ) # ユーザに紐づくannotationを作成 |> Rumbl.Annotation . changeset ( attrs ) # annotationのchangesetを作成 case Repo . insert ( info_changeset ) do # インサート出来たらInfoSysの結果を共通関数でブロードキャストする { :ok , info_ann } -> broadcast_annotation ( socket , info_ann ) { :error , _changeset } -> :ignore end end end defp broadcast_annotation ( socket , annotation ) do annotation = Repo . preload ( annotation , :user ) rendered_ann = Phoenix.View . render ( AnnotationView , \"annotation.json\" , %{ annotation : annotation }) broadcast! socket , \"new_annotation\" , rendered_ann end end ほとんどコメントのままですが、 Task.start_link を使って他の処理をブロッキングしないように、 InfoSys.compute を呼び出しています。 compute_additional_info を見てもらうとわかるように result.backend がユーザとして存在することが 前提となっているので seed で追加します。 backend_seeds.exs を以下のように実装します。 1 2 3 4 alias Rumbl.Repo alias Rumbl.User Repo . insert! (% User { name : \"Wolfram\" , username : \"wolfram\" }) これでいつものようにスクリプトを実行すれば組み込みは完成です。 まとめ simple_one_for_one を使ったときは Supervisor.start_child を使って子側からリンクする Task.start_link で非同期で関数実行を行う。 Agent と異なり単なる結果を返す関数を実行する OTP タイムアウト処理は Process.send_after で行い、 receive で受け取る 色々でてきて処理を追うのが大変でした。 IO.inspect とかでメッセージの表示順とかを見ると分かりやすいかもしれません。","tags":"programming","url":"posts/2017/02/09/programming-phoenix18/"},{"title":"Programming Phoenix勉強その17","text":"その17です。ここから chapter11 です。 OTP で簡単なアプリを作ります。次の章にそれをアンブレラプロジェクトの下に置きます。 Counterアプリの作成 はじめに素朴な send と receive を使ったカウンターアプリを作ります。 lib/rumbl/counter.ex を実装します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 defmodule Rumbl.Counter do # listenにメッセージを送信する def inc ( pid ), do : send ( pid , :inc ) def dec ( pid ), do : send ( pid , :dec ) # listenで保持されている状態を取得する def val ( pid , timeout \\\\ 5000 ) do # プロセスにリファレンスという形でマークを付ける # リクエストに対してレスポンスを紐付ける同期処理 ref = make_ref () send ( pid , { :val , self (), ref }) receive do { &#94; ref , val } -> val after timeout -> exit ( :timeout ) end end # エントリポイント def start_link ( initial_val ) do { :ok , spawn_link ( fn -> listen ( initial_val ) end )} end # 無限ループでval状態を保持する defp listen ( val ) do receive do :inc -> listen ( val + 1 ) :dec -> listen ( val - 1 ) { :val , sender , ref } -> send sender , { ref , val } listen ( val ) end end end 以下で動作を確かめられます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 iex> { :ok, pid } = Counter.start_link ( 0 ) { :ok, #PID<0.259.0>} iex> pid #PID<0.259.0> iex> Counter.inc ( pid ) :inc iex> Counter.val ( pid ) 1 iex> Counter.dec ( pid ) :dec iex> Counter.dec ( pid ) :dec iex> Counter.val ( pid ) -1 start_link 関数でプロセスを開始します。これは listen 関数の再帰呼び出しによって無限ループになっています。 listen 関数によって保存される状態はPIDによって識別されるため inc 関数や dec 、 val 関数 にそのPIDを与えています。 次に素朴な非同期通信から OTP の GenServer を使ってみます。 CounterアプリのOTP化 Counter を OTP を使ったものにしてみます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 defmodule Rumbl.Counter do use GenServer # listenにメッセージを送信する def inc ( pid ), do : GenServer . cast ( pid , :inc ) def dec ( pid ), do : GenServer . cast ( pid , :dec ) def val ( pid ) do # 値が返ってくるのを待つ必要があるため同期呼び出し GenServer . call ( pid , :val ) end def start_link ( initial_val ) do GenServer . start_link ( __MODULE__ , initial_val ) end def init ( initial_val ) do { :ok , initial_val } end def handle_cast ( :inc , val ) do { :noreply , val + 1 } end def handle_cast ( :dec , val ) do { :noreply , val - 1 } end def handle_call ( :val , _from , val ) do { :reply , val , val } end end GenServer を使ったものに変更しました。大分すっきりしました。 同期処理の handle_call は値を返すことを期待するため {:reply, val, val} を返しています。 非同期処理の handle_cast は値を返さない非同期処理なので {:noreply, val ± 1} としています。 また、 OTP 化しましたので元の Rumbl アプリに組み込んでみます。 lib/rumbl.ex をちょっと変更します。 1 2 3 4 5 6 7 8 children = [ # Start the Ecto repository supervisor ( Rumbl.Repo , []), # Start the endpoint when the application starts supervisor ( Rumbl.Endpoint , []), # Start your own worker by calling: Rumbl.Worker.start_link(arg1, arg2, arg3) worker ( Rumbl.Counter , [ 5 ]), # 追加 ] Rumbl アプリ起動時にワーカーとして Counter を起動するように追加しました。 ワーカーとして追加することで start_link が自動で呼び出され、第二引数のものを引数として起動します。 クラッシュ時の動作 せっかく Supervisor Tree に Counter を追加してみたので、クラッシュさせたときの動作も見てみます。 counter.ex をクラッシュさせるようにしてみます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def init ( initial_val ) do # :tickメッセージを1000ミリ秒後に自分自身に送信 Process . send_after ( self (), :tick , 1000 ) { :ok , initial_val } end # valが0以下になったらわざとクラッシュさせる def handle_info ( :tick , val ) when val <= 0 , do : raise \"boom!\" # send_afterで自分自身に送られたものを受け取る def handle_info ( :tick , val ) do IO . puts \"tick #{ val } \" Process . send_after ( self (), :tick , 1000 ) { :noreply , val - 1 } end 以下のような表示がコンソールにされます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 iex> tick 5 iex> tick 4 iex> tick 3 iex> tick 2 iex> tick 1 iex> [ error ] GenServer #PID<0.348.0> terminating ** ( RuntimeError ) boom! ( rumbl ) lib/rumbl/counter.ex:38: Rumbl.Counter.handle_info/2 ( stdlib ) gen_server.erl:615: :gen_server.try_dispatch/4 ( stdlib ) gen_server.erl:681: :gen_server.handle_msg/5 ( stdlib ) proc_lib.erl:240: :proc_lib.init_p_do_apply/3 Last message: :tick State: 0 iex> tick 5 デクリメントされ0以下になったときにプロセスがクラッシュしていることがわかります。 さらに、自動で与えていた初期値で再起動しています。 クラッシュ時の各戦略について worker の再起動戦略は以下の設定が可能です。 worker の第三引数として restart: :permanent のような形式で指定します。 :permanent : デフォルトの戦略。上記のような挙動をする。 :temporary : クラッシュ時に再起動しない。 :transient : 正常終了以外でプロセスが終了した時に再起動を行う。 また、 supervisor の監視戦略は以下のようなものがあります。 :one_for_one : 子プロセスがクラッシュすると Supervisor はそのプロセスだけを再起動する。 :one_for_all : 子プロセス全てを終了して再起動する。 :rest_for_one : 終了した子プロセスにつながるプロセスのみ全て終了後再起動する。 :simple_one_for_one : 基本的には :one_for_one だが、プロセスを動的に監視する必要がある場合に使う。 Supervisor に一つの子のみ定義する必要がある。 Agentについて 今まで書いてきた GenServer は Agent を使うともっと短く書けます。コンソールで試してみます。 1 2 3 4 5 6 7 8 9 10 11 12 iex ( 1 ) > import Agent Agent iex ( 2 ) > { :ok, agent } = start_link fn -> 5 end, name: MyAgent { :ok, #PID<0.351.0>} iex ( 3 ) > update MyAgent, & ( & 1 + 1 ) :ok iex ( 4 ) > update MyAgent, & ( & 1 + 1 ) :ok iex ( 5 ) > get MyAgent, & ( & 1 ) 7 iex ( 6 ) > stop MyAgent :ok また、 OTP は start_link で開始時に :name オプションでプロセスにPID以外の名前をつけることが出来ます。 update 関数で状態を変更出来、 get 関数で状態を取得できます。 見てわかるように Agent は状態の保持に特化したものです。実際には中身で GenServer が呼ばれるようです。 このように GenServer 上の構成物になっているものの中の一つとして Phoenix.Channel があります。 まとめ プロセスを起動するには GenServer を使う。 プロセスの戦略は worker 自身の設定と children に対する supervisor の監視戦略で行う。 Agent は GenServer の状態管理特化の抽象化。 Phoenix.Channel も Agent 同様に GenServer の抽象化。","tags":"programming","url":"posts/2017/02/06/programming-phoenix17/"},{"title":"Programming Phoenix勉強その16","text":"その16です。 Channel の続きからですが、コメント管理するモデルの作成からです。 モデルの作成 いつものコマンドからモデルを作成&マイグレーションします。 1 2 rumbl $ mix phoenix.gen.model Annotation annotations body:text at:integer user_id:references:users video_id:references:videos rumbl $ mix ecto.migrate 完了したら user.ex と video.ex に has_many :annotations, Rumbl.Annotation を追加しておきます。 作成したらモデルを使うようにしてやります。 video_channel.ex を以下のように変更します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 defmodule Rumbl.VideoChannel do use Rumbl.Web , :channel def join ( \"videos:\" <> video_id , _params , socket ) do { :ok , assign ( socket , :video_id , String . to_integer ( video_id ))} end # 最初に入ってきてuserを取得後各関数に処理をディスパッチする def handle_in ( event , params , socket ) do user = Repo . get ( Rumbl.User , socket . assigns . user_id ) handle_in ( event , params , user , socket ) end def handle_in ( \"new_annotation\" , params , user , socket ) do changeset = user |> build_assoc ( :annotations , video_id : socket . assigns . video_id ) |> Rumbl.Annotation . changeset ( params ) case Repo . insert ( changeset ) do { :ok , annotation } -> # 接続しているクライアント全てにブロードキャストする # ユーザが任意のメッセージを送れないようにparamsを分解する broadcast! socket , \"new_annotation\" , %{ id : annotation . id , user : Rumbl.UserView . render ( \"user.json\" , %{ user : user }), body : annotation . body , at : annotation . at } { :reply , :ok , socket } { :error , changeset } -> { :reply , { :error , %{ errors : changeset }}, socket } end end end handle_in/3 関数と handle_in/4 関数を追加しました。 user を必ず取得してから次の処理に移行するように しています。 この中で UserVide.render 関数を使っているのでそちらも user_view.ex に実装します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 defmodule Rumbl.UserView do use Rumbl.Web , :view alias Rumbl.User def first_name (% User { name : name }) do name |> String . split ( \" \" ) |> Enum . at ( 0 ) end def render ( \"user.json\" , %{ user : user }) do %{ id : user . id , username : user . username } end end render 関数を追加しました。普通の render 関数は第一引数にテンプレート名を受けますが、 jsonを受けるようにして作りました。 コメントの時系列順表示 annotation の永続化は行ったので、以下を行います。 永続化されたコメントを取り出して表示する処理 クリックしたときに投稿した時間に動画を飛ばす処理 video_channel.ex の join 関数を以下のように変更します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 alias Rumbl.AnnotationView def join ( \"videos:\" <> video_id , _params , socket ) do video_id = String . to_integer ( video_id ) video = Repo . get! ( Rumbl.Video , video_id ) annotations = Repo . all ( # videoに紐づくannotationsを取得 from a in assoc ( video , :annotations ), order_by : [ asc : a . at , asc : a . id ], limit : 200 , preload : [ :user ] ) resp = %{ annotations : Phoenix.View . render_many ( annotations , AnnotationView , \"annotation.json\" )} # socket.assignsにvideo_idを保存 { :ok , resp , assign ( socket , :video_id , video_id )} end 接続直後にその video に関連する annotation を取得して送信しています。 Rumbl.AnnotationView を使っているのでこれも実装します。 1 2 3 4 5 6 7 8 9 10 11 12 defmodule Rumbl.AnnotationView do use Rumbl.Web , :view def render ( \"annotation.json\" , %{ annotation : ann }) do %{ id : ann . id , body : ann . body , at : ann . at , user : render_one ( ann . user , Rumbl.UserView , \"user.json\" ) } end end render_many や render_one 見たいな関数は 公式ドキュメント を参考にすればわかると思います。 これに伴い、 join した時のクライアントサイドコードも変更しておく必要があります。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 import Player from \"./player\" let Video = { ... onReady ( videoId , socket ) { let msgContainer = document . getElementById ( \"msg-container\" ); let msgInput = document . getElementById ( \"msg-input\" ); let postButton = document . getElementById ( \"msg-submit\" ); // トピックの識別 let vidChannel = socket . channel ( \"videos:\" + videoId ); postButton . addEventListener ( \"click\" , e => { let payload = { body : msgInput . value , at : Player . getCurrentTime () }; vidChannel . push ( \"new_annotation\" , payload ) . receive ( \"error\" , e => console . log ( e )); msgInput . value = \"\" ; }); // サーバーからのプッシュイベントを受け取るイベントハンドラを設定 vidChannel . on ( \"new_annotation\" , ( resp ) => { this . renderAnnotation ( msgContainer , resp ); }); msgContainer . addEventListener ( \"click\" , e => { e . preventDefault (); let seconds = e . target . getAttribute ( \"data-seek\" ) || e . target . parentNode . getAttribute ( \"data-seek\" ); if ( ! seconds ) { return ; } Player . seekTo ( seconds ); }); // チャンネルへのjoin receiveで帰ってきたものを受け取る(OTPっぽい) vidChannel . join () . receive ( \"ok\" , resp => { this . scheduleMessages ( msgContainer , resp . annotations ) }) . receive ( \"error\" , reason => console . log ( \"join failed\" , reason )); }, esc ( str ) { let div = document . createElement ( \"div\" ); div . appendChild ( document . createTextNode ( str )); return div . innerHTML ; }, renderAnnotation ( msgContainer , { user , body , at }) { let template = document . createElement ( \"div\" ); template . innerHTML = ` <a href=\"#\" data-seek=\" ${ this . esc ( at ) } \"> [ ${ this . formatTime ( at ) } ] <b> ${ this . esc ( user . username ) } </b>: ${ this . esc ( body ) } </a> ` ; msgContainer . appendChild ( template ); msgContainer . scrollTop = msgContainer . scrollHeight ; }, scheduleMessages ( msgContainer , annotations ) { setTimeout (() => { let ctime = Player . getCurrentTime (); let remaining = this . renderAtTime ( annotations , ctime , msgContainer ); this . scheduleMessages ( msgContainer , remaining ); }, 1000 ); }, renderAtTime ( annotations , seconds , msgContainer ) { return annotations . filter ( ann => { if ( ann . at > seconds ) { // コメントした時間以降で無ければ表示しない return true ; } else { // 表示してリストから除外する this . renderAnnotation ( msgContainer , ann ); return false ; } }); }, formatTime ( at ) { let date = new Date ( null ); date . setSeconds ( at / 1000 ); return date . toISOString (). substr ( 14 , 5 ); } } export default Video ; 何かいっぱい追加しましたが、大したことはしていないです。 join 時にリストで受け取るコメント一覧を保持 renderAtTime 関数で投稿時間を過ぎていたらレンダリングする コメントをクリックしたら時間のところに動画をシークするイベント追加 こんなところでしょうか。 切断処理の実装 切断処理を適切にハンドリングするようにします。 現状では切断後そのまま再接続すると同じコメントがかぶってしまったりするケースがあります。 これを回避するために最後に参照した annotation のidを保持しておいて、再接続後はそれ以降のものを取得するようにします。 はじめにクライアント側で最後に取得したコメントのIDを保持するように変更します。 video.js を修正します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ... // サーバーからのプッシュイベントを受け取るイベントハンドラを設定 vidChannel . on ( \"new_annotation\" , ( resp ) => { // 投稿したものが最新のIDなので保持する vidChannel . params . last_seen_id = resp . id ; this . renderAnnotation ( msgContainer , resp ); }); ... // チャンネルへのjoin receiveで帰ってきたものを受け取る(OTPっぽい) vidChannel . join () . receive ( \"ok\" , resp => { let ids = resp . annotations . map ( ann => ann . id ); if ( ids . length > 0 ) { // 再生したコメントの最後のものを取得 vidChannel . params . last_seen_id = Math . max (... ids ); } console . log ( vidChannel . params . last_seen_id ); this . scheduleMessages ( msgContainer , resp . annotations ) }) . receive ( \"error\" , reason => console . log ( \"join failed\" , reason )); 最後に取得したコメントIDを last_seen_id を params のパラメータとして保持します。 vidChannel.params は最初から用意されており、自動でサーバー側にも送信されるパラメータです。 last_seen_id を使うように video_channel.ex の join 関数を変更します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def join ( \"videos:\" <> video_id , params , socket ) do last_seen_id = params [ \"last_seen_id\" ] || 0 video_id = String . to_integer ( video_id ) video = Repo . get! ( Rumbl.Video , video_id ) annotations = Repo . all ( # videoに紐づくannotationsを取得 from a in assoc ( video , :annotations ), where : a . id > &#94; last_seen_id , order_by : [ asc : a . at , asc : a . id ], limit : 200 , preload : [ :user ] ) resp = %{ annotations : Phoenix.View . render_many ( annotations , AnnotationView , \"annotation.json\" )} { :ok , resp , assign ( socket , :video_id , video_id )} end join 関数内では、 params を引数で受け取り Map などのように使えます。 但し、パラメータが渡されていない場合は nil になるのでチェックを掛けています。 これで切断後の再接続用処理が実装出来ました。 まとめ サーバー側とクライアント側で任意のパラメータを共有するときは params を使う 何か新しいことがあったというよりは今まで習ったものを JavaScript とか Elixir から上手いこと使う感じでした。","tags":"programming","url":"posts/2017/02/04/programming-phoenix16/"},{"title":"Programming Phoenix勉強その15","text":"その15です。ここからChapter10の Channel です。Phoenixの目玉機能の一つな気もするので楽しみです。 Channelについて ステートを持つ双方向通信である ステートフルなので Cookie などを意識しなくて良い トピックと呼ばれる単位で各会話は管理される 各々の会話はプロセスで管理され、一つがバグっても他に影響を与えないし、並列性も持つ クライアント側はES6(ES2015)で記述する 実装するにあたりクライアントとサーバーで以下3つを意識する 接続と切断 メッセージの送信 メッセージの受信 クライアントサイドの実装 というわけで、ES6でクライアントサイドから実装していきます。まず video.js を作成します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import Player from \"./player\" let Video = { init ( socket , element ) { if ( ! element ) { return ; } let playerId = element . getAttribute ( \"data-player-id\" ); let videoId = element . getAttribute ( \"data-id\" ); socket . connect () Player . init ( element . id , playerId , () => { this . onReady ( videoId , socket ); }); }, onReady ( videoId , socket ) { let msgContainer = document . getElementById ( \"msg-container\" ); let msgInput = document . getElementById ( \"msg-input\" ); let postButton = document . getElementById ( \"msg-submit\" ); // トピックの識別 let voidChannel = socket . channel ( \"videos:\" + videoId ); // TODO: join the vidChannel } } export default Video ; player の import をこっちに移設しています。また、 init メソッドと onReady メソッドを定義しています。 onReady はコールバックとして使っているようです。 コメントにあるようにトピックの識別子は videoId としています。 app.js を上の実装に合わせて変えておきます。 Player を作成していた部分に変わって Video の利用にします。 1 2 3 import socket from \"./socket\" ; import Video from \"./video\" ; Video . init ( socket , document . getElementById ( \"video\" )); デフォルトで用意されている socket.js のインポートも行っています。 このファイルについては後で触るようです。 通常のリクエストと socket のデータの流れの違いについても触れられています。 前の章で見たように通常のアクセスではデータは conn という形で各パイプラインを流れて、 その中で変換されていきます。 conn は新しい接続ごとに新しいものが作られて使われます。 一方 socket の方ではステートフルなためソケットの寿命まで一つの接続が変換され続けます。 socket.jsの変更 最初のソケットを作成します。 socket.js の中身を変更して実装していきます。 1 2 3 4 5 6 7 8 9 import { Socket } from \"phoenix\" let socket = new Socket ( \"/socket\" , { params : { token : window . userToken }, // バッククオートで囲んだものがテンプレートリテラルとして値を文字に埋め込める logger : ( kind , msg , data ) => { console . log ( ` ${ kind } : ${ msg } ` , data ); } }); export default socket 余計な部分を消してしまって問題ないです。ログをコンソールに出すように変更しただけです。 Phoenix 側でのソケットのエンドポイントは endpoint.ex に記述されています。 1 socket \"/socket\" , Rumbl.UserSocket サーバーサイドの実装 Rumbl.UserSocket がエントリポイントになっていることがわかったので中身を見てみます。 channel/user_socket.ex です。 1 2 3 4 5 6 7 8 9 10 11 12 defmodule Rumbl.UserSocket do use Phoenix.Socket transport :websocket , Phoenix.Transports.WebSocket # transport :longpoll, Phoenix.Transports.LongPoll def connect ( _params , socket ) do { :ok , socket } end def id ( _socket ), do : nil end 余計なコメントは消してます。 transport のところをコメントと合わせて見るとわかるように、二種類サポートされているようです。 通常の websocket と longpoll のロングポーリングです。 これは接続方法が抽象化され、他の部分の処理は同じで良いということです。 connect/2 関数はユーザの接続制御に用いられる。現在は全てのユーザが接続可能。認証は後で追加するらしい。 id/1 関数はソケットの識別を行っています。 nil なので全ユーザが匿名です。 実際に実装していきます。まず user_socket.ex に以下を追加します。 1 2 ## Channels channel \"videos:*\" , Rumbl.VideoChannel Phoenix ではトピックはリソース名（ :videos とか）でサブトピックは付随するIDになるようです。 上記に書いた通り、 VideoChannel にディスパッチしているのでこれを実装していきます。 channels/video_channel.ex を実装します。 1 2 3 4 5 6 7 defmodule Rumbl.VideoChannel do use Rumbl.Web , :channel def join ( \"videos:\" <> video_id , _params , socket ) do { :ok , assign ( socket , :video_id , String . to_integer ( video_id ))} end end join/3 コールバック関数を作りました。（コールバックという呼び方はOTPに習っているようです。） 引数に与えられている socket は接続されている間状態を保持します。 なので、 assign などでデータを追加するとそれもずっと保持されて参照可能です。 クライアント側でも join 出来るようにします。 video.js を変更します。 1 2 3 4 5 6 7 8 9 10 11 onReady ( videoId , socket ) { let msgContainer = document . getElementById ( \"msg-container\" ); let msgInput = document . getElementById ( \"msg-input\" ); let postButton = document . getElementById ( \"msg-submit\" ); // トピックの識別 let vidChannel = socket . channel ( \"videos:\" + videoId ); // チャンネルへのjoin receiveで帰ってきたものを受け取る(OTPっぽい) vidChannel . join () . receive ( \"ok\" , resp => console . log ( \"joined the video channel\" , resp )) . receive ( \"error\" , reason => console . log ( \"join failed\" , reason )); } 抜粋しました。クライアントサイドでサーバーサイドの関数呼んでるような見た目です。 また、 receive はOTPでよく出てくるメッセージを受信するやつと同じっぽい感じで使っているみたいです。 次に、試しに5秒毎にクライアントに通知を投げる処理を追加してみます。 video_channel.ex を以下のように実装します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 defmodule Rumbl.VideoChannel do use Rumbl.Web , :channel def join ( \"videos:\" <> video_id , _params , socket ) do # 5秒ごとにクライアントにメッセージを送る # send_interval/2関数は最終的にはsend_interval(Time, self(), Message)という形で呼び出される :timer . send_interval ( 5_000 , :ping ) # socket.assignsにvideo_idを保存 { :ok , assign ( socket , :video_id , String . to_integer ( video_id ))} end # OTPのコールバックhandle_castやhandle_callの仲間 # castやcallで処理される以外のメッセージを処理するらしい def handle_info ( :ping , socket ) do count = socket . assigns [ :count ] || 1 push socket , \"ping\" , %{ count : count } { :noreply , assign ( socket , :count , count + 1 )} end end コメントに書いてあるように、 join されると5秒ごとに自分自身にメッセージを投げて handle_info コールバックで受け取っています。 handle_info では socket に追加された count をインクリメントしていっているだけです。 push されるとクライアント側に通知が行くようです。 リアルタイムアノテーションの実装 基本的なところはわかったので動画にリアルタイムコメントを付けられるようにします。 ちなみに ここ によるとYouTubeの動画へのコメントとかをアノテーションって呼ぶときもあるらしいですよ。 video.js を変更します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 onReady ( videoId , socket ) { let msgContainer = document . getElementById ( \"msg-container\" ); let msgInput = document . getElementById ( \"msg-input\" ); let postButton = document . getElementById ( \"msg-submit\" ); // トピックの識別 let vidChannel = socket . channel ( \"videos:\" + videoId ); postButton . addEventListener ( \"click\" , e => { let payload = { body : msgInput . value , at : Player . getCurrentTime () }; vidChannel . push ( \"new_annotation\" , payload ) . receive ( \"error\" , e => console . log ( e )); msgInput . value = \"\" ; }); // サーバーからのプッシュイベントを受け取るイベントハンドラを設定 vidChannel . on ( \"new_annotation\" , ( resp ) => { this . renderAnnotation ( msgContainer , resp ); }); // チャンネルへのjoin receiveで帰ってきたものを受け取る(OTPっぽい) vidChannel . join () . receive ( \"ok\" , resp => console . log ( \"joined the video channel\" , resp )) . receive ( \"error\" , reason => console . log ( \"join failed\" , reason )); }, esc ( str ) { let div = document . createElement ( \"div\" ); div . appendChild ( document . createTextNode ( str )); return div . innerHTML ; }, renderAnnotation ( msgContainer , { user , body , at }) { let template = document . createElement ( \"div\" ); template . innerHTML = ` <a href=\"#\" data-seek=\" ${ this . esc ( at ) } \"> <b> ${ this . esc ( user . username ) } </b>: ${ this . esc ( body ) } </a> ` ; msgContainer . appendChild ( template ); msgContainer . scrollTop = msgContainer . scrollHeight ; } } サーバーからのプッシュイベントを受け取る用に設定したのと、受け取った物をレンダリングする関数を作成しました。 また、 esc 関数でXSS対策を行っています。 count のやり取りからコメントのやり取りに変更したのでサーバー側も合わせて変更します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 defmodule Rumbl.VideoChannel do use Rumbl.Web , :channel def join ( \"videos:\" <> video_id , _params , socket ) do { :ok , socket } end # クライアントから直接送信された時に受け取るコールバック def handle_in ( \"new_annotation\" , params , socket ) do # 接続しているクライアント全てにブロードキャストする # ユーザが任意のメッセージを送れないようにparamsを分解する broadcast! socket , \"new_annotation\" , %{ user : %{ username : \"anon\" }, body : params [ \"body\" ], at : params [ \"at\" ] } { :reply , :ok , socket } end end join 関数をもとに戻したのと handle_in/3 関数を新たに追加しました。 handle_in では Map.put とかでメッセージを作っていないのはセキュリティ対策のようです。 メッセージはユーザから任意で入力されるので params をバラして好き勝手入れられない様にしています。 認証の追加 誰が送ったメッセージか知りたいので認証を行います。 普通のアプリケーションはセッションでの認証が主ですが、 websocket では接続が長く続くため、 トークン認証で行います。まずテンプレートにトークンを埋め込みます。 1 2 3 4 5 6 ... </div> <!-- /container --> <!-- websocket用ユーザトークンの埋め込み Rumbl.Authでの認証が通っていることが条件 --> <script>window.userToken = \" <%= assigns [ :user_token ] %> \"</script> <script src=\" <%= static_path ( @conn , \"/js/app.js\" ) %> \"></script> ... user_token を assign するように auth.ex を変更します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 defmodule Rumbl.Auth do ... def call ( conn , repo ) do user_id = get_session ( conn , :user_id ) cond do user = conn . assigns [ :current_user ] -> put_current_user ( conn , user ) # 変更 user = user_id && repo . get ( Rumbl.User , user_id ) -> put_current_user ( conn , user ) # 変更 true -> assign ( conn , :current_user , nil ) end end def login ( conn , user ) do conn |> put_current_user ( user ) # 変更 |> put_session ( :user_id , user . id ) |> configure_session ( renew : true ) end ... # 追加 defp put_current_user ( conn , user ) do # 第二引数はsalt token = Phoenix.Token . sign ( conn , \"user socket\" , user . id ) conn |> assign ( :current_user , user ) |> assign ( :user_token , token ) # トークンを突っ込んでapp.html.eexより使う end end 特に不思議なところはなくて、 Phoenix.Token.sign を使ってトークンを作っているだけです。 user_socket.ex を変更してセッションに割り当てられた :user_token から user_id を判別し、 socket に割り当てるようにします。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ... # 2週間有効 @max_age 2 * 7 * 24 * 60 * 60 def connect (%{ \"token\" => token }, socket ) do # 第二引数はsalt case Phoenix.Token . verify ( socket , \"user socket\" , token , max_age : @max_age ) do { :ok , user_id } -> { :ok , assign ( socket , :user_id , user_id )} { :error , _reason } -> :error end end def connect ( _params , _socket ), do : :error def id ( socket ), do : \"user_socket: #{ socket . assigns . user_id } \" end これも余り不思議なところはなくて、 Phoenix.Token.verify を使ってトークンから user_id を取っているだけです。 これでログインしていなければコメントが投稿できなくなりました。 まとめ Channel はサーバーとクライアントの双方向リアルタイム通信を行う。 Channel はOTPの上に成り立っていて、コールバック関数などもそれに従っている。 Phoenix には最初からクライアント側の weboscket 用ライブラリも用意されている。 接続が長期間続くため、認証はトークンを利用して行う。 websocket その1でした。今まで余りやったことがないことをしている感があって面白いです。 次は投稿されたコメントの永続化からです。","tags":"programming","url":"posts/2017/02/03/programming-phoenix15/"},{"title":"Programming Phoenix勉強その14","text":"その14です。その13の続きです。追加した Slug をURLに使ってアクセスできるようにします。 URLのカスタマイズ URLを単なるID指定から id + 先程作成した slug でアクセスできるようにします。 Phoenix.Param を impl することでカスタマイズ可能です。 1 2 3 4 5 defimpl Phoenix.Param , for : Rumbl.Video do def to_param (%{ slug : slug , id : id }) do \" #{ id } - #{ slug } \" end end 公式ドキュメント を見ると単なる impl なら @derive {Phoenix.Param, key: :username} で行けるようです。 今回は \"#{id}-#{slug}\" などのちょっとカスタムされたURLでアクセスしたいので直接実装してます。（ derive で実装できる方法はあるのだろうか・・・） IEX で上記で作成したものを試してみます。 1 2 3 iex> video = %Rumbl.Video { id: 1 , slug: \"hello\" } iex> Rumbl.Router.Helpers.watch_path ( %URI {} , :show, video ) \"/watch/1-hello\" watch_path/3 の第一引数が %URI{} となっています。すべてのヘルパーはこのURI構造体を第一引数を取るらしいです。 URI構造体を使ってちょっと遊んでみます。 1 2 3 4 5 iex> url = URI.parse ( \"http://example.com/prefix\" ) %URI { authority: \"example.com\" , fragment: nil, host: \"example.com\" , path: \"/prefix\" , port: 80 , query: nil, scheme: \"http\" , userinfo: nil } iex ( 6 ) > Rumbl.Router.Helpers.watch_url ( url, :show, video ) \"http://example.com/prefix/watch/1-hello\" 第一引数に与えたURLに続くパスとしてパスを構築してくれていることがわかります。じゃあ今使っている localhost のURLはどうなってんだという疑問がわきます。 以下を試してみます。 1 2 3 4 5 iex> url = Rumbl.Endpoint.struct_url %URI { authority: nil, fragment: nil, host: \"localhost\" , path: nil, port: 4000 , query: nil, scheme: \"http\" , userinfo: nil } iex ( 8 ) > Rumbl.Router.Helpers.watch_url ( url, :show, video ) \"http://localhost:4000/watch/1-hello\" どうやら内部的には struct_url で全体のURLが構築されているらしいことがわかります。また、 url というAPIもあるようです。 こちらは文字列でURL全体を返してくれます。 ここまでやって、ウォッチページにとぼうとするとエラーになります。 watch_controller の :show アクションではURLパラメータとして :id を期待しているのに 1-hello のようなパラメータが来ているためです。これからこの点を修正します。 リンクの修正 上記の問題を解決するためにリンクを修正します。 lib/rumbl/permalink.ex を実装します。 ちなみに lib フォルダと web フォルダの違いはコードリロードが走るかどうかの違いのようです。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 defmodule Rumbl.Permalink do # cast,dump,load,typeの実装を要求するbehaviour @behaviour Ecto.Type def type , do : :id # changesetのcast関数が呼び出される時とかクエリを構築する時とかに使われる # 文字列の場合 def cast ( binary ) when is_binary ( binary ) do case Integer . parse ( binary ) do { int , _ } when int > 0 -> { :ok , int } _ -> :error end end def cast ( integer ) when is_integer ( integer ) do { :ok , integer } end def cast ( _ ) do :error end # データがデータベースに送信される時に呼び出される def dump ( integer ) when is_integer ( integer ) do { :ok , integer } end # データがデータベースからロードされる時に呼び出される def load ( integer ) when is_integer ( integer ) do { :ok , integer } end end データが呼び出されたり、突っ込まれたりするときの動作を記述しています。 今回関係があるのは一つ目の cast/1 関数で、文字列を binary として受け取り、先頭の数字とそれ以外でパースしている部分です。 この処理により、 3-hello のようなパラメータも受取が可能になります。 上記作ったものを利用できるように video.ex を編集します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 defmodule Rumbl.Video do use Rumbl.Web , :model # idフィールドのカスタマイズ 第二要素は型らしい @primary_key { :id , Rumbl.Permalink , autogenerate : true } schema \"videos\" do field :url , :string field :title , :string field :description , :string field :slug , :string belongs_to :user , Rumbl.User belongs_to :category , Rumbl.Category timestamps () end ... @praimary_key アトリビュートを使ってプライマリーキーをカスタマイズしています。 :id 以外をキーとしたい場合も似たような感じで書けば出来るようです。 ここまでやればビデオ閲覧画面は完成です。 まとめ Phoenix.Param を impl することでURLパラメータがカスタマイズ出来る。 @primary_key でプライマリーキーをカスタマイズ出来る。 ちょっと短かったです・・・バランスが難しい。 @primary_key の2個目の要素の型指定とかまだちょっと疑問が残るので追々調べてみようと思います。","tags":"programming","url":"posts/2017/01/31/programming-phoenix14/"},{"title":"Programming Phoenix勉強その13","text":"その13です。ここからPart2です。ここから機能をちゃんと整備します。 ビデオに対してリアルタイムコメントを付けられるように ビデオを再生可能に をやっていくようです。はじめにビデオを再生可能にしていきます。 視聴用ページ作成 投稿されたビデオを見るためのページを作ります。いつものを作るのでソースのみ提示します。 app.html.eex に投稿一覧表示用メニューを付けます。 1 2 3 4 5 6 7 8 9 10 11 ... <body> <div class=\"container\"> <header class=\"header\"> <ol class=\"breadcrumb text-right\"> <!-- assignsで突っ込んだものが使えている --> <%= if @current_user do %> <li> <%= @current_user . username %> </li> <li> <%= link \"My Videos\" , to : video_path ( @conn , :index ) %> </li> <li> ... watch_controller.ex を作成します。 1 2 3 4 5 6 7 8 9 defmodule Rumbl.WatchController do use Rumbl.Web , :controller alias Rumbl.Video def show ( conn , %{ \"id\" => id }) do video = Repo . get! ( Video , id ) render conn , \"show.html\" , video : video end end wathc/show.html.eex を作成します。コメント入力欄がある唯のページです。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 <h2> <%= @video . title %> </h2> <div class=\"row\"> <div class=\"col-sm-7\"> <%= content_tag :div , id : \"video\" , data : [ id : @video . id , player_id : player_id ( @video ) ] do %> <% end %> </div> <div class=\"col-sm-5\"> <div class=\"panel panel-default\"> <div class=\"panel-heading\"> <h3 class=\"panel-title\">Annotations</h3> </div> <div id=\"msg-container\" class=\"panel-body annotations\"> </div> <div class=\"panel-footer\"> <textarea id=\"msg-input\" rows=\"3\" class=\"form-control\" placeholder=\"Comment...\"> </textarea> <button id=\"msg-submit\" class=\"btn btn-primary form-control\" type=\"submit\"> Post </button> </div> </div> </div> </div> 上記テンプレート内で player_id/1 という関数を使っているので watch_view.ex を実装します。 1 2 3 4 5 6 7 8 9 defmodule Rumbl.WatchView do use Rumbl.Web , :view def player_id ( video ) do ~r{&#94;.*(?:youtu\\.be/|\\w+/|v=)(?<id>[&#94; # &?]*)} |> Regex . named_captures ( video . url ) |> get_in ([ \"id\" ]) end end 正規表現を使って投稿されたYouTubeのURLに対してパラメータ部分のみを取り出しています。 router.ex に / スコープに get \"/watch/:id\", WatchController, :show を追加しておきます。 最後に、ビデオ一覧画面にウォッチ画面へのリンクボタンを作成します。 video/index.html.eex に以下を追加します。 1 2 3 4 5 6 7 8 9 10 11 12 ... <tbody> <%= for video <- @videos do %> <tr> <td> <%= video . user_id %> </td> <td> <%= video . url %> </td> <td> <%= video . title %> </td> <td> <%= video . description %> </td> <td class=\"text-right\"> <%= link \"Watch\" , to : watch_path ( @conn , :show , video ), class : \"btn btn-default btn-xs\" %> ... これで準備は完了です。次からJavaScript側のコードを作成します。 視聴用ページ作成 最初にPhoenixでのJavaScriptのビルド周りについて触れられています。 ビルドツールは Brunch がデフォルト Brunch の設定はデフォルトでES6になっている Brunch を使わないように変えることも可能。プロジェクト作成時に --no-Brunch オプションを与えると最初から除ける。 web/static/js 以下にあるファイルをすべて app.js にまとめる staticファイルの読み込みは static_path(@conn, \"/js/app.js\") で行う モジュールシステムを利用しないライブラリは web/static/vendor に追加する 公式ドキュメントによると bower で入れたものはこっちに配備されるっぽい？ というわけでJavaScript周りを実装します。 static/js/player.js を以下の通り実装します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 let Player = { player : null , init ( domId , player , onReadby ) { window . onYouTubeIframeAPIReady = () => { this . onIframeReady ( domId , player , onReadby ); }; let youtubeScriptTag = document . createElement ( \"script\" ); // APIの読み込み APIが読み込まれるとonYouTubeIframeAPIReady関数が自動で呼ばれる youtubeScriptTag . src = \"//www.youtube.com/iframe_api\" ; document . head . appendChild ( youtubeScriptTag ); }, onIframeReady ( domId , playerId , onReady ) { this . player = new YT . Player ( domId , { height : \"360\" , width : \"420\" , videoId : playerId , events : { \"onReady\" : ( event => onReady ( event )), \"onStateChange\" : ( event => this . onPlayerStateChange ( event )) } }); }, onPlayerStateChange ( event ) {}, getCurrentTime () { return Math . floor ( this . player . getCurrentTime () * 1000 ); }, seekTo ( millsec ) { return this . player . seekTo ( millsec / 1000 ); } }; export default Player ; YouTubeのAPIを読み込んでいます。本筋から外れてしまうので割愛します。文法がES2015形式なので昔のJavaScriptとはちょっと変わっています。 ソースを作っただけでは読み込んでくれないので static/js/app.js を以下のように変更します。 1 2 3 4 5 6 7 8 ... import Player from \"./player\" ; let video = document . getElementById ( \"video\" ); if ( video ) { Player . init ( video . id , video . getAttribute ( \"data-player-id\" ), () => { console . log ( \"player ready!\" ); }); } import 文もES2015の文法だったと記憶してます。これも特に言うことはありません。 こんな感じで実装して実行したあと、 priv/static/js/app.js を見に行くとソースがまとめられていることがわかります。 抜粋して載せてみます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 var Player = { player : null , init : function init ( domId , plyerId , onReadby ) { var _this = this ; window . onYouTubeIframeAPIReady = function () { _this . onIframeReady ( domId , playerId , onReadby ); }; var youtubeScriptTag = document . createElement ( \"script\" ); // APIの読み込み APIが読み込まれるとonYouTubeIframeAPIReady関数が自動で呼ばれる youtubeScriptTag . src = \"//www.youtube.com/iframe_api\" ; document . head . appendChild ( youtubeScriptTag ); }, onIframeReady : function onIframeReady ( domId , playerId , _onReady ) { var _this2 = this ; this . player = new YT . Player ( domId , { height : \"360\" , width : \"420\" , videoId : playerId , events : { \"onReady\" : function onReady ( event ) { return _onReady ( event ); }, \"onStateChange\" : function onStateChange ( event ) { return _this2 . onPlayerStateChange ( event ); } } }); }, onPlayerStateChange : function onPlayerStateChange ( event ) {}, getCurrentTime : function getCurrentTime () { return Math . floor ( this . player . getCurrentTime () * 1000 ); }, seekTo : function seekTo ( millsec ) { return this . player . seekTo ( millsec / 1000 ); } }; exports . default = Player ; }); スラッグの追加 各ビデオを任意のURLでアクセス出来るように Slug を付けます。 mix ecto.gen.migration add_slug_to_video を実行後以下のようにマイグレーションファイルを変更します。 1 2 3 4 5 6 7 8 9 defmodule Rumbl.Repo.Migrations.AddSlugToVideo do use Ecto.Migration def change do alter table ( :videos ) do add :slug , :string end end end 出来たらマイグレーションを実行後、 video.ex で新たに追加された slug カラムを使うようにします。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 defmodule Rumbl.Video do use Rumbl.Web , :model schema \"videos\" do field :url , :string field :title , :string field :description , :string field :slug , :string # 追加 belongs_to :user , Rumbl.User belongs_to :category , Rumbl.Category timestamps () end @doc \"\"\" Builds a changeset based on the `struct` and `params`. \"\"\" def changeset ( struct , params \\\\ %{}) do struct |> cast ( params , [ :url , :title , :description , :category_id ]) |> validate_required ([ :url , :title , :description ]) |> slugify_title () # タイトルをSlugに変換 |> assoc_constraint ( :category ) end defp slugify_title ( changeset ) do # タイトルからSlugを作成する # changesetを弄るだけで変更予定データの追加などが出来ている if title = get_change ( changeset , :title ) do put_change ( changeset , :slug , slugify ( title )) else changeset end end defp slugify ( str ) do str |> String . downcase () |> String . replace ( ~r/[&#94;\\w-]+/u , \"-\" ) end end get_change や put_change などを使うことで、変更が changeset の中だけで収まってくれています。 まとめ JavaScript のビルドツールのデフォルトは Brunch JavaScript の書式はデフォルトでES2015(ES6)形式 static系統のファイルは web/static/* に色々おいていくとよしなにしてくれる 全体的にクライアントサイドって感じでした。","tags":"programming","url":"posts/2017/01/30/programming-phoenix13/"},{"title":"Programming Phoenix勉強その12","text":"その12です。テストの続きです。ビュー周りのテストからです。 テンプレートのテスト 何個か前の章でやったようにテンプレートのレンダリングも単なる関数なので簡単にテスト可能です。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 defmodule Rumbl.VideoViewTest do use Rumbl.ConnCase , async : true import Phoenix.View test \"renders index.html\" , %{ conn : conn } do videos = [% Rumbl.Video { id : \"1\" , title : \"dogs\" }, % Rumbl.Video { id : \"2\" , title : \"cats\" }] # テンプレートを文字列としてレンダリングする content = render_to_string ( Rumbl.VideoView , \"index.html\" , conn : conn , videos : videos ) assert String . contains? ( content , \"Listing videos\" ) # 内包表記は中の式は評価される for video <- videos do assert String . contains? ( content , video . title ) end end test \"renders new.html\" , %{ conn : conn } do changeset = Rumbl.Video . changeset (% Rumbl.Video {}) categories = [{ \"cats\" , 123 }] content = render_to_string ( Rumbl.VideoView , \"new.html\" , conn : conn , changeset : changeset , categories : categories ) assert String . contains? ( content , \"New video\" ) end end 注目すべきは render_to_string 関数でテンプレートを文字列としてレンダリングしている点かと思います。 実際にレンダリングをHTMLとして行わなくてもテストが出来ています。 render_to_string 関数のオプションにテンプレート側で使う変数を割り当てられるようです。 モデルのテスト（非同期） モデルのテストを行う前に model_case.ex を確認しておきます。ついでに import Rumbl.TestHelpers を追記もしておきます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 defmodule Rumbl.ModelCase do use ExUnit.CaseTemplate using do quote do alias Rumbl.Repo import Ecto import Ecto.Changeset import Ecto.Query import Rumbl.TestHelpers import Rumbl.ModelCase end end setup tags do :ok = Ecto.Adapters.SQL.Sandbox . checkout ( Rumbl.Repo ) unless tags [ :async ] do Ecto.Adapters.SQL.Sandbox . mode ( Rumbl.Repo , { :shared , self ()}) end :ok end def errors_on ( struct , data ) do struct . __struct__ . changeset ( struct , data ) |> Ecto.Changeset . traverse_errors ( & Rumbl.ErrorHelpers . translate_error / 1 ) |> Enum . flat_map ( fn { key , errors } -> for msg <- errors , do : { key , msg } end ) end end 書籍と比べて error_on 関数が変更されてますが余りきにしなくて良さそうです。ぱっとみエラーメッセージをマップに変更しているだけに見えます。 model/user_test.exs を作成し以下のように実装します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 defmodule Rumbl.UserTest do use Rumbl.ModelCase , async : true alias Rumbl.User @valid_attrs %{ name : \"A User\" , username : \"eva\" , password : \"secret\" } @invalid_attrs %{} test \"changeset with valid attributes\" do changeset = User . changeset (% User {}, @valid_attrs ) assert changeset . valid? end test \"changeset with invalid attributes\" do changeset = User . changeset (% User {}, @invalid_attrs ) refute changeset . valid? end test \"changeset does not accepts long usernames\" do attrs = Map . put ( @valid_attrs , :username , String . duplicate ( \"a\" , 30 )) assert { :username , \"should be at most 20 character(s)\" } in errors_on (% User {}, attrs ) end test \"registration_changeset password must be at least 6 chars long\" do attrs = Map . put ( @valid_attrs , :password , \"12345\" ) changeset = User . registration_changeset (% User {}, attrs ) assert { :password , { \"should be at least %{count} character(s)\" , [ count : 6 , validation : :length , min : 6 ]}} in changeset . errors end test \"registration_changeset with valid attributes hashes password\" do attrs = Map . put ( @valid_attrs , :password , \"123456\" ) changeset = User . registration_changeset (% User {}, attrs ) %{ password : pass , password_hash : pass_hash } = changeset . changes assert changeset . valid? assert pass_hash assert Comeonin.Bcrypt . checkpw ( pass , pass_hash ) end end erros_on を使っている場所は ここを参考 にしました。 これらのテストは副作用を起こさないテストでまとめたため、 async: true にして並列実行しているようです。 副作用のあるテスト 副作用が無く非同期に実行できるテストに対して、実際に Repo.insert したりするようなテストは副作用が発生します。その為、同じモデルのテストでも副作用あり/無しで分離してテストを書きます。 model/user_repo_test.exs を以下のように作成します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 defmodule Rumbl.UserRepoTest do use Rumbl.ModelCase alias Rumbl.User @valid_attrs %{ name : \"A User\" , username : \"eva\" } test \"converts unique_constraint on username to error\" do insert_user ( username : \"eric\" ) attrs = Map . put ( @valid_attrs , :username , \"eric\" ) changeset = User . changeset (% User {}, attrs ) assert { :error , changeset } = Repo . insert ( changeset ) # changeset.errorsはキーワードリストになっている # キーワードリストの各要素は最初の値がアトムとなるタプルとしても認識される assert { :username , { \"has already been taken\" , []}} in changeset . errors end end 実際にインサートを行っている以外には大した違いが無いです。 async オプションはデフォルトで false なので指定をしていません。 関係ないですが、キーワードリストについて忘れてて若干ハマりました・・・ 同様に category_repo_test.exs を以下のように作ります。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 defmodule Rumbl.CategoryRepoTest do use Rumbl.ModelCase alias Rumbl.Category test \"alphabetical/1 orders by name\" do Repo . insert! (% Category { name : \"c\" }) Repo . insert! (% Category { name : \"a\" }) Repo . insert! (% Category { name : \"b\" }) query = Category |> Category . alphabetical () query = from c in query , select : c . name assert Repo . all ( query ) == ~w(a b c) end end 別段躓くところはなかったです。 まとめ ビューは単なる関数なので render_to_string などを使って簡単にテストができる。 副作用が無いテストを分離することで非同期にテストを実行できる。 NUnit とか使ってうっかり先に書いたテストに依存するようなテストを書いちゃうことは結構ありましたが、今回のように改めてテストの同期/非同期を意識したのは新鮮でした。 書籍の区分け的にはここで一段落です。以降からパート2に入ります。 Channel とかは目玉昨日の一つだと思うのでやっていきます。","tags":"programming","url":"posts/2017/01/29/programming-phoenix12/"},{"title":"Programming Phoenix勉強その11","text":"その11です。chapter8です。テストですよ 環境が test になるのでChapter7でやったWindows用コンパイルをやっておきます。細かい部分は省きます。 1 rumbl> set \"MIX_ENV=test\" && mix deps.compile テスト用に自動生成されるコードについて テストを実行する前に自動生成された video_controller_test.exs を削除しておきます。 conn_case.ex を見るとテストの初期設定がかいてあるっぽいです。ちなみに最新版だと書籍のやつと大分違います。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 defmodule Rumbl.ConnCase do use ExUnit.CaseTemplate using do quote do # Import conveniences for testing with connections use Phoenix.ConnTest alias Rumbl.Repo import Ecto import Ecto.Changeset import Ecto.Query import Rumbl.Router.Helpers # The default endpoint for testing @endpoint Rumbl.Endpoint end end setup tags do :ok = Ecto.Adapters.SQL.Sandbox . checkout ( Rumbl.Repo ) unless tags [ :async ] do Ecto.Adapters.SQL.Sandbox . mode ( Rumbl.Repo , { :shared , self ()}) end { :ok , conn : Phoenix.ConnTest . build_conn ()} end end using ブロックは対して違いが無いですが、 setup ブロックは大分違います。 Ectoのドキュメント を見て探ってみます。 Ecto.Adapters.SQL.Sandbox.checkout(Rumbl.Repo) では与えられたリポジトリに対してコネクションを取りに行っているようです。 次の Ecto.Adapters.SQL.Sandbox.mode(Rumbl.Repo, {:shared, self()}) は接続の共有方法を指定しているようです。同期的にテストを行う場合はこちらのようです。（ allow/3 関数を使った非同期の方も書いてありましたが割愛します。） また、これは checkout された接続と同じ接続を使うようなので checkout の後に呼び出すのが必須なようです。 接続に対して所有権の概念が導入されこのようになったようです。 ログアウト時のテストの実装 まずテストデータを作る関数を作ります。 test/support/test_helpers.ex を作ります。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 defmodule Rumbl.TestHelpers do alias Rumbl.Repo def insert_user ( attrs \\\\ %{}) do # Dictをマージする キーが被っている時は第二引数のものが優先される changes = Enum . into ( attrs , %{ name : \"Some User\" , username : \"user #{ Base . encode16 ( :crypto . rand_bytes ( 8 )) } \" , password : \"supersecret\" , }) % Rumbl.User {} |> Rumbl.User . registration_changeset ( changes ) |> Repo . insert! () end def insert_video ( user , attrs \\\\ %{}) do user |> Ecto . build_assoc ( :videos , attrs ) |> Repo . insert! () end end 新しい目のElixirだと Dict がdeprecatedと怒られるので Enum.into に変えてます。第一引数の Enumerable を第二引数の Collectable のものに合体します。パイプでやろうかと思いましたが逆に見にくくなりそうだったのでやめました。 作った関数を各テストで使えるように import します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 using do quote do # Import conveniences for testing with connections use Phoenix.ConnTest alias Rumbl.Repo import Ecto import Ecto.Changeset import Ecto.Query import Rumbl.Router.Helpers # 自分で実装したヘルパー関数を各テストで使えるようにする import Rumbl.TestHelpers # The default endpoint for testing @endpoint Rumbl.Endpoint end end 最後に video_controller_test.exs を作ります。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 defmodule Rumbl.VideoControllerTest do use Rumbl.ConnCase test \"requires user authentication on all actions\" , %{ conn : conn } do Enum . each ([ get ( conn , video_path ( conn , :new )), get ( conn , video_path ( conn , :index )), get ( conn , video_path ( conn , :show , \"123\" )), get ( conn , video_path ( conn , :edit , \"123\" )), put ( conn , video_path ( conn , :update , \"123\" , %{})), post ( conn , video_path ( conn , :create , %{})), delete ( conn , video_path ( conn , :delete , \"123\" )), ], fn conn -> assert html_response ( conn , 302 ) # ユーザ認証が必要なので全部設定されたパスにリダイレクトされる assert conn . halted # 認証が行われていないのでhaltedはtrueになる end ) end end ユーザ認証が行われていない時にちゃんとリダイレクトされて halted が true になっているかテストをしています。このテストは mix test で実行した時にパスするはずです。 ログイン時のテストの実装 ログアウトときたらログインということで実装してみます。 まずテスト時にログインしてないと話にならないのでそこら辺からやっていきます。 auth.ex の call/2 関数を変更します。 1 2 3 4 5 6 7 8 9 10 11 12 13 def call ( conn , repo ) do user_id = get_session ( conn , :user_id ) cond do user = conn . assigns [ :current_user ] -> conn user = user_id && repo . get ( Rumbl.User , user_id ) -> # assignでconnを変更する(importされた関数) # これによって:current_userがコントローラやビューで使えるようになる assign ( conn , :current_user , user ) true -> assign ( conn , :current_user , nil ) end end cond で場合分けをしていて、カレントユーザがすでに入ればそのまま conn を返します。これで :current_user を突っ込んだ後にこいつを呼び出せばそのまま処理に移れるはずです。 次に video_controller_test.exs を以下のように変更します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 defmodule Rumbl.VideoControllerTest do use Rumbl.ConnCase alias Rumbl.Video @valid_attrs %{ url : \"http://youtu.be\" , title : \"vid\" , description : \"a vid\" } @invalid_attrs %{ title : \"invalid\" } defp video_count ( query ), do : Repo . one ( from v in query , select : count ( v . id )) setup %{ conn : conn } = config do if username = config [ :login_as ] do # ログインしておいて欲しいときはこっち user = insert_user ( username : \"max\" ) conn = assign ( conn , :current_user , user ) { :ok , conn : conn , user : user } else # ログインしてほしくないときはこっち :ok end end test \"requires user authentication on all actions\" , %{ conn : conn } do Enum . each ([ get ( conn , video_path ( conn , :new )), get ( conn , video_path ( conn , :index )), get ( conn , video_path ( conn , :show , \"123\" )), get ( conn , video_path ( conn , :edit , \"123\" )), put ( conn , video_path ( conn , :update , \"123\" , %{})), post ( conn , video_path ( conn , :create , %{})), delete ( conn , video_path ( conn , :delete , \"123\" )), ], fn conn -> assert html_response ( conn , 302 ) # ユーザ認証が必要なので全部設定されたパスにリダイレクトされる assert conn . halted # 認証が行われていないのでhaltedはtrueになる end ) end @tag login_as : \"max\" test \"lists all user's videos on index\" , %{ conn : conn , user : user } do user_video = insert_video ( user , title : \"funny cats\" ) other_video = insert_video ( insert_user ( username : \"other\" ), title : \"another video\" ) conn = get conn , video_path ( conn , :index ) assert html_response ( conn , 200 ) =~ ~r/Listing videos/ assert String . contains? ( conn . resp_body , user_video . title ) refute String . contains? ( conn . resp_body , other_video . title ) end @tag login_as : \"max\" test \"creates user video and redirects\" , %{ conn : conn , user : user } do conn = post conn , video_path ( conn , :create ), video : @valid_attrs assert redirected_to ( conn ) == video_path ( conn , :index ) assert Repo . get_by! ( Video , @valid_attrs ) . user_id == user . id end @tag login_as : \"max\" test \"does not create video and renders errors when invalid\" , %{ conn : conn } do count_before = video_count ( Video ) conn = post conn , video_path ( conn , :create ), video : @invalid_attrs assert html_response ( conn , 200 ) =~ \"check the errors\" assert video_count ( Video ) == count_before end @tag login_as : \"max\" test \"autorizes actions against access by other users\" , %{ user : owner , conn : conn } do video = insert_video ( owner , @valid_attrs ) non_owner = insert_user ( username : \"sneaky\" ) conn = assign ( conn , :current_user , non_owner ) assert_error_sent :not_found , fn -> get ( conn , video_path ( conn , :show , video )) end assert_error_sent :not_found , fn -> get ( conn , video_path ( conn , :edit , video )) end assert_error_sent :not_found , fn -> get ( conn , video_path ( conn , :update , video , video : @valid_attrs )) end assert_error_sent :not_found , fn -> get ( conn , video_path ( conn , :delete , video )) end end end video_controller に対するテストを一気に追加しました。ポイントとなるのは以下だと思います。テスト自体にそんなに難しいところは無いと思います。 setup の部分をタグによって場合分けした。それにより、ログイン時のテストにはタグを付けることでログアウト時のテストと一緒にテストが出来る。 @～ で共通で使えるリクエストパラメータを外出しした。 Plugのテスト Plug のテストも普通のテストと同じように書けます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 defmodule Rumbl.AuthTest do use Rumbl.ConnCase alias Rumbl.Auth setup %{ conn : conn } do conn = conn |> bypass_through ( Rumbl.Router , :browser ) # bypass_through関数でRouterを経由してconnを作る |> get ( \"/\" ) { :ok , %{ conn : conn }} end test \"authenticate_user halts when no current_user exists\" , %{ conn : conn } do conn = Auth . authenticate_user ( conn , []) assert conn . halted end test \"authenticate_user continues when the current_user exists\" , %{ conn : conn } do conn = conn |> assign ( :current_user , % Rumbl.User {}) |> Auth . authenticate_user ([]) refute conn . halted end test \"login puts the user in the session\" , %{ conn : conn } do login_conn = conn |> Auth . login (% Rumbl.User { id : 123 }) |> send_resp ( :ok , \"\" ) # テスト用に:okをレスポンスとして返す next_conn = get ( login_conn , \"/\" ) assert get_session ( next_conn , :user_id ) === 123 end test \"logout drops the session\" , %{ conn : conn } do logout_conn = conn |> put_session ( :user_id , 123 ) |> Auth . logout () |> send_resp ( :ok , \"\" ) next_conn = get ( logout_conn , \"/\" ) refute get_session ( next_conn , :user_id ) end test \"call places user from session into assigns\" , %{ conn : conn } do user = insert_user () # セッションにユーザIDをを入れてcallを呼び出す conn = conn |> put_session ( :user_id , user . id ) |> Auth . call ( Repo ) assert conn . assigns . current_user . id == user . id end test \"call with no session sets current_user assign to nil\" , %{ conn : conn } do # sessionに何も入れずにcallを呼び出す conn = Auth . call ( conn , Repo ) assert conn . assigns . current_user == nil end test \"login with a valid username and pass\" , %{ conn : conn } do user = insert_user ( username : \"me\" , password : \"secret\" ) { :ok , conn } = Auth . login_by_username_add_pass ( conn , \"me\" , \"secret\" , repo : Repo ) assert conn . assigns . current_user . id == user . id end test \"login with a not found user\" , %{ conn : conn } do assert { :error , :not_found , _conn } = Auth . login_by_username_add_pass ( conn , \"me\" , \"secret\" , repo : Repo ) end test \"login with password mismatch\" , %{ conn : conn } do _ = insert_user ( username : \"me\" , password : \"secret\" ) assert { :error , :unauthorized , _conn } = Auth . login_by_username_add_pass ( conn , \"me\" , \"wrond\" , repo : Repo ) end end あまり書くことはないですが、 setup で bypass_through で各パイプを経由した conn を作っている点くらいだと思います。 セッションやらフラッシュメッセージが必要となるためです。 テストの高速化のために config/text.exs に以下を追加しておきます。 1 2 3 # テストを高速化するためにハッシュの複雑差を変えて計算の時間を減らす config :comeonin , :bcrypt_log_rounds , 4 config :comeonin , :pbkdf2_rounds , 1 まとめ よくあるテストコードと余り変わらなくて特に書くことがない・・・今までの知識を総動員している感覚があります。","tags":"programming","url":"posts/2017/01/28/programming-phoenix11/"},{"title":"Programming Phoenix勉強その10","text":"その10です。 chapter7の続きです。 Ecto.Queryの利用 前のChapterで調べた Ecto.Query を利用して Category にソート用の query と取得用の query を生成できる関数を用意します。 1 2 3 4 5 6 7 def alphabetical ( query ) do from c in query , order_by : c . name end def names_and_ids ( query ) do from c in query , select : { c . name , c . id } end テンプレートの準備 カテゴリ一覧は取得できるようになったのでそれを表示できるようにしておきます。 video/form.html.eex を以下のように編集します。 1 2 3 4 5 6 7 8 9 <%= form_for @changeset , @action , fn f -> %> ... <!-- 追加 --> <div class=\"form-group\"> <%= label f , :category_id , \"Category\" , class : \"control-label\" %> <%= select f , :category_id , @categories , class : \"form-control\" , prompt : \"Choose a category\" %> </div> ... <% end %> video/new.html.eex を以下のように編集します。 1 2 3 4 5 6 <h2>New video</h2> <%= render \"form.html\" , changeset : @changeset , categories : @categories , action : video_path ( @conn , :create ) %> <%= link \"Back\" , to : video_path ( @conn , :index ) %> video/edit.html.eex を以下のように編集します。 1 2 3 4 5 6 <h2>Edit video</h2> <%= render \"form.html\" , changeset : @changeset , categories : @categories , action : video_path ( @conn , :update , @video ) %> <%= link \"Back\" , to : video_path ( @conn , :index ) %> QueryのAPIについて Query 構築の際に使えるものは以下 ==, !=, <=, >=,<,> and, or, not in like,ilike is_nil count, avg, sum, min, max datetime_add, date_add fragment, field, type より柔軟に Query を使いたい場合は fragments を使うことが出来る。 1 from ( u in User , where : fragment ( \"lower(username) = ?\" , &#94; String . downcase ( uname ))) よくある静的プレースホルダと同じでしょうか。この方法でもセキュリティは担保されています。 もっと柔軟にクエリを投げたいときは以下のように直接SQLを実行できます。 1 iex> Ecto.Adapters.SQL.query ( Rumbl.Repo, \"SELECT power( $1 , $2 )\" , [ 2 , 10 ]) クエリで関連するものも取りたい時は以下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 iex ( 6 ) > user = Repo.one from ( u in User, limit: 1 ) [ debug ] QUERY OK source = \"users\" db = 16 .0ms decode = 15 .0ms SELECT u0. \"id\" , u0. \"name\" , u0. \"username\" , u0. \"password_hash\" , u0. \"inserted_at\" , u0. \"updated_at\" FROM \"users\" AS u0 LIMIT 1 [] %Rumbl.User { __meta__: #Ecto.Schema.Metadata<:loaded, \"users\">, id: 1, inserted_at: ~N [ 2017 -01-11 03 :37:33.878000 ] , name: \"aaa\" , password: nil, password_hash: \" $2 b $12$L2IGA8kAewNvbOLJ0 /c7i.4m6k18hAmuTSG4JuaHhyUK0qWfB0hae\" , updated_at: ~N [ 2017 -01-16 03 :40:31.371000 ] , username: \"aaa\" , videos: #Ecto.Association.NotLoaded<association :videos is not loaded>} iex ( 7 ) > user.videos # この時点ではNotLoaded #Ecto.Association.NotLoaded<association :videos is not loaded> iex ( 8 ) > user = Repo.preload ( user, :videos ) # preloadすると関連するものも取れる [ debug ] QUERY OK source = \"videos\" db = 78 .0ms SELECT v0. \"id\" , v0. \"url\" , v0. \"title\" , v0. \"description\" , v0. \"user_id\" , v0. \"category_id\" , v0. \"inserted_at\" , v0. \"updated_at\" , v0. \"user_id\" FROM \"videos\" AS v0 WHERE ( v0. \"user_id\" = $1 ) ORDER BY v0. \"user_id\" [ 1 ] %Rumbl.User { __meta__: #Ecto.Schema.Metadata<:loaded, \"users\">, id: 1, inserted_at: ~N [ 2017 -01-11 03 :37:33.878000 ] , name: \"aaa\" , password: nil, password_hash: \" $2 b $12$L2IGA8kAewNvbOLJ0 /c7i.4m6k18hAmuTSG4JuaHhyUK0qWfB0hae\" , updated_at: ~N [ 2017 -01-16 03 :40:31.371000 ] , username: \"aaa\" , videos: []} iex ( 9 ) > user.videos [] Repo.preload 関数を使えば関連するものも一緒に取得できます。ただ、毎回 user の取得と preload を別々にやるのは面倒なので以下のようなオプションが良いされてます。 1 2 3 4 5 6 7 8 9 10 11 iex ( 10 ) > user = Repo.one from ( u in User, limit: 1 , preload: [ :videos ]) [ debug ] QUERY OK source = \"users\" db = 0 .0ms SELECT u0. \"id\" , u0. \"name\" , u0. \"username\" , u0. \"password_hash\" , u0. \"inserted_at\" , u0. \"updated_at\" FROM \"users\" AS u0 LIMIT 1 [] [ debug ] QUERY OK source = \"videos\" db = 16 .0ms SELECT v0. \"id\" , v0. \"url\" , v0. \"title\" , v0. \"description\" , v0. \"user_id\" , v0. \"category_id\" , v0. \"inserted_at\" , v0. \"updated_at\" , v0. \"user_id\" FROM \"videos\" AS v0 WHERE ( v0. \"user_id\" = $1 ) ORDER BY v0. \"user_id\" [ 1 ] %Rumbl.User { __meta__: #Ecto.Schema.Metadata<:loaded, \"users\">, id: 1, inserted_at: ~N [ 2017 -01-11 03 :37:33.878000 ] , name: \"aaa\" , password: nil, password_hash: \" $2 b $12$L2IGA8kAewNvbOLJ0 /c7i.4m6k18hAmuTSG4JuaHhyUK0qWfB0hae\" , updated_at: ~N [ 2017 -01-16 03 :40:31.371000 ] , username: \"aaa\" , videos: []} iex ( 11 ) > join も普通に出来ます。 1 2 3 4 5 6 7 8 9 10 11 iex ( 11 ) > Repo.all from u in User, ... ( 11 ) > join: v in assoc ( u, :videos ) , ... ( 11 ) > join: c in assoc ( v, :category ) , ... ( 11 ) > where: c.name == \"Comedy\" , ... ( 11 ) > select : { u, v } [ debug ] QUERY OK source = \"users\" db = 31 .0ms SELECT u0. \"id\" , u0. \"name\" , u0. \"username\" , u0. \"password_hash\" , u0. \"inserted_at\" , u0. \"updated_at\" , v1. \"id\" , v1. \"url\" , v1. \"title\" , v1. \"description\" , v1. \"user_id\" , v1. \"category_id\" , v1. \"inserted_at\" , v1. \"updated_at\" FROM \"users\" AS u0 INNER JOIN \"videos\" AS v1 ON v1. \"user_id\" = u0. \"id\" INNER JOIN \"categories\" AS c2 ON c2. \"id\" = v1. \"category_id\" WHERE ( c2. \"name\" = 'Comedy' ) [] [] iex ( 12 ) > 各制約について 現状のアプリケーションはマイグレーションファイルに create unique_index(:users, [:username]) とあり、重複するユーザーネームを登録しようとするとエラーになります。 このままだと画面にエラーが出てしまうので changeset で受け取れるように変更してみます。 user.ex を編集します。 1 2 3 4 5 6 7 def changeset ( model , params \\\\ %{}) do model |> cast ( params , [ :name , :username ]) # 更新予定のパラメータカラムを第三引数でとる(?) |> validate_required ([ :name , :username ]) # このリストがcastが返すchangesetに存在するか検証 |> validate_length ( :username , min : 1 , max : 20 ) |> unique_constraint ( :username ) end unique_constraint を最後のパイプラインに追加することで :username がかぶっていればエラーにしてくれます。 この調子で外部キー制約もエラーハンドリングできるようにします。 video.ex を以下のように変更します。 色々やった結果元の部分も間違っていたので修正してます。 1 2 3 4 5 6 def changeset ( struct , params \\\\ %{}) do struct |> cast ( params , [ :url , :title , :description , :category_id ]) |> validate_required ([ :url , :title , :description ]) |> assoc_constraint ( :category ) end validate_required の第三引数には何がはいるのだろうか・・・と思いましたが、 公式ドキュメント に書いてありました。 :message を取り、エラーメッセージをカスタマイズできるっぽいです。 これで外部制約も確かめることが出来ます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 iex ( 1 ) > alias Rumbl.Repo iex ( 2 ) > alias Rumbl.Video iex ( 3 ) > alias Rumbl.Category iex ( 4 ) > import Ecto.Query iex ( 5 ) > video = Repo.one ( from v in Video, limit: 1 ) iex ( 6 ) > changeset = Video.changeset ( video, % { category_id: 12345 }) iex ( 7 ) > Repo.update changeset [ debug ] QUERY OK db = 0 .0ms begin [] [ debug ] QUERY ERROR db = 46 .0ms UPDATE \"videos\" SET \"category_id\" = $1 , \"updated_at\" = $2 WHERE \"id\" = $3 [ 12345 , {{ 2017 , 1 , 23 } , { 15 , 2 , 49 , 366000 }} , 1 ] [ debug ] QUERY OK db = 0 .0ms rollback [] { :error, #Ecto.Changeset<action: :update, changes: %{category_id: 12345}, errors: [ category: { \"does not exist\" , []}] , data: #Rumbl.Video<>, valid?: false> } 良さそうです。 また、削除するときには foreign_key_constraint 関数が使えます。これを使うとカテゴリが削除出来ない理由をユーザに示す事ができます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 iex> alias Rumbl.Repo iex> alias Rumbl.Category iex> alias Rumbl.Video iex> import Ecto.Query iex> import Ecto.Changeset iex> category = Repo.get_by Category, name: \"Drama\" iex> changeset = Ecto.Changeset.change ( category ) iex> changeset = foreign_key_constraint ( changeset, :videos, name: :videos_category_id_fkey, message: \"still exist\" ) iex> Repo.delete changeset [ debug ] QUERY ERROR db = 312 .0ms DELETE FROM \"categories\" WHERE \"id\" = $1 [ 6 ] { :error, #Ecto.Changeset<action: :delete, changes: %{}, errors: [ videos: { \"still exist\" , []}] , data: #Rumbl.Category<>, valid?: false> } video のデータの中に既に Drama カテゴリーのIDを参照しているものがあれば設定したエラーを出してくれます。ちなみにどっかで書いたかもしれませんが Ecto.Changeset.change 関数は構造体とかからチェンジセット作ってくれる関数です。 cast やバリデーションを使いたくない時に使えるみたいです。（ 参考 ） もう一つの選択肢として、マイグレーション時に参照先が削除された時どうするかの設定が書けるみたいです。前に作った add_category_id_to_video を見てみます。 1 2 3 4 5 6 7 8 9 defmodule Rumbl.Repo.Migrations.AddCategoryIdToVideo do use Ecto.Migration def change do alter table ( :videos ) do add :category_id , references ( :categories ) end end end add :category_id, references(:categories) の部分が肝です。 references(:categories) には :on_delete オプションが付けられるようです。 :nothing ：デフォルト値。何もしない :delete_all ：関連するものも一緒に削除する :nilify_all ：関連するものが削除されたとき NULL にする まとめ Query のAPIを使うことでデータベースへの柔軟な問合せができる。 *_constraints を使うことで各制約のバリデーションを使える。 書籍の中には頻繁にデータベースでやることはデータベースの中でやるべきだとありました。また、全部に *_constraints 付けるのではなくクラッシュすべきところはクラッシュすべきとも書いてありました。ココらへんはElixirのLet's Crashの思想から来ているのかと思います。ユーザ側がどうにか出来る制約エラーの場合はカスタムエラーメッセージを出すと良いらしいです。（また英語力が・・・）","tags":"programming","url":"posts/2017/01/24/programming-phoenix10/"},{"title":"Programming Phoenix勉強その9","text":"その9です。 ここからchapter7です。 Ecto の続きっぽいです。 videoのカテゴリー追加 ビデオにカテゴリーを付けられるようにします。ジェネレータを使って category モデルを生成します。ついでに色々準備もします。 以下のコマンドを実行します。 1 rumbl $ mix phoenix.gen.model Category categories name:string 出来上がったマイグレーションファイルを編集します。 NOT NULL 制約とか付けます。 1 2 3 4 5 6 7 8 9 10 11 12 13 defmodule Rumbl.Repo.Migrations.CreateCategory do use Ecto.Migration def change do create table ( :categories ) do add :name , :string , null : false timestamps () end create unique_index ( :categories , [ :name ]) end end video.ex を Category に紐付けるように変更します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 defmodule Rumbl.Video do use Rumbl.Web , :model schema \"videos\" do field :url , :string field :title , :string field :description , :string belongs_to :user , Rumbl.User belongs_to :category , Rumbl.Category timestamps () end @doc \"\"\" Builds a changeset based on the `struct` and `params`. \"\"\" def changeset ( struct , params \\\\ %{}) do struct |> cast ( params , [ :url , :title , :description ]) |> validate_required ([ :url , :title , :description ], [ :category_id ]) end end 例に漏れず cast/4 じゃなくなってるので適当に公式ドキュメント見て辻褄合わせしてます。 video モデルに category_id を追加するためのマイグレーションファイルを作ります。 1 rumbl $ mix ecto.gen.migration add_category_id_to_video 出来上がったファイルを編集します。 1 2 3 4 5 6 7 8 9 10 defmodule Rumbl.Repo.Migrations.AddCategoryIdToVideo do use Ecto.Migration def change do alter table ( :videos ) do add :category_id , references ( :categories ) end end end マイグレーションを実行します。いつものコマンドです。 マイグレーション出来たら seeds.exs を編集して初期データを作ります。カテゴリー名は他の要素で編集されない固定の値だからです。 1 2 3 4 5 6 7 alias Rumbl.Repo alias Rumbl.Category for category <- ~w(Action Drama Romance Comedy Sci-fi) do # カテゴリがすでに存在するか確認して無ければ入れる Repo . get_by ( Category , name : category ) || Repo . insert! (% Category { name : category }) end 用意したら mix run priv/repo/seeds.ex コマンドを実行すればシードデータ投入完了です。 ここまでの流れも余り違和感も不思議なところも無いかと思います。 Ectoについて ここで Ecto の Query とかについて軽く解説がありました。 iex で以下のコマンドを入力すると何が起こっているかわかります。 1 2 3 4 5 6 7 8 9 10 11 iex ( 1 ) > import Ecto.Query Ecto.Query iex ( 2 ) > alias Rumbl.Repo Rumbl.Repo iex ( 3 ) > alias Rumbl.Category Rumbl.Category iex ( 4 ) > Repo.all from c in Category, select : c.name [ debug ] QUERY OK source = \"categories\" db = 188 .0ms decode = 15 .0ms SELECT c0. \"name\" FROM \"categories\" AS c0 [] [ \"Action\" , \"Drama\" , \"Romance\" , \"Comedy\" , \"Sci-fi\" ] iex ( 5 ) > 上記を見てわかるのは Repo.all は Ecto.Query を取る Ecto.Query は from マクロで作れる from マクロ以降の使い方は LINQ to SQL のクエリ式っぽく書ける LINQ to SQL のクエリ式に馴染みがあるとすんなり受け入れられそうです。メソッドとかでラップされない分柔軟に使えそうだなと思いました。分解して構築することも可能です。 1 2 3 4 5 6 7 8 9 10 11 iex ( 6 ) > query = Category Rumbl.Category iex ( 7 ) > query = from c in query, order_by: c.name #Ecto.Query<from c in Rumbl.Category, order_by: [asc: c.name]> iex ( 8 ) > query = from c in query, select : c.name #Ecto.Query<from c in Rumbl.Category, order_by: [asc: c.name], select: c.name> iex ( 9 ) > Repo.all query [ debug ] QUERY OK source = \"categories\" db = 47 .0ms SELECT c0. \"name\" FROM \"categories\" AS c0 ORDER BY c0. \"name\" [] [ \"Action\" , \"Comedy\" , \"Drama\" , \"Romance\" , \"Sci-fi\" ] iex ( 10 ) > 実際に Repo.all/1 とかが引数として取れるものは Ecto.Queryable プロトコルを実装したものらしいです。 Repo.all(Category) とかのような使い方が許されるのはこれらがプロトコルを実装しているからです。 Ecto.Queryableについて ふと疑問に思って Category とか User とか Video とかに Ecto.Queryable プロトコル実装している部分はどこかと思って探しました。 ざっくり探った感じまず、 Ecto.Queryable の該当ソースを見ると以下のようになっています。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 defimpl Ecto.Queryable , for : Atom do def to_query ( module ) do try do module . __schema__ ( :query ) rescue UndefinedFunctionError -> message = if :code . is_loaded ( module ) do \"the given module does not provide a schema\" else \"the given module does not exist\" end raise Protocol.UndefinedError , protocol : @protocol , value : module , description : message end end end for: Atom なんだからモジュールはだめじゃん？とか思われるかもしれませんが、モジュール名の実体は Atom なので問題ないです。 モジュールに to_atom すると true になります。ちなみに Erlang のモジュールは小文字から始まって Elixir のモジュールは :'Elixir.Module' とかになっています。ココらへんはプログラミングElixirとかを参考にするとよいかもしれないです。 話を戻して、 try の部分を見ると module.__schema__(:query) となっていることがわかります。 じゃあ __schema__/1 はどこにあるかというと Ecto.Schema に書いてあります。（内容は直接は関係ないのでおいておきます。） ここまで見て一旦自分で Queryable なモジュールを作ってみました。 1 2 3 defmodule Test do use Ecto.Schema end これで以下を呼び出してみます。 1 2 3 iex ( 0 ) > Ecto.Queryable.to_query ( Test ) ** ( Protocol.UndefinedError ) protocol Ecto.Queryable not implemented for Test, the given module does not provide a schema ( ecto ) lib/ecto/queryable.ex:37: Ecto.Queryable.Atom.to_query/1 モジュールの中に schema がないとだめとか言われているので適当に作ってみます。 1 2 3 4 5 6 defmodule Test do use Ecto.Schema schema \"test\" do end end これでさっきのをもっかい打ち込んでみます。 1 2 iex ( 0 ) > Ecto.Queryable.to_query ( Test ) #Ecto.Query<from t in Test> これでOKです。まとめておくと以下の点を満たすものが Queryable になっていると言ってよさそうです。 Ecto.Schema を use している モジュール内で schema マクロを使っている おまけ Ecto.Schema の __using__ マクロを見てみると以下のようになっています。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 defmacro __using__ ( _ ) do quote do import Ecto.Schema , only : [ schema : 2 , embedded_schema : 1 ] @primary_key nil @timestamps_opts [] @foreign_key_type :id @schema_prefix nil Module . register_attribute ( __MODULE__ , :ecto_primary_keys , accumulate : true ) Module . register_attribute ( __MODULE__ , :ecto_fields , accumulate : true ) Module . register_attribute ( __MODULE__ , :ecto_assocs , accumulate : true ) Module . register_attribute ( __MODULE__ , :ecto_embeds , accumulate : true ) Module . register_attribute ( __MODULE__ , :ecto_raw , accumulate : true ) Module . register_attribute ( __MODULE__ , :ecto_autogenerate , accumulate : true ) Module . register_attribute ( __MODULE__ , :ecto_autoupdate , accumulate : true ) Module . put_attribute ( __MODULE__ , :ecto_autogenerate_id , nil ) end end import Ecto.Schema, only: [schema: 2, embedded_schema: 1] となっているので schema/2 マクロを見てみます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 defmacro schema ( source , [ do : block ]) do schema ( source , true , :id , block ) end defp schema ( source , meta? , type , block ) do quote do ... Module . eval_quoted __ENV__ , [ Ecto.Schema . __defstruct__ ( @struct_fields ), Ecto.Schema . __changeset__ ( @changeset_fields ), Ecto.Schema . __schema__ ( prefix , source , fields , primary_key_fields ), Ecto.Schema . __types__ ( fields ), Ecto.Schema . __assocs__ ( assocs ), Ecto.Schema . __embeds__ ( embeds ), Ecto.Schema . __read_after_writes__ ( @ecto_raw ), Ecto.Schema . __autogenerate__ ( @ecto_autogenerate_id , autogenerate , autoupdate )] end end Module.eval_quoted となっています。 eval_quoted の ドキュメントを見ると quote を展開してモジュールに sum 関数を導入している例が見れます。 Ecto.Schema.__schema__ をみてみます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def __schema__ ( prefix , source , fields , primary_key ) do field_names = Enum . map ( fields , & elem ( &1 , 0 )) # Hash is used by the query cache to specify # the underlying schema structure did not change. # We don't include the source because the source # is already part of the query cache itself. hash = :erlang . phash2 ({ primary_key , fields }) quote do def __schema__ ( :query ), do : % Ecto.Query { from : { unquote ( source ), __MODULE__ }, prefix : unquote ( prefix )} def __schema__ ( :prefix ), do : unquote ( prefix ) def __schema__ ( :source ), do : unquote ( source ) def __schema__ ( :fields ), do : unquote ( field_names ) def __schema__ ( :primary_key ), do : unquote ( primary_key ) def __schema__ ( :hash ), do : unquote ( hash ) end end quote の部分が評価されるのでこれで上記のドキュメントの例と同様に __schema__ 関数がモジュールで使えるようになることがわかります。 やっぱメタプログラミングをもっと勉強しないとちゃんとソースの中身見るのはつらそうな気がします。 まとめ Ecto.Query は分解して書ける Repo.all の引数に取れるのは Ecto.Queryable プロトコルを実装したもののみ Ecto.Queryable になれるモジュールは use Ecto.Schema と schema を定義したモジュールになる。 気になったことを調べたら本題とは別の部分で長くなってしまいました・・・","tags":"programming","url":"posts/2017/01/22/programming-phoenix9/"},{"title":"Programming Phoenix勉強その8","text":"その8です。 ここからchapter6です。 Ecto をコードジェネレータを色々探るみたいです。 コードジェネレータの利用 早速コードジェネレータを使ってみます。 rumbl ビデオにコメントを付けられるアプリなので Video 周りが色々と必要そうです。 Video 周りのものはコードジェネレータにおまかせしてみます。以下のコマンドを入力します。 1 rumbl $ mix phoenix.gen.html Video videos user_id:references:users url:string title:string description:text モデル名の複数形とかモジュール名とかフィールドの型情報とかを与えてやっています。 マイグレーションの前に下準備を行います。 認証処理は共有で使いたいので user_controller.ex にあった authenticate/2 関数は auth.ex に外出して置きます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 defmodule Rumbl.Auth do import Phoenix.Controller alias Rumbl.Router.Helpers ... def authenticate_user ( conn , _opts ) do # Plugで追加したassignの呼び出しが可能かどうか if conn . assigns . current_user do conn else conn |> put_flash ( :error , \"You must be logged in to access that page\" ) |> redirect ( to : Helpers . page_path ( conn , :index )) |> halt () end end end web.ex に以下を追加して全コントローラーとルーターで上記の認証関数を使えるようにします。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ... def controller do quote do use Phoenix.Controller alias Rumbl.Repo import Ecto import Ecto.Query import Rumbl.Router.Helpers import Rumbl.Gettext import Rumbl.Auth , only : [ authenticate_user : 2 ] # 追加 end end ... def router do quote do use Phoenix.Router import Rumbl.Auth , only : [ authenticate_user : 2 ] # 追加 end end 当然、 user_controller.ex の認証プラグも authenticate_user に変えておきます。 router.ex に新しいスコープを追加します。 1 2 3 4 5 scope \"/manage\" , Rumbl do pipe_through [ :browser , :authenticate_user ] resouces \"/videos\" , VideoController end ここまで行ってマイグレーションを行います。 空白文字の扱いについては、 controller 内に scrub_param という Plug が定義されており、これによって自動で nil に変換されているらしいです。 ついでに Model を見に行くとバージョンの違いが結構生成されたものが異なってます。何個か前の章で書いた用に cast/4 関数が非推奨になっているからです。 user_id を外部キーにしてるので、 user.ex も変更しておきます。 1 2 3 4 5 6 7 8 9 schema \"users\" do field :name , :string field :username , :string field :password , :string , virtual : true field :password_hash , :string has_many :videos , Rumbl.Video # 追加 timestamps () end Ectoについて ここで説明される Ecto の関数は以下 Ecto.build_assoc/3 第一引数と関連する第二引数引数の構造体を第三引数の Map の構造で作る Ecto.assoc/2 第一引数に対して has_many になっている第二引数の構造体を取り出すクエリを生成する。コンソール見ると LINQ to SQLっぽいのが流れてた 毎回のように翻訳と理解が正しいか怪しい・・・ 自動生成されたコードの調整 自動生成されたコードを調整します。 まずは video_controller.ex の :new アクションを変更します。 1 2 3 4 5 6 7 8 def new ( conn , _params ) do changeset = conn . assigns . current_user |> build_assoc ( :videos ) # current_userに関連するVideo構造体を作成 |> Video . changeset () # 上記Video構造体からchangeset作成 render ( conn , \"new.html\" , changeset : changeset ) end Video の changeset を作るだけだったのをログイン中のユーザに関連する Video にするように変更しました。 current_user は色んな所で出てきそうで鬱陶しいのでまとめられう方法を探します。幸いなことにカスタムアクションなるものがあるようです。 以下の関数を video_controller.ex に追加します。 1 2 3 def action ( conn , _ ) do apply ( __MODULE__ , action_name ( conn ), [ conn , conn . params , conn . assigns . current_user ]) end パット見わけがわかりませんが簡単です。 まず apply/3 関数はモジュール名、関数名のアトム、その関数に適用する引数を取る関数です。（ Elixirの組み込みです。 ） __MODULE__ は現在のモジュール名で、 action_name/1 は conn が要求するアクション名を返してくる関数です。（ Phoenix側で用意されている。 ） こんな感じにしてやると video_controller.ex の全アクションは上記の第三引数の引数を取るようにカスタマイズされてくれます。 なのでアクションを書き換えます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 defmodule Rumbl.VideoController do use Rumbl.Web , :controller alias Rumbl.Video # カスタムアクションで各アクションをカスタマイズする def action ( conn , _ ) do # 第一引数のモジュールの第二引数の関数に第三引数の引数を渡して実行する apply ( __MODULE__ , action_name ( conn ), [ conn , conn . params , conn . assigns . current_user ]) end def index ( conn , _params , user ) do videos = Repo . all ( user_videos ( user )) render ( conn , \"index.html\" , videos : videos ) end def new ( conn , _params , user ) do changeset = user |> build_assoc ( :videos ) # current_userに関連するVideo構造体を作成 |> Video . changeset () # 上記Video構造体からchangeset作成中身は空 render ( conn , \"new.html\" , changeset : changeset ) end def create ( conn , %{ \"video\" => video_params }, user ) do changeset = user |> build_assoc ( :videos ) # current_userに関連するVideo構造体を作成 |> Video . changeset ( video_params ) # 上記Video構造体からchangeset作成 case Repo . insert ( changeset ) do { :ok , _video } -> conn |> put_flash ( :info , \"Video created successfully.\" ) |> redirect ( to : video_path ( conn , :index )) { :error , changeset } -> render ( conn , \"new.html\" , changeset : changeset ) end end def show ( conn , %{ \"id\" => id }, user , user ) do video = Repo . get! ( user_videos ( user ), id ) render ( conn , \"show.html\" , video : video ) end def edit ( conn , %{ \"id\" => id }, user ) do video = Repo . get! ( user_videos ( user ), id ) changeset = Video . changeset ( video ) render ( conn , \"edit.html\" , video : video , changeset : changeset ) end def update ( conn , %{ \"id\" => id , \"video\" => video_params }, user ) do video = Repo . get! ( user_videos ( user ), id ) changeset = Video . changeset ( video , video_params ) case Repo . update ( changeset ) do { :ok , video } -> conn |> put_flash ( :info , \"Video updated successfully.\" ) |> redirect ( to : video_path ( conn , :show , video )) { :error , changeset } -> render ( conn , \"edit.html\" , video : video , changeset : changeset ) end end def delete ( conn , %{ \"id\" => id }, user ) do video = Repo . get! ( user_videos ( user ), id ) # Here we use delete! (with a bang) because we expect # it to always work (and if it does not, it will raise). Repo . delete! ( video ) conn |> put_flash ( :info , \"Video deleted successfully.\" ) |> redirect ( to : video_path ( conn , :index )) end defp user_videos ( user ) do assoc ( user , :videos ) end end current_user を取り出して使っていたのをカスタムアクションによって引数で取ることができるようになりました。 show アクションなどではユーザに関係のある一覧が欲しいので user_videos/1 関数を用意してあります。 これで Video 周りの実装は一旦修了です。 まとめ assoc で対象に関係のあるデータが取得できる。 コードジェネレータやルーティングについては他の言語とほとんど変わりがない","tags":"programming","url":"posts/2017/01/21/programming-phoenix8/"},{"title":"Programming Phoenix勉強その7","text":"その7です。 ここからchapter5です。認証周りをやるらしいです。 パスワードのハッシュ化 まずはパスワードのハッシュ化を行います。必要なライブラリをインストールするために mix.exs に以下のように追記を行います。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ... def application do [ mod : { Rumbl , []}, applications : [ :phoenix , :phoenix_pubsub , :phoenix_html , :cowboy , :logger , :gettext , :phoenix_ecto , :postgrex , :comeonin ]] # comeoninを追加 end ... defp deps do [{ :phoenix , \"~> 1.2.1\" }, { :phoenix_pubsub , \"~> 1.0\" }, { :phoenix_ecto , \"~> 3.0\" }, { :postgrex , \">= 0.0.0\" }, { :phoenix_html , \"~> 2.6\" }, { :phoenix_live_reload , \"~> 1.0\" , only : :dev }, { :gettext , \"~> 0.11\" }, { :cowboy , \"~> 1.0\" }, { :comeonin , \"~> 2.0\" }] # 追加 end application に対して追加しているのはこのアプリの依存ライブラリを書いているようです。 comeonin とか言うライブラリを追加しています。 リポジトリ を見るとそのまんまパスワードをハッシュ化してくれるライブラリだとわかります。 mix deps.get で追加できたらモデルでこいつを使うように変更してやります。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def changeset ( model , params \\\\ %{}) do model |> cast ( params , [ :name , :username ]) # 更新予定のパラメータカラムを第三引数でとる(?) |> validate_required ([ :name , :username ]) # このリストがcastが返すchangesetに存在するか検証 |> validate_length ( :username , min : 1 , max : 20 ) end def registration_changeset ( model , params ) do model |> changeset ( params ) |> cast ( params , [ :password ]) |> validate_required ([ :password ]) |> validate_length ( :password , min : 6 , max : 100 ) |> put_pass_hash () end defp put_pass_hash ( changeset ) do case changeset do % Ecto.Changeset { valid? : true , changes : %{ password : pass }} -> put_change ( changeset , :password_hash , Comeonin.Bcrypt . hashpwsalt ( pass )) _ -> changeset end end Ecto の最新版を使っているので書籍と若干異なっています。新しい方の Ecto では cast/4 は推奨されなくなっているようです。 なので、 Phoenixのガイド とか、 Ectoのドキュメント とかを見て適当に修正してます。（このやり方でいいか不安ですが・・・） また、 :empty もWarningになるので、空のハッシュに変えています。 ついでに create アクションで User.changeset の部分を User.registration_changeset に変更します。 ここまでやってMacだとOKでしたが、Windowsだとエラーになりました。 Windowsでのエラー（comeonin） Windowsから comeonin を使おうとするとコンパイルを促すエラーが出るので ここ を参考にコンパイルします。 ちなみにVisualStudioインストールしてあったので最下部付近にあるVSインストール済みの場合の方法を取っています。 VSに付属している開発者コマンドプロンプトを起動します。 開発者コマンドプロンプト上で以下のコマンドを実行しておきます。 1 > vcvarsall.bat amd64 vcvarsall.bat にパスが通ってない場合は、適当にフルパスで指定すればいいと思います。これを行わなくてもコンパイル自体は出来ますが、実行時にエラーになりました。（ vcvarsall.bat については MSDN ） 本プロジェクト（ rumbl ）のディレクトリまで移動して以下のコマンドを実行します。 1 rumbl > mix deps.compile 自分の環境ではこれでうまくいきました。 Plugについて Plug を使ってログイン機能を作る前に Plug についてちょっと掘ります。 Plug にはモジュールプラグと関数プラグの二種類が存在する。 モジュールプラグは名前の通り幾つかの関数を集めたモジュールのプラグ 関数プラグは関数名をアトムとして指定したプラグ ログイン機能としてモジュールプラグを作成します。 モジュールプラグ モジュールプラグとして設定するモジュールには init/1 関数と call/2 関数が必要とされます。 以下は何もしないモジュールプラグの例です。 1 2 3 4 5 6 7 8 9 defmodule NothingPlug do def init ( opts ) do opts end def call ( conn , _opts ) do conn end end call 関数の引数を見るとわかりますが、モジュールプラグは conn を変換するようです。 Plug.Connについて(conn) Plug.Conn が持つフィールドについて見てみます。 書籍の方には色々書いてありますが割愛します。 Plug.Connの公式ドキュメント を参照して下さい。ここではリクエストフィールドが持つものだけを見てみます。 host リクエストのホスト名 ex) www.pragprog.com method リクエストのWebメソッド（GETとかPOSTとか） path_info パスを分割したリスト req_headers リクエストヘッダ scheme プロトコル（httpとか） Webのリクエスト周りに関係するものが存在していることがわかります。 認証プラグの実装 やっと認証用のプラグを実装します。 controllers/auth.ex を以下の内容で実装します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 defmodule Rumbl.Auth do import Plug.Conn def init ( opts ) do # キーワードリストから:repoの箇所の値を取得する # 無ければexception(つまりは必須) Keyword . fetch! ( opts , :repo ) end def call ( conn , repo ) do user_id = get_session ( conn , :user_id ) user = user_id && repo . get ( Rumbl.User , user_id ) # assignでconnを変更する(importされた関数) # これによって:current_userがコントローラやビューで使えるようになる assign ( conn , :current_user , user ) end end コメント通りなので余り言うことはないです。 init で repo を取得してそれが conn の第二引数に渡されるようです。セッションにあるユーザIDからユーザを取得しています。 パイプラインの流れの一部として処理してほしいので router.ex を以下のように変更します。 1 2 3 4 5 6 7 8 pipeline :browser do plug :accepts , [ \"html\" ] plug :fetch_session plug :fetch_flash plug :protect_from_forgery plug :put_secure_browser_headers plug Rumbl.Auth , repo : Rumbl.Repo # 追加 end アクセス制限の実装 Plug は出来たのでアクセス制限とログインを作ります。ログインしない限りは :index アクションと :show アクションにアクセス出来ないようにします。 user_controller.ex を以下のように変更します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 defmodule Rumbl.UserController do ... def index ( conn , _params ) do case authenticate ( conn ) do # 構造体connのhaltedメンバのパターンマッチによる振り分け % Plug.Conn { halted : true } = conn -> conn conn -> users = Repo . all ( Rumbl.User ) render conn , \"index.html\" , users : users end end ... defp authenticate ( conn ) do # Plugで追加したassignの呼び出しが可能かどうか if conn . assigns . current_user do conn else conn |> put_flash ( :error , \"You must be logged in to access that page\" ) |> redirect ( to : page_path ( conn , :index )) |> halt () end end end 先程の Plug で変更した値を authenticate/1 関数で使っています。また、 :index アクションのアクセス時に authenticate 関数で認証済みかチェック掛けています。 authenticate の関数プラグ化 user_controller.ex の Rumbl.Web の直下のあたりに以下を追加します。 1 plug :authenticate when action in [ :index , :show ] また、 index アクションを case 文を使う以前のものに戻しておきます。 authenticate 関数も以下のように2引数にしておきます。 1 2 3 4 5 6 7 8 9 10 11 defp authenticate ( conn , _opts ) do # Plugで追加したassignの呼び出しが可能かどうか if conn . assigns . current_user do conn else conn |> put_flash ( :error , \"You must be logged in to access that page\" ) |> redirect ( to : page_path ( conn , :index )) |> halt () end end _opts を追加しただけです。関数 Plug 化したためです。 Plug をマクロ展開したときの例が出てますが割愛します。 ログインの実装 認証までしか無いので実際のログイン処理を実装します。取り敢えず create アクションでユーザが作成された時に自動でログインするようにしてみます。 先程作った auth.ex に以下の関数を追加します。 1 2 3 4 5 6 def login ( conn , user ) do conn |> assign ( :current_user , user ) |> put_session ( :user_id , user . id ) |> configure_session ( renew : true ) # セッションキーとかを新しくしている(セキュリティのため) end 次に create アクションでこの関数を呼び出すようにしてやります。 1 2 3 4 5 6 7 8 9 10 11 12 def create ( conn , %{ \"user\" => user_params }) do changeset = User . registration_changeset (% User {}, user_params ) case Repo . insert ( changeset ) do { :ok , user } -> conn |> Rumbl.Auth . login ( user ) # ユーザを作成したらログイン |> put_flash ( :info , \" #{ user . name } created!\" ) |> redirect ( to : user_path ( conn , :index )) { :error , changeset } -> render ( conn , \"new.html\" , changeset : changeset ) end end これで完了です。 ログイン画面の実装 ここまででログインするための素材は揃ったので、ログイン/ログアウト画面を作ります。今まで作ったものの合わせ技なので一気に行きます。 session_controller.ex を実装します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 defmodule Rumbl.SessionController do use Rumbl.Web , :controller def new ( conn , _ ) do render conn , \"new.html\" end def create ( conn , %{ \"session\" => %{ \"username\" => user , \"password\" => pass }}) do case Rumbl.Auth . login_by_username_add_pass ( conn , user , pass , repo : Repo ) do { :ok , conn } -> conn |> put_flash ( :info , \"Welcome back!\" ) |> redirect ( to : page_path ( conn , :index )) { :error , _reason , conn } -> conn |> put_flash ( :error , \"Invalid username/password combination\" ) |> render ( \"new.html\" ) end end def delete ( conn , _ ) do conn |> Rumbl.Auth . logout () |> redirect ( to : page_path ( conn , :index )) end end session_view.ex も作っておきます。内容は割愛します。関数などは定義しなくて良いです。 router.ex も上で作った session_controller.ex 用に追加しておきます。 1 2 3 4 5 6 7 scope \"/\" , Rumbl do pipe_through :browser # Use the default browser stacks. get \"/\" , PageController , :index resources \"/users\" , UserController , only : [ :index , :show , :new , :create ] resources \"/sessions\" , SessionController , only : [ :new , :create , :delete ] # 追加 end usernameとpasswordでログインするための関数とログアウト用の関数を auth.ex に用意しておきます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ... import Comeonin.Bcrypt , only : [ checkpw : 2 , dummy_checkpw : 0 ] ... def logout ( conn ) do configure_session ( conn , drop : true ) end def login_by_username_add_pass ( conn , username , given_pass , opts ) do repo = Keyword . fetch! ( opts , :repo ) user = repo . get_by ( Rumbl.User , username : username ) # 複数の値で分岐しているためcaseではなくcond(caseは与えられた1つの値に対する分岐) cond do user && checkpw ( given_pass , user . password_hash ) -> { :ok , login ( conn , user )} user -> { :error , :unauthorized , conn } true -> dummy_checkpw () { :error , :not_found , conn } end end ログイン画面用のテンプレートも作ります。まず session/new.html.eex を以下のように実装します。 1 2 3 4 5 6 7 8 9 10 11 12 <h1>Login</h1> <%= form_for @conn , session_path ( @conn , :create ), [ as : :session ] , fn f -> %> <div class=\"form-group\"> <%= text_input f , :username , placeholder : \"Username\" , class : \"form-control\" %> </div> <div class=\"form-group\"> <%= password_input f , :password , placeholder : \"Password\" , class : \"form-control\" %> </div> <%= submit \"Log in\" , class : \"btn btn-primary\" %> <% end %> 最後に今まで作ったもののリンクを表示します。 layout/app.html.eex を以下のように変更します。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <header class=\"header\"> <ol class=\"breadcrumb text-right\"> <!-- assignsで突っ込んだものが使えている --> <%= if @current_user do %> <li> <%= @current_user . username %> </li> <li> <%= link \"Log out\" , to : session_path ( @conn , :delete , @current_user ), method : \"delete\" %> </li> <% else %> <li> <%= link \"Register\" , to : user_path ( @conn , :new ) %> </li> <li> <%= link \"Log in\" , to : session_path ( @conn , :new ) %> </li> <% end %> </ol> <span class=\"logo\"></span> </header> これでOKなはずです。 まとめ Plug.Conn を使ったセッションやコネクションの管理はスマートだし中身が分かればわかりやすいと思いました。関数の引数に毎回 conn が出てきちゃいますが・・・ 本のおかげかもしれませんが余りブラックボックスな部分を残さないよう理解出来ている感があるのが良いです。 関数型だけあってかロジックを関数毎に分離しているのがとても良かったです。書いてて理解し易い気がします。 1記事がやたらと長くなりましたが実験ということで・・・","tags":"programming","url":"posts/2017/01/19/programming-phoenix7/"},{"title":"Programming Phoenix勉強その6","text":"その6です。 実際にDBを操作するところからです。 新規ユーザ生成処理 Rumbl.UserController に以下の関数を実装します。 1 2 3 4 def new ( conn , _params ) do changeset = User . changeset (% User {}) render conn , \"new.html\" , changeset : changeset end changeset 周りとかが謎めいていますが一旦置いときます。単に自分が今理解してないだけですが・・・ DBの操作とそれ以外の検証とかエラーとかセキュリティとかを分離するのに役立つっぽいです。 user.ex に上記で利用している User.changeset 関数を実装します。 1 2 3 4 5 def changeset ( model , params \\\\ :empty ) do model |> cast ( params , ~w(name username) , []) |> validate_length ( :username , min : 1 , max : 20 ) end Ecto を使う関数を定義しました。 cast で Ecto.changeset を生成してバリデーションチェックを掛けているようです。 前準備 :new アクションを実装する前に前準備をします。 今まで書いてあったルーティング設定を消して以下を追加します。まぁ説明不要だと思います。 1 resouces \"/users\" , UserController , only : [ :index , :show , :new , :create ] テンプレート実装 :new に対応するテンプレートを適当に作ります。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 <h1>New User</h1> <%= form_for @changeset , user_path ( @conn , :create ), fn f -> %> <div class=\"form-group\"> <%= text_input f , :name , placeholder : \"Name\" , class : \"form-control\" %> </div> <div class=\"form-group\"> <%= text_input f , :username , placeholder : \"Username\" , class : \"form-control\" %> </div> <div class=\"form-group\"> <%= password_input f , :password , placeholder : \"Password\" , class : \"form-control\" %> </div> <%= submit \"Create User\" , class : \"btn, btn-primary\" %> <% end %> ここまでやって起動したところ、何やらWarningが出たので解消します。 1 2 3 4 5 6 7 8 9 10 11 warning: ` Ecto.Changeset.cast/4 ` is deprecated, please use ` cast/3 ` + ` validate_required/3 ` instead ( rumbl ) web/models/user.ex:15: Rumbl.User.changeset/2 ( rumbl ) web/controllers/user_controller.ex:16: Rumbl.UserController.new/2 ( rumbl ) web/controllers/user_controller.ex:1: Rumbl.UserController.action/2 ( rumbl ) web/controllers/user_controller.ex:1: Rumbl.UserController.phoenix_controller_pipeline/2 warning: passing :empty to Ecto.Changeset.cast/3 is deprecated, please pass an empty map or :invalid instead ( rumbl ) web/models/user.ex:15: Rumbl.User.changeset/2 ( rumbl ) web/controllers/user_controller.ex:16: Rumbl.UserController.new/2 ( rumbl ) web/controllers/user_controller.ex:1: Rumbl.UserController.action/2 ( rumbl ) web/controllers/user_controller.ex:1: Rumbl.UserController.phoenix_controller_pipeline/2 Warningの解消 Ecto とかのバージョの違いのせいか2つWarningが出てました。1つは user.ex の changeset/2 関数のデフォルト引数で :empty としていた部分です。 その部分を以下のように変えます。 1 def changeset ( model , params \\\\ %{}) do 単純に空の Map にしただけですね。 もう1つ cast/4 関数を呼び出している部分でもWarningが出ているので修正します。 1 2 3 4 model |> cast ( params , [ :name , :username ]) |> validate_required ([ :name , :username ]) |> validate_length ( :username , min : 1 , max : 20 ) ここ とか ここらへん 参考にしましたが英語力の無さ故にあってるかわからないです。誰か教えて!! パラメータの名前的にはあってそうですが・・・ また、これを見ると cast が changeset を返してきて、それに対してバリデーションを掛けているのがわかります。 Createアクションの実装 new アクションを実装したので実際にDBにインサートする create アクションを実装します。 1 2 3 4 5 6 7 8 9 10 11 def create ( conn , %{ \"user\" => user_params }) do changeset = User . changeset (% User {}, user_params ) case Repo . insert ( changeset ) do { :ok , user } -> conn |> put_flash ( :info , \" #{ user . name } created!\" ) |> redirect ( to : user_path ( conn , :index )) { :error , changeset } -> render ( conn , \"new.html\" , changeset : changeset ) end end あんまり説明することはないですが、 conn からのパイプラインで作成後の template 用の処理を読んでる点くらいでしょうか。パイプラインが最大の特徴かもしれませんが・・・ また、 new.html.eex もエラーを表示するように変えます。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 <h1>New User</h1> <%= if @changeset . action do %> <div class=\"alert alert-danger\"> <p>Oops, something went wrong! Please check the errors below.</p> </div> <% end %> <%= form_for @changeset , user_path ( @conn , :create ), fn f -> %> <div class=\"form-group\"> <%= text_input f , :name , placeholder : \"Name\" , class : \"form-control\" %> <%= error_tag f , :name %> </div> <div class=\"form-group\"> <%= text_input f , :username , placeholder : \"Username\" , class : \"form-control\" %> <%= error_tag f , :username %> </div> <div class=\"form-group\"> <%= password_input f , :password , placeholder : \"Password\" , class : \"form-control\" %> <%= error_tag f , :password %> </div> <%= submit \"Create User\" , class : \"btn, btn-primary\" %> <% end %> error_tag/2 関数は view の error_helpers.ex に定義されている関数です。 Changesetについて このchapterの最後に changeset について触れられています。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 iex ( 1 ) > changeset = Rumbl.User.changeset ( %Rumbl.User { username: \"eric\" }) #Ecto.Changeset<action: nil, changes: %{}, errors: [ name: { \"can't be blank\" , [ validation: :required ]}] , data: #Rumbl.User<>, valid?: false> iex ( 2 ) > changeset #Ecto.Changeset<action: nil, changes: %{}, errors: [ name: { \"can't be blank\" , [ validation: :required ]}] , data: #Rumbl.User<>, valid?: false> iex ( 3 ) > import Ecto.Changeset Ecto.Changeset iex ( 4 ) > changeset.changes % {} iex ( 5 ) > changeset = put_change ( changeset, :username, \"ericmj\" ) #Ecto.Changeset<action: nil, changes: %{username: \"ericmj\"}, errors: [ name: { \"can't be blank\" , [ validation: :required ]}] , data: #Rumbl.User<>, valid?: false> iex ( 6 ) > changeset.changes % { username: \"ericmj\" } iex ( 7 ) > get_change ( changeset, :username ) \"ericmj\" これを見ると changeset はバリデーション以外にも変更をの追跡と保持を行っていることがわかります。 まとめ 簡単なDB操作を行いました。今回はテンプレート周りはおまけだったように思います。 何かしらフレームワーク触ったことあればそんなに違和感はなく使えると思います。 ずっと changeset が謎だったんですが、少し理解できたと思います。 基本的なところは結構網羅されてきたんじゃないかと思いますのでサクサク行きたいです。","tags":"programming","url":"posts/2017/01/11/programming-phoenix6/"},{"title":"Programming Phoenix勉強その5","text":"その5です。ここからChapter4です。 Ecto を使って独自実装してた Repository を Postgres に置き換えていきます。 まず lib/rumbl/repo.ex をもとに戻します。 1 2 3 defmodule Rumbl.Repo do use Ecto.Repo , otp_app : :rumbl end さらに lib/rumbl.ex でコメントアウトした部分をもとに戻します。 1 2 # Start the Ecto repository supervisor ( Rumbl.Repo , []), # ここのコメントアウトを戻す まだ mix ecto.create をしてなければしておきます。 modelの実装 次に model の実装を行います。 web/model/user.ex を以下の内容で実装します。 1 2 3 4 5 6 7 8 9 10 11 12 defmodule Rumbl.User do use Rumbl.Web , :model schema \"users\" do field :name , :string field :username , :string field :password , :string , virtual : true field :password_hash , :string timestamps end end ActiveRecord 使ったことがあればそんなに違和感なく受け入れられると思います。 :virtual オプションは値として受け取るが、DBには保存しない値です。 ここまで行って起動してみたら以下のような警告が出ました。 1 2 3 warning: variable \"timestamps\" does not exist and is being expanded to \"timestamps()\" , please use parentheses to remove the ambiguity or change the variable name web/models/user.ex:10 timestamps が変数なのか timestamps/0 の関数呼び出しか曖昧だと言われてるようです。 今回は timestamps/0 の呼び出しなので timestamps の部分を timestamps() にすると警告がでなくなります。 ここらへん を参考にしました。 最後に web/web.ex の model 関数を以下のように変更します。 1 2 3 4 5 6 7 8 9 def model do quote do use Ecto.Schema import Ecto import Ecto.Changeset import Ecto.Query , only : [ from : 1 , from : 2 ] # only以下を追加 end end DBのマイグレーション DB側にもテーブルとかを作る必要があるので以下のコマンドを実行します。 1 2 3 rumbl $ mix ecto.gen.migration create_user * creating priv/repo/migrations * creating priv/repo/migrations/20170108070642_create_user.exs 生成された priv/repo/migrations/{日付}_create_user.exs ファイルを以下のように変更します。 これもRailsやったことあれば説明不要だと思います。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 defmodule Rumbl.Repo.Migrations.CreateUser do use Ecto.Migration def change do create table ( :users ) do add :name , :string add :username , :string , null : false add :password_hash , :string timestamps () end create unique_index ( :users , [ :username ]) end end mix ecto.migrate でマイグレーションを実行します。 まとめ Model 周りの話でした。O/Rマッパー使ったことあればあまり違和感なく受け入れられそうでした。 関係ないですけど、基本的な部分終わったらガンガン飛ばしていこうと思います。亀のようなペースだと全然おわらないので。","tags":"programming","url":"posts/2017/01/09/programming-phoenix5/"},{"title":"Programming Phoenix勉強その4","text":"その4です。 その3の続きです。 :show アクションの実装からです. :showアクションの実装 :show アクションで各ユーザの詳細を表示できるようにします. まず Controler を実装します. 1 2 3 4 def show ( conn , %{ \"id\" => id }) do user = Repo . get ( Rumbl.User , id ) render conn , \"show.html\" , user : user end 次に, web/templates/user/show.html.eex を以下の内容で実装します. 1 2 <h1>Showing User</h1> <b> <%= first_name ( @user ) %> </b> ( <%= @user . id %> ) よく見ると <b> タグの部分が index.html.eex とかぶっているのがわかります. templateの分離 各テンプレートで重複している部分を別テンプレートに分離します. web/templates/user/user.html.eex を以下の内容で実装します. 1 <b> <%= first_name ( @user ) %> </b> ( <%= @user . id %> ) 共通部分をくくりだしたので,既存のテンプレートを編集します. web/templates/user/index.html.eex を以下の内容に変更します. <%= render \"user.html\", user: user %> の部分が変更点です. 1 2 3 4 5 6 7 8 9 10 <h1>Listing Users</h1> <table class=\"table\"> <%= for user <- @users do %> <tr> <td> <%= render \"user.html\" , user : user %> </td> <td> <%= link \"View\" , to : user_path ( @conn , :show , user . id ) %> </td> </tr> <% end %> </table> web/templates/user/show.html.eex も同様に変更します. 1 2 <h1>Showing User</h1> <%= render \"user.html\" , user : @user %> view はモジュール, template は関数と捉えると良いみたいです. iex -S mix で以下のコマンドを入力すると何が起きているかなんとなくわかります. view の部分が :safe とリストの入れ子のタプルになってて一見わかりにくいですが,リストの部分は単なるタグの入れ子になってるみたいです. 素のタグ部分と, <%= %> とか <% %> の部分とでわけられてるみたいです. 1 2 3 4 5 6 iex ( 1 ) > user = Rumbl.Repo.get Rumbl.User, \"1\" %Rumbl.User { id: \"1\" , name: \"Jose\" , password: \"elixir\" , username: \"josevalim\" } iex ( 2 ) > view = Rumbl.UserView.render ( \"user.html\" , user: user ) { :safe, [[[[[ \"\" | \"<b>\" ] | \"Jose\" ] | \"</b> (\" ] | \"1\" ] | \")\\n\" ]} iex ( 3 ) > Phoenix.HTML.safe_to_string ( view ) \"<b>Jose</b> (1)\\n\" :safe はこのHTMLが安全であることを示しています. また、リストになっているのはパフォーマスのためだそうです. ぱっと見どのテンプレートも render 関数呼び出しで呼び出されるっぽいですがテンプレート名でパターンマッチが行われることによってレンダリングしてるようです. error 見るとよりわかりやすそうです. 1 2 3 4 5 6 7 def render ( \"404.html\" , _assigns ) do \"Page not found\" end def render ( \"500.html\" , _assigns ) do \"Internal server error\" end render 関数が2つあって第一引数のテンプレート名でパターンマッチしてるのがわかります. レンダリングについて 一番初めに templates/layout/app.html.eex がレンダリングされて,その後正規のテンプレートがレンダリングされる. まぁRailsとかもおんなじ感じだったと思うのでここらへんは適当にすっ飛ばします. まとめ ここでChapter3終わるのでちょっと短いですがここまでです. @conn みたいな度々出てくる conn の正体がまだイマイチ理解しきれてないので具体的にどういうものがどういう流れで入ってきてるのかぼちぼちしらべたいです.","tags":"programming","url":"posts/2017/01/07/programming-phoenix4/"},{"title":"Programming Phoenix勉強その3","text":"その3です。 その2の続きです。 今回からChpater3です. このChapterではまず rumbl と呼ばれるアプリを作ります. ビデオにたいしてリアルタイムでコメントを付けられるアプリになる予定らしい. 準備 Chapter1と同様に以下のコマンドでPhoenixの新しいプロジェクトを作成します.（詳細は割愛） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ mix phoenix.new rumbl * creating rumbl/ config/ config.exs ... Fetch and install dependencies? [ Yn ] y * running mix deps.get * running npm $ cd rumbl rumbl $ mix ecto.create == > connection Compiling 1 file （.ex） Generated connection app ... Modelの追加 実際はコマンドで自動生成されるものを手製で実装します. web/models/user.ex を以下の内容で実装します. 1 2 3 defmodule Rumbl.User do defstruct [ :id , :name , :username , :password ] endD これは id, name, username, password 構造体として持つUserモジュールです. Repositoryの変更 現段階では,RepositoryはRDBからではなく独自にハードコーディングします. このようにすることで,データの概念とデータベースの概念が分離されていることがわかります. （ Repo と Model として） まず, lib/rumbl/repo.ex を以下のように変更します. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 defmodule Rumbl.Repo do @moduledoc \"\"\" In memory repository. \"\"\" def all ( Rumbl.User ) do [% Rumbl.User { id : \"1\" , name : \"Jose\" , username : \"josevalim\" , password : \"elixir\" }, % Rumbl.User { id : \"2\" , name : \"Bruce\" , username : \"redropids\" , password : \"7longs\" }, % Rumbl.User { id : \"3\" , name : \"Chris\" , username : \"chrismccord\" , password : \"phx\" }] end def all ( _module ), do : [] def get ( module , id ) do Enum . find all ( module ), fn map -> map . id == id end end def get_by ( module , params ) do Enum . find all ( module ), fn map -> Enum . all? ( params , fn { key , val } -> Map . get ( map , key ) == val end ) end end end Ecto を使わないようにしたので, lib/rumbl.ex を編集して上記の repo.ex をプロセス管理対象から外します. 1 2 # Start the Ecto repository # supervisor(Rumbl.Repo, []), # これをコメントアウト 上手く行っているか試すにはコンソールでプロジェクトフォルダに移動して iex -S mix コマンドで iex を起動します. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 rumbl $ iex -S mix Erlang/OTP 19 [ erts-8.2 ] [ source ] [ 64 -bit ] [ smp:4:4 ] [ async-threads:10 ] [ hipe ] [ kernel-poll:false ] [ dtrace ] Compiling 7 files ( .ex ) Interactive Elixir ( 1 .3.4 ) - press Ctrl+C to exit ( type h () ENTER for help ) iex ( 1 ) > alias Rumbl.User Rumbl.User iex ( 2 ) > alias Rumbl.Repo Rumbl.Repo iex ( 3 ) > Repo.all User [ %Rumbl.User { id: \"1\" , name: \"Jose\" , password: \"elixir\" , username: \"josevalim\" } , %Rumbl.User { id: \"2\" , name: \"Bruce\" , password: \"7longs\" , username: \"redropids\" } , %Rumbl.User { id: \"3\" , name: \"Chris\" , password: \"phx\" , username: \"chrismccord\" }] iex ( 4 ) > Repo.all Rumbl.Other [] iex ( 5 ) > Repo.get User, \"1\" %Rumbl.User { id: \"1\" , name: \"Jose\" , password: \"elixir\" , username: \"josevalim\" } iex ( 6 ) > Repo.get_by User, name: \"Brunce\" nil iex ( 7 ) > Repo.get_by User, name: \"Bruce\" %Rumbl.User { id: \"2\" , name: \"Bruce\" , password: \"7longs\" , username: \"redropids\" } iex ( 8 ) > Controllerの実装 上記で作成した Repository を扱う Controller を実装します. まず,専用のルーティング設定を web/router.ex に設定します. 1 2 3 4 5 6 7 scope \"/\" , Rumbl do pipe_through :browser # Use the default browser stacks. get \"/users\" , UserController , :index # 追加 get \"/users/:id\" , UserController , :show # 追加 get \"/\" , PageController , :index end みて分かる通り UserControler の index アクションと show アクションに対応するルーティング設定を行います. get マクロはHTTPメソッドのGETで呼び出されることを想定されています. 次に,設定したルーティングに対応する Controller を実装します. 1 2 3 4 5 6 7 8 defmodule Rumbl.UserController do use Rumbl.Web , :controller def index ( conn , _params ) do users = Repo . all ( Rumbl.User ) render conn , \"index.html\" , users : users end end hello アプリで作成したものと対して変わらないと思います. 違いは Repo.all/1 関数でユーザ一覧を取ってきてることくらいだと思います. この時点でもまだ View がないとエラーになるので, View の実装をします. Viewの実装 web/views/user_view.ex を以下の内容で実装します. 1 2 3 4 5 6 7 8 9 10 defmodule Rumbl.UserView do use Rumbl.Web , :view alias Rumbl.User def first_name (% User { name : name }) do name |> String . split ( \" \" ) |> Enum . at ( 0 ) end end 単純に名前を名字と名前で分解しているだけの関数です. View モジュール名は Controller 名から自動で推測されます. （ UserController なら UserView といった具合） Templateの実装 web/templates/user/index.html.eex を以下の内容で実装します. 1 2 3 4 5 6 7 8 9 10 <h1>Listing Users</h1> <table class=\"table\"> <%= for user <- @users do %> <tr> <td><b> <%= first_name ( user ) %> </b> ( <%= user . id %> )</td> <td>> <%= link \"View\" , to : user_path ( @conn , :show , user . id ) %> </td> </tr> <% end %> </table> Template は View 名から自動で推測されます. （ UserView なら user フォルダといった具合） ここまでくれば http://localhost:4000/users でユーザ一覧が表示されます. EEx のハイライトないので ERB でハイライトしてます. Viewのuse Rumbl.Web, :viewについて view に記述した use Rumbl.Web, :view の実体は web/web.ex に存在します. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 defmodule Rumbl.Web do … def view do quote do use Phoenix.View , root : \"web/templates\" # Import convenience functions from controllers import Phoenix.Controller , only : [ get_csrf_token : 0 , get_flash : 2 , view_module : 1 ] # Use all HTML functionality (forms, tags, etc) use Phoenix.HTML import Rumbl.Router.Helpers import Rumbl.ErrorHelpers import Rumbl.Gettext end end … end Phoenix.HTML をHTML周りのことを色々やってくれているようです. また,これによって生成されるHTMLは安全で,XSS対策なども行ってくれているようです. ここには勝手に関数を書くのはNG.書きたいなら真似して import を使うこと. まとめ 今回は前回より具体的に各機能を実装しました. 個人的には今までよくわからなかった Repository と Model の関係がちょっとわかったのが収穫でした. 他のフレームワーク触ってると, View と Template が分離しているのが一瞬戸惑いそうだとおもいました.","tags":"programming","url":"posts/2017/01/04/programming-phoenix3/"},{"title":"Programming Phoenix勉強その2","text":"その2です。 その1の続きです。 デフォルトのディレクトリ構成について config ディレクトリ Phoenixの設定ファイル置き場.名前のまま. prod.secret.exs は秘密情報が入っているファイルなので,VCSからは外すこと. config.exs の endpoint はWebサーバーとアプリケーションの接続の境界部分. lib ディレクトリ Supervision treeと,長く起動するプロセスが置かれる.（?,あってるか微妙） DBとのコネクションプールとかのような長く使われるものが置かれるっぽい. test ディレクトリ 名前の通りテストが置かれる. web ディレクトリ Webアプリに必要な model , view , template , controller が置かれる. Plugについて Plug ライブラリは接続の統一化のために使われる. Plug のリポジトリ [Plugリポジトリ] には以下のように書いてある. ・ A specification for composable modules between web applications ・ Connection adapters for different web servers in the Erlang VM なので,各機能のモジュールの仕様の記述と,Erlang VMと各Webサーバーとの接続をやってくれるみたいです. （あまり理解してない感が） 実際にPhoenixが作ってくれる物を見てみます. config/endpoint.exs を見てみます. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 defmodule Hello.Endpoint do use Phoenix.Endpoint , otp_app : :hello socket \"/socket\" , Hello.UserSocket # Serve at \"/\" the static files from \"priv/static\" directory. # # You should set gzip to true if you are running phoenix.digest # when deploying your static files in production. plug Plug.Static , at : \"/\" , from : :hello , gzip : false , only : ~w(css fonts images js favicon.ico robots.txt) # Code reloading can be explicitly enabled under the # :code_reloader configuration of your endpoint. if code_reloading? do socket \"/phoenix/live_reload/socket\" , Phoenix.LiveReloader.Socket plug Phoenix.LiveReloader plug Phoenix.CodeReloader end plug Plug.RequestId plug Plug.Logger plug Plug.Parsers , parsers : [ :urlencoded , :multipart , :json ], pass : [ \"*/*\" ], json_decoder : Poison plug Plug.MethodOverride plug Plug.Head # The session will be stored in the cookie and signed, # this means its contents can be read but not tampered with. # Set :encryption_salt if you would also like to encrypt it. plug Plug.Session , store : :cookie , key : \"_hello_key\" , signing_salt : \"zzWE+Yw+\" plug Hello.Router end とりあえず plug ってのがいっぱい出てきています. なんとなく見てると, plug Plug.Static で静的ファイルについての設定っぽいものが書いてあったり, plug Plug.Logger とか, plug Plug.Parsers とかあったりして,Webアプリに必要な設定が書いてあるっぽいなと言う感覚です. ココらへんの一連の plug は関数のパイプラインとして処理されるようです. 1 2 3 4 5 6 7 8 9 connection |> Plug.Static . call |> Plug.RequestId . call |> Plug.Logger . call |> Plug.Parsers . call |> Plug.MethodOverride . call |> Plug.Head . call |> Plug.Session . call |> Hello.Router . call ソースに書いた順になってるっぽいです.Servletの設定順ミスってハマった思い出が… ちなみに endpoint 自体も plug で,アプリケーション自体は endpoint で始まり controller で終わる一連のパイプラインらしい. Routerについて web/router.ex のソースを見ると,2つのパイプラインがあることがわかる. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 defmodule Hello.Router do use Hello.Web , :router pipeline :browser do plug :accepts , [ \"html\" ] plug :fetch_session plug :fetch_flash plug :protect_from_forgery plug :put_secure_browser_headers end pipeline :api do plug :accepts , [ \"json\" ] end scope \"/\" , Hello do pipe_through :browser # Use the default browser stack get \"/hello/:name\" , HelloController , :world get \"/\" , PageController , :index end # Other scopes may use custom stacks. # scope \"/api\", Hello do # pipe_through :api # end end browser パイプライン HTMLのみを受け付ける. セッション管理とか,フラッシュメッセージとか,セキュリティ対策とかを提供してくれるらしい. api パイプライン 基本的なJSON API用のパイプライン.JSONのみ受け付ける. XMLにしたいときとかはここ一箇所変更すれば全部変更される. pipe_through でどのパイプラインを使うか書く. 処理の流れとしては接続を取得→パイプラインを呼び出し→コントローラーを呼び出し. 呼び出し順を纏めると以下になる. 1 2 3 4 5 connection |> endpoint |> router |> pipeline |> controller まとめ 今回は,内部的な処理の流れとかおまじない的な部分が何をしてるかの勉強だった感じです. 英語がヘタレ過ぎて自分が理解している意味とあってるか若干の不安が... リンク [Plugリポジトリ] https://github.com/elixir-lang/plug","tags":"programming","url":"posts/2016/12/31/programming-phoenix2/"},{"title":"Programming Phoenix勉強その1","text":"買ってあったけど読んでなかったので読みます.プログラミングElixirは原著の方も翻訳の方も一応読んでます. プログラミングElixirについては色々なところで書評なり見る気がするけど,こっちの方は余り見ない気がします. Programming Phoenix: Productive, Reliable, Fast posted with カエレバ Chris Mccord,Bruce Tate,Jose Valim Pragmatic Bookshelf 2016-04-30 Amazon ちなみに実際にコードを書くPart1のChapter2からやってきます. あとPhoenix自体は何回か触ってます.趣味で. 前提 PostgreSQL9.5 Elixir 1.3.2 Phoenix Framework1.2.1 本より新し目のバージョンにしてるので,色々問題ありそうですが頑張る感じで行きます. 初期構築 プロジェクトテンプレートの生成としてはじめに以下のコマンドを入力します. 1 2 3 4 5 6 7 $ mix phoenix.new hello * creating hello/ config/ config.exs ... Fetch and install dependencies? [ Yn ] y * running mix deps.get * running npm これでカレントディレクトリにhelloってフォルダが掘られて,色々勝手に整備してくれる. 次に以下のコマンドでDB作ったりします. 1 2 3 4 5 6 $ cd hello hello $ mix ecto.create == > connection Compiling 1 file （.ex） Generated connection app ... これで hello_dev とか言うデータベースができていればOKです. 出来てなければ, config/dev.exs ってファイルにDBとの接続設定があるので見直します. 起動 以下のコマンドでサーバー起動. 1 2 $ cd hello $ mix phoenix.server mix phoenix.server の部分は iex -S mix phoenix.server でもOK.こちらはIEXの内部でサーバーが起動する. ちなみにデフォルトでは localhost:4000 で起動する. ルーティング 特定のURLとのルーティングを行うには, web/router.exs に設定を書く. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 defmodule Hello.Router do # 省略 scope \"/\" , Hello do pipe_through :browser # Use the default browser stack get \"/hello\" , HelloController , :world # 追加 get \"/\" , PageController , :index end # Other scopes may use custom stacks. # scope \"/api\", Hello do # pipe_through :api # end end 見ればなんとなくわかると思いますが, get マクロに対して色々ルーティングの設定をします. この場合は /hello にアクセスが来たら HelloController （モジュール）の :world アクション（関数）を呼び出すようにしてます. ただ,この段階だと HelloController がないのでアクセスしてもエラー画面です. エラー画面が若干本と違ってたので貼っておきます. Controller実装 エラーを解消するために web/controllers/hello_controller.ex を以下の内容で作ります. 1 2 3 4 5 6 7 defmodule Hello.HelloController do use Hello.Web , :controller def world （ conn , _param ） do render conn , \"world.html\" end end ファイル名はController名をスネークケース,モジュール名は, （ scope で設定した名前） . （ get に設定したController名）で作ります. （ココらへんの理解が微妙に曖昧） で,また /hello にアクセスすると,今度はviewがないと怒られます。 View実装 web/views/hello_view.ex を以下の内容で作ります. 1 2 3 defmodule Hello.HelloView do use Hello.Web , :view end で,今度はtemplateが無いって怒られるのでまた作ります. Template実装 web/templates/world.html.eex を以下の内容で作ります. 1 < h1 > From template: Hello world! </ h1 > これで晴れて /hello にアクセスしても怒られなくなります. Routing時のパラメータ 次に,ルーティング時にパラメータを渡す方法を実装します. （ /hoge/1/ のような感じに） web/router.ex に上の方で追加したルーティング設定を修正します. 1 get \"/hello/:name\" , HelloController , :world こうすると :name の部分が色々変えられてControllerに渡されてきます. なので,Controllerを以下のように変更して渡された値を取得できるようにします. 1 2 3 def world ( conn , %{ \"name\" => name }) do render conn , \"world.html\" , name : name end パターンマッチにより渡されてきた値が name にバインドされます. パターンマッチについては本の中で解説されてますが,飛ばします.プログラミングElixirとかElixirのチュートリアルとか読んでもらえれば. 最後に,template側で渡された値を表示するようにしてあげれば完成. 1 < h1 > Hello < %= String.capitalize @name %>! </ h1 > <%= ～ %> の部分にElixirの関数が書けて, @name の部分にControllerから渡された値が入ってくるようです. まとめ とりあえず今回はここまでとしておきます。 かなり復習感ありましたが,基本的な部分はなんとなくわかったと思います。 やっぱりRailsにかなり近くて,Railsやってた人はここらへんはあまり深く読まなくても良い気がします. あと名前付けとかのルールとかは追々という感じで調べていきたいです.","tags":"programming","url":"posts/2016/12/28/programming-phoenix1/"},{"title":"ブログ書くことにした","text":"大した理由は無いけど色々あってブログを書くことにしました。 動機 始めようと思った理由は以下のような感じです。 勉強だけは色々するけど、発表する場が社内でもない。（自分で作ればあるけど・・・） EvernoteとかOnenoteにまとめてたけど中々見づらくてあとで振り返りづらい。 社外の人とも技術的な交流がする場が欲しい。 技術的なアウトプットを目に見える形で出すことにメリットが有ると思ったから。 構成 Pelicanと適当にテーマ使って作ってます。なので見た目はちょくちょく変わるかも。 サーバー自体はGitHub Pages使ってます。 Pelican選んだ理由は以下のような感じです。 Python好きだったから。 流行ってるもの嫌いな天邪鬼だから。（流行ってるものが素晴らしかったり楽しいのは理解してるんですが・・・） 方向性 基本的には技術的な内容にしていきたいですが、好きなゲームとか音楽とかアニメとかも話すかもしれないです。 あと、数学も大学院終わって大分忘れてきているので、勉強したらその内容でも投稿しようかと。 Pelicanについて ググればいくらでも出ると思いますが、PelicanはPython製の静的サイトジェネレーターです。 （Rubyで言うJekyllとかに値するやつ） 元々個人的に作った社内資料まとめとかにはSphinx使ってて、その流れって感じです。 具体的なPelicanの設定うんぬんは気が向けばそのうち書きます。環境は以下の感じ。 OS Windows10 64bit or Mac OS X El Capitan 諸事情でSierraじゃないです。 Python3.5.2 Pelican 3.6.3 エディタの類 Visual Studio Code Vim その他 Pelican良いと思いますが、ブログを書くという一点のみに着目すると車輪の再発明感も否めないです。 多分好き勝手書いていくと思うので、何か間違ってるとかあればコメントしてもらうか、Twitterにリプなりくれれば多分反応します。 うさぎの画像がたまに出てくるのは大久野島にたまに行くからです。うさぎ好きならおすすめします。一人なら泊る場所は島外にしよう！ PS. 何故か社内Redmineとかも丁寧語になってしまう現象が・・・","tags":"misc","url":"posts/2016/12/25/my-first-article/"}]}